<!DOCTYPE html>
<html lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="css/main.css" />
  <link rel="stylesheet" type="text/css" href="css/cpp.css" />
  <script type="text/javascript" src="script.js"></script>
  <link rel="icon" type="image/png" href="/favicon.png" />
  <title>Ожидание окончания переходных процессов в отдельных частях схемы</title>
</head>

<body onload="DocLoad()">
<p class="top"><a href="index.html#light_connwatch">Назад</a></p>
<div class="text">

<h1>Ожидание окончания переходных процессов в отдельных частях схемы</h1>

<p>Начиная с версии 1.0.509 в RDS добавлен механизм для слежения за изменением значений, передаваемых
группой связей, влияющих на вход заданного блока. Он нужен для обнаружения окончания переходных процессов в
какой-либо части схемы и формирования сигнала готовности значения для блоков итеративного расчета
(например, внешних максимизаторов). В состав RDS включен стандартный блок для формирования такого
сигнала.</p>

<p>В данном тексте п.&nbsp;<a href="#light_p1">1</a>, <a href="#light_p3">3</a> и <a href="#light_p4">4</a>
предназначены для пользователей, п.&nbsp;<a href="#light_p2">2</a> &ndash; для программистов,
создающих модели блоков, и
&laquo;продвинутых&raquo; пользователей, п.&nbsp;<a href="#light_p5">5</a> и <a href="#light_p6">6</a> &ndash;
для программистов.</p>

<p>Также доступны:</p>
<ul>
  <li>этот текст <a href="pdf/RDS_ConnWatcher.pdf">в формате PDF</a>
  (937.21 кб);</li>
  <li><a href="bin/ConnWatcherExamples.zip">примеры схем</a> из этого текста
  (архив &laquo;<span class="file">zip</span>&raquo;, 53.43 кб).</li>
</ul>

<div class="toc">
<div class="level">
  <p>Содержание:</p>
  <div class="level">
    <p><a href="#light_p1">1. Проблема выработки сигнала готовности и ее решение</a></p>
    <p><a href="#light_p2">2. Поддержка нового механизма моделями блоков</a> (для программистов и &laquo;продвинутых&raquo; пользователей)</p>
    <div class="level">
      <p><a href="#light_p2_1">2.1. Использование блоков-переключателей</a></p>
      <p><a href="#light_p2_2">2.2. Передача данных через динамические переменные</a></p>
      <p><a href="#light_p2_3">2.3. Блоки, перезапускающие сами себя</a></p>
    </div>
    <p><a href="#light_p3">3. Блок обнаружения переходного процесса</a></p>
    <p><a href="#light_p4">4. Примеры схем с использованием блока</a></p>
    <div class="level">
      <p><a href="#light_p4_1">4.1. Схема &laquo;1_Ready.rds&raquo; &ndash; наблюдение за процессом</a></p>
      <p><a href="#light_p4_2">4.2. Схема &laquo;2_Ready.rds&raquo; &ndash; один блок на два процесса</a></p>
      <p><a href="#light_p4_3">4.3. Схема &laquo;3_Spoiler.rds&raquo; &ndash; обнуляющий выход блок</a></p>
      <p><a href="#light_p4_4">4.4. Схема &laquo;4_Switcher.rds&raquo; &ndash; влияние выключателей</a></p>
      <p><a href="#light_p4_5">4.5. Схема &laquo;5_MS.rds&raquo; &ndash; мультиплексор</a></p>
      <p><a href="#light_p4_6">4.6. Схема &laquo;6_SW.rds&raquo; &ndash; демультиплексор</a></p>
      <p><a href="#light_p4_7">4.7. Схема &laquo;7_DynVar.rds&raquo; &ndash; передача данных через динамическую переменную</a></p>
      <p><a href="#light_p4_8">4.8. Схема &laquo;8_Max.rds&raquo; &ndash; &laquo;черный ящик&raquo; с внешним максимизатором</a></p>
      <p><a href="#light_p4_9">4.9. Схема &laquo;9_Restarter.rds&raquo; &ndash; перезапускающийся внутренний максимизатор</a></p>
      <p><a href="#light_p4_10">4.10. Схема &laquo;10_Lock.rds&raquo; &ndash; запоминание входных значений</a></p>
      <p><a href="#light_p4_11">4.11. Схема &laquo;11_Bad.rds&raquo; &ndash; расходящийся процесс</a></p>
    </div>
    <p><a href="#light_p5">5. Новые описания, функции и события для наблюдения за переходными процессами</a> (для программистов)</p>
    <div class="level">
      <p><a href="#light_p5_1">5.1. Дополнительные флаги блока</a></p>
      <p><a href="#light_p5_2">5.2. <span class="cpp">RDS_CWCREATEDATA</span> &ndash; структура описания наблюдения за процессом</a></p>
      <p><a href="#light_p5_3">5.3. Функции и макросы</a></p>
        <div class="level">
          <p><a href="#light_p5_3_1">5.3.1. Макрос <span class="cpp">RDS_CWCREATEDATA_RESET</span> &ndash; инициализация структуры описания</a></p>
          <p><a href="#light_p5_3_2">5.3.2. <span class="cpp">rdsCWCreate</span> &ndash; функция создания объекта-наблюдателя</a></p>
          <p><a href="#light_p5_3_3">5.3.3. <span class="cpp">rdsCWCreateCopy</span> &ndash; функция создания копии объекта-наблюдателя</a></p>
          <p><a href="#light_p5_3_4">5.3.4. <span class="cpp">rdsCWGetParameters</span> &ndash; функция чтения параметров объекта-наблюдателя</a></p>
          <p><a href="#light_p5_3_5">5.3.5. Команда <span class="cpp">RDS_CWPARAM_ADDVARNAME</span> &ndash; добавление имени входа</a></p>
          <p><a href="#light_p5_3_6">5.3.6. Команда <span class="cpp">RDS_CWPARAM_ADDVARNUM</span> &ndash; добавление номера входа</a></p>
          <p><a href="#light_p5_3_7">5.3.7. <span class="cpp">rdsCWTranslateChanges</span> &ndash; функция передачи признака изменения из одного объекта в другой</a></p>
        </div>
      <p><a href="#light_p5_4">5.4. Основные реакции блоков</a></p>
        <div class="level">
          <p><a href="#light_p5_4_1">5.4.1. <span class="cpp">RDS_BFM_CONNCHANGEON</span> &ndash; начало переходного процесса</a></p>
          <p><a href="#light_p5_4_2">5.4.2. <span class="cpp">RDS_BFM_CONNCHANGEOFF</span> &ndash; окончание переходного процесса</a></p>
          <p><a href="#light_p5_4_3">5.4.3. <span class="cpp">RDS_BFM_CONNCHANGEERROR</span> &ndash; переходный процесс расходится</a></p>
        </div>
      <p><a href="#light_p5_5">5.5. Дополнительные реакции блоков-переключателей</a></p>
        <div class="level">
          <p><a href="#light_p5_5_1">5.5.1. <span class="cpp">RDS_BFM_CONNCHGCTRLSTART</span> &ndash; предварительный вызов блоков-переключателей</a></p>
          <p><a href="#light_p5_5_2">5.5.2. <span class="cpp">RDS_BFM_CONNCHGCTRLASK</span> &ndash; запрос изменений для выхода блока</a></p>
          <p><a href="#light_p5_5_3">5.5.3. <span class="cpp">RDS_BFM_CONNCHGCTRLEND</span> &ndash; завершающий вызов блоков-переключателей</a></p>
          <p><a href="#light_p5_5_4">5.5.4. <span class="cpp">RDS_BFM_CONNCHGCTRLPROCESS</span> &ndash; передача изменений на выход</a></p>
        </div>
    </div>
    <p><a href="#light_p6">6. Общие правила построения некоторых типовых моделей блоков</a> (для программистов)</p>
    <div class="level">
      <p><a href="#light_p6_1">6.1. Блоки-выключатели связей</a></p>
      <p><a href="#light_p6_2">6.2. Мультиплексоры (много входов, один выход)</a></p>
      <p><a href="#light_p6_3">6.3. Демультиплексоры (один вход, много выходов)</a></p>
      <p><a href="#light_p6_4">6.4. Блок, вычисляющий динамические переменные по значениям входов</a></p>
    </div>
  </div>

</div>
</div>

<h1 id="light_p1">1. Проблема выработки сигнала готовности и ее решение</h1>

<p>В некоторых задачах, например, в задачах с внешним оптимизатором, есть часть схемы
(&laquo;черный ящик&raquo;), включенная в обратную связь какого-либо управляющего блока.</p>

<div class="pic"><div class="container" id="pic1">
<img src="img/ConnWatch_pic1.png" width="701" height="340" alt="Черный ящик в ОС" />
<p id="light_pic1">&laquo;Черный ящик&raquo; в обратной связи управляющего блока</p>
</div></div>

<p>Расчет в этой части схемы выполняется не за один такт, поэтому управляющему блоку необходимо
знать, когда на его входах, подключенных к &laquo;черному ящику&raquo;, установятся правильные
значения. Пока все блоки в &laquo;черном ящике&raquo; не отработали, значения на его
выходах нельзя считать соответствующими входным значениям. По мере срабатывания разных ветвей
схемы выходы &laquo;черного ящика&raquo; будут изменяться, причем между такими изменениями
может пройти довольно много тактов, если в схеме есть длинные цепочки. Управляющий блок должен
дождаться прекращения всех изменений значений на входах всех блоков внутри
&laquo;черного ящика&raquo;, чтобы можно было переходить к следующей итерации и выдавать
на него новую порцию значений. Сейчас эта проблема обычно решается введением в управляющий
блок задержки на заданное число тактов. Это полумера, потому что требуемое число тактов
задержки зависит от структуры &laquo;черного ящика&raquo; и длины максимальной цепочки передачи
в нем. Ситуация осложняется тем, что в &laquo;черном ящике&raquo; могут быть внутренние
обратные связи, что не позволяет просто посчитать число внутренних блоков и ввести это число
(плюс один или плюс два для надежности) в качестве значения задержки &ndash; неизвестно,
сколько тактов будут работать обратные связи, пока вычисления внутри &laquo;черного ящика&raquo;
не завершатся.</p>

<p>Управляющие блоки обычно имеют входной сигнал готовности, поступление которого должно
сигнализировать о завершении вычислений, но &laquo;вытащить&raquo; такой сигнал из
&laquo;черного ящика&raquo; сложной структуры, как правило, не очень просто.</p>

<p>Теперь в RDS включен внутренний механизм обнаружения прекращения изменения передаваемых данных
в заданном наборе связей. Для пользователя он реализован в виде
<a href="#light_p3">блока</a>, который выделяет из
схемы дерево связей и блоков, ведущих к своему входу (далее это дерево будет называться
&laquo;подграфом влияния&raquo; или просто &laquo;подграфом&raquo;), и формирует выходной
сигнал, когда данные, передаваемые по всем связям внутри этого дерева, перестанут изменяться.
Для поддержки работы блока введено несколько сервисных функций и событий, описанных в
п.&nbsp;<a href="#light_p5">5</a>.</p>

<div class="pic"><div class="container" id="pic2">
<img src="img/ConnWatch_pic2.png" width="701" height="340" alt="Подграф влияния" />
<p id="light_pic2">Подключение формирователя сигнала готовности<br />
(подграф, влияющий на готовность, выделен синим)</p>
</div></div>

<p>Технически выделение подграфа связей производится следующим образом: берется связь, идущая к
входу блока готовности, затем все связи, идущие к входам блока, от которого идет эта связь,
затем все связи, идущие к входам блоков, выдающих данные для этих связей и т. д. Таким образом,
строится дерево связей, ведущих к заданному входу блока. На
<a href="#pic2">рисунке</a> все связи подграфа, ведущие к входу блока готовности,
выделены синим цветом.</p>

<p>После того, как множество связей, влияющих на вход блока готовности, составлено, при
их срабатывании RDS будет сравнивать передаваемое с выхода блока значение с текущим значением входа,
на который оно передается. Если они не совпадают с заданной точностью, весь подграф считается изменившимся.
Только если ни одно срабатывание связи в подграфе не привело к изменению значения входа в
течение заданного в настройках блока готовности числа тактов, переходный процесс в &laquo;черном ящике&raquo;
считается завершенным.</p>

<p>Поскольку для анализируемых связей к простому копированию данных из выхода во вход добавляется
еще и предварительное сравнение этих данных, включение этого механизма приведет к некоторому
уменьшению скорости расчета. Оно будет примерно эквивалентно удвоению числа связей в
анализируемом подграфе (на каждый вход &ndash; две операции вместо одной). Но включение
в управляющем блоке задержки на число тактов, заведомо большее числа тактов в самом длинном
переходном процессе, используемое сейчас, замедляет расчет сильнее.</p>

<h1 id="light_p2">2. Поддержка нового механизма моделями блоков</h1>

<p>Абсолютное большинство блоков, как стандартных, так и пользовательских, не требуют каких-либо
модификаций для поддержки механизма обнаружения окончания переходного процесса. Проверка изменений
передаваемых по связям значений делается на уровне RDS, без участия моделей самих блоков. Однако,
некоторые сложные блоки могут выпасть из поля зрения нового механизма, поэтому их модели
необходимо модифицировать. К таким блокам относятся:</p>

<ul>
  <li>различные блоки-переключатели (на их выходы влияют не все входные значения, а
  только те, которые соответствуют текущему состоянию блока);</li>
  <li>блоки, передающие данные через динамические переменные (они не соединены связью и
  поэтому не обнаруживаются при анализе графа схемы);</li>
  <li>блоки, перезапускающие сами себя для выполнения длительного расчета (их выходы долго
  не изменяются, что может послужить ложным сигналом об окончании переходного процесса).</li>
</ul>

<p class="noindent">Во все стандартные модели подобных блоков
<span class="emph">уже внесены необходимые изменения</span>. Пользователи, которые не собираются
создавать собственные модели блоков указанных типов и редко использующие в своих схемах динамические
переменные и блоки-переключатели, могут полностью пропустить
п.&nbsp;2 и перейти к п.&nbsp;<a href="#light_p3">3</a>. Для разработчиков же здесь в общем виде
описываются изменения,
которые необходимо внести в модели таких блоков. Более подробно они описаны в
п.&nbsp;<a href="#light_p5">5</a> и <a href="#light_p6">6</a>.</p>

<h2 id="light_p2_1">2.1. Использование блоков-переключателей</h2>

<p>Включение в RDS механизма слежения за переходными процессами в связях привело к
усложнению моделей блоков-переключателей: выключателей связей, мультиплексоров и демультиплексоров.
Для всех прочих блоков считается, что значения всех выходов блока зависят от значений всех входов, и,
в большинстве случаев, это справедливо. Но у блоков-переключателей все не так. У простого выключателя
связи выход зависит от входа только тогда, когда блок включен. У мультиплексора выход зависит только
от выбранного в данный момент входа. У демультиплексора от входа зависит только один, выбранный в
данный момент, выход (на остальные выходы данные не передаются).</p>

<p>В связи с этим стандартный способ выделения влияющего на готовность подграфа связей,
описанный выше, для этих блоков не работает: нельзя считать, что на все выходы переключателя всегда
влияют все его входы. В данный момент все стандартные блоки-переключатели в RDS модифицированы так,
чтобы самостоятельно разбираться с переходными процессами на своих входах (принципы действия таких
моделей описаны в п.&nbsp;<a href="#light_p6_1">6.1</a>, <a href="#light_p6_2">6.2</a> и
<a href="#light_p6_3">6.3</a>). Фактически, переключатель разрывает анализируемый подграф связей и сам
запрашивает изменения в отдельных подграфах, подключенных к его входам, а затем, согласно логике
своей работы, устанавливает признак изменения выходного подграфа. Пользователю, собирающему схемы и
создающему обычные модели блоков, не обязательно знать, как устроена модель переключателя, и как она
программно передает признаки изменения из входных подграфов в выходные. Для подавляющего большинства
задач подходят стандартные блоки, в которых все необходимые механизмы уже встроены. Но для создания
схем необходимо понимать, что в той части схемы, которая подключена к выходу переключателя,
будут обнаруживаться только те переходные процессы, которые происходят в связях, подключенных к
входу, соответствующему текущему состоянию блока.</p>

<p>В качестве примера рассмотрим условную схему на <a href="#pic3" class="hidden">рисунке ниже</a>.
В ней к разным элементам входного массива &laquo;X&raquo; мультиплексора &laquo;MS dbl&raquo;
подключены две ветви схемы: верхняя ветвь через блоки &laquo;Block2&raquo; и
&laquo;Block4&raquo; принимает данные от внешнего управляющего блока, а нижняя ветвь
(&laquo;Block3&raquo;, &laquo;Block5&raquo;) подключена к полю ввода внутри самого
&laquo;черного ящика&raquo;. Выбор входа мультиплексора, значение которого будет передаваться на
его выход и поступать через блок &laquo;Block1&raquo; в управляющий блок, осуществляет двухпозиционный
блок выбора варианта, подключенный к входу мультиплексора &laquo;N&raquo;.</p>

<div class="pic"><div class="container"
                    id="pic3">
<img src="img/ConnWatch_pic3.png" width="701" height="340" alt="Мультиплексор" />
<p            id="light_pic3">Мультиплексор подключает к управляющему блоку только верхнюю ветвь схемы<br />
(синим выделен главный подграф, зеленым &ndash; подчиненные активные,<br />
тонкими черными линиями &ndash; подчиненный игнорируемый)</p>
</div></div>

<p>Такие конфигурации часто используются для отладки схемы. Если мультиплексор переключен на
нижнюю ветвь, то значения, поступающие на вход блока &laquo;Block1&raquo;, можно задавать вручную
и исследовать поведение этой части схемы. При переключении на верхнюю ветвь значения будут
поступать с управляющего блока.</p>

<p>На рисунке мультиплексор переключен на прием данных с верхней ветви схемы. Это значит, что
любые изменения в нижней ветви схемы будут игнорироваться блоком формирования сигнала готовности
(&laquo;Готовность&raquo;). На сигнал готовности будет влиять только срабатывание связей,
обозначенных жирными синими и зелеными линиями. Информацию об изменениях в синих связях
получает непосредственно блок &laquo;Готовность&raquo;. Информацию об изменениях в зеленых
и черных связях получает мультиплексор. При обнаружении любых изменений в подграфе связей,
подключенном к входу &laquo;N&raquo;, мультиплексор немедленно взводит признак изменения в
выходном подграфе: переключение ветвей схемы способно повлиять на выход мультиплексора и,
таким образом, на ту часть схемы, которая к нему подключена. Любые изменения в черном подграфе,
подключенном к &laquo;X[1]&raquo;, игнорируются: эта ветвь сейчас отключена и никак
не может повлиять на выход блока. Обнаружив изменения в зеленом подграфе, подключенном
&laquo;X[0]&raquo;, мультиплексор опять взводит признак изменения выходного подграфа: при
текущем значении &laquo;N&raquo; этот вход передается на выход. Таким образом, изменения
данных в зеленых связях обнаруживаются не блоком &laquo;Готовность&raquo;, а мультиплексором,
который программно сообщает об изменениях далее по связям.</p>

<p>Конкретные примеры схем с выключателем связей, мультиплексором и демультиплексором
приведены в п.&nbsp;<a href="#light_p4">4</a>.</p>

<h2 id="light_p2_2">2.2. Передача данных через динамические переменные</h2>

<p>Если блок передает данные в другие блоки через динамические переменные, такая передача не
может быть обнаружена при помощи анализа связей. Более того, обнаружить изменения при такой
передаче средствами RDS затруднительно: в отличие от связи, в которой можно сравнить значение
на выходе одного блока со значением на входе другого, динамическая переменная существует
в единственном экземпляре для всех подключенных к ней блоков, ее предыдущее значение нигде
не хранится, и она может быть изменена в любой момент в любой реакции любого блока.</p>

<p>Чтобы при этом можно было все равно анализировать переходные процессы, блок теперь может
установить в своих данных признак того, что изменение значений на его входах приводит к
изменению значений динамических переменных, к которым он подключен. В стандартные блоки для
передачи данных через динамические переменные этот признак уже добавлен. При обнаружении в
анализируемом подграфе блока, подключенного к динамической переменной, автоматически просматриваются
все остальные блоки, подключенные к той же переменной, и, если у кого-нибудь из них установлен
упомянутый выше признак, весь подграф входных связей такого блока включаются в общий подграф
(зеленые связи на <a href="#pic4" class="hidden">рисунке ниже</a>).</p>

<div class="pic"><div class="container"
                    id="pic4">
<img src="img/ConnWatch_pic4.png" width="701" height="340" alt="Связь через динамическую переменную" />
<p            id="light_pic4">Отслеживание передачи данных через динамическую переменную
при анализе графа</p>
</div></div>

<p>Следует учитывать, что не всегда блок, подключенный к динамической переменной, изменяет ее при
изменении своих входов. Например, блок, поставляющий всей схеме значение времени при
динамическом расчете, меняет динамическую переменную &laquo;DynTime&raquo; по таймеру, а не
по своим входам. Для динамических блоков понятие &laquo;завершение переходного процесса&raquo;
определяется течением времени, а не числом выполненных тактов, и, поэтому, имеет другой смысл и
должно анализироваться по-другому. Но у стандартных &laquo;блоков-туннелей&raquo;, включенных в
RDS и подобных изображенным на <a href="#pic4" class="hidden">рисунке</a>, значение динамической
переменной жестко связано именно со значением входа, и для них работает описанный выше механизм.
Если пользователь решит делать собственные аналогичные модели блоков, записывающих значения в
динамические переменные при изменении входов, ему нужно будет программно сообщать об этом в
RDS установкой соответствующего флага (см. п.&nbsp;<a href="#light_p6_4">6.4</a>).</p>

<p>Следует также иметь в виду, что анализ подграфа связей выполняется при переходе в
режим моделирования из режима редактирования, поэтому при этом анализе будут учтены связи блоков
только через динамические переменные,
<span class="emph">существующие на этот момент</span>. Если в процессе расчета блок подключится к
другой динамической переменной, эта связь не будет влиять на проверку окончания переходного процесса.
Сейчас все стандартные блоки RDS подписываются на динамические переменные и создают их в режиме
редактирования, поэтому они будут работать правильно. Если же в какой-то экзотической задаче придется
создавать динамические переменные &laquo;на лету&raquo; в процессе расчета, в такие блоки
придется закладывать логику работы, аналогичную логике блоков-переключателей
(см. п.&nbsp;<a href="#light_p2_1">2.1</a>) &ndash; блок должен самостоятельно обнаруживать переходные
процессы на своих входах и сообщать о них связанным блокам, чтобы они установили флаги изменений
в выходных подграфах.</p>

<p>Пример схемы со связью блоков через динамические переменные, в которой определяется момент окончания
переходного процесса, приведен в п.&nbsp;<a href="#light_p4_7">4.7</a>.</p>

<h2 id="light_p2_3">2.3. Блоки, перезапускающие сами себя</h2>

<p>В некоторых случаях блок, получив на вход данные, должен выполнить достаточно сложный расчет,
занимающий длительное время. Например, внутренний максимизатор многократно вызывает заложенную в
него функцию с разными значениями аргументов, пока не найдет максимальное значение. Блок поиска
равновесия тоже многократно вызывает несколько заложенных в него функций, пока их значения не
придут в состояние равновесия (не перестанут изменяться). Если все эти вызовы выполнять
в цикле в одном такте расчета, RDS не будет реагировать на действия пользователя, пока модель блока,
закончив вычисления, не вернет управление главной программе. Чтобы избежать &laquo;зависания&raquo;
при длительных вычислениях в рамках одного блока, модели таких блоков устроены следующим образом:
модель выполняет только небольшую часть расчета, запоминает, где он остановился, взводит у своего
блока сигнал запуска в следующем такте, запрещает передачу данных с выходов и завершается. В следующем
такте модель снова запустится, выполнит еще одну часть расчета и снова перезапустится. Так будет
продолжаться, пока весь расчет не будет выполнен &ndash; только тогда блок выдаст данные на выходы.</p>

<p>Такой режим работы может помешать правильному обнаружению завершения переходного процесса.
Рассмотрим, например, схему на <a href="#pic5" class="hidden">рисунке ниже</a>. В ней в
&laquo;черный ящик&raquo; включено несколько блоков с внутренним максимизатором на выходе.</p>

<div class="pic"><div class="container"
                    id="pic5">
<img src="img/ConnWatch_pic5.png" width="701" height="340" alt="Перезапускающийся блок" />
<p            id="light_pic5">Наблюдение за переходным процессом в схеме, в которой блок выполняет расчет за несколько тактов,<br />
перезапуская себя и не изменяя выходы</p>
</div></div>

<p>Связи, за переходным процессом в которых будет наблюдать блок &laquo;Готовность&raquo;, на рисунке
обозначены синим цветом. При запуске расчета внешний максимизатор выдаст данные на блок
&laquo;Block1&raquo;, он, в свою очередь, передаст данные блоку
&laquo;Block2&raquo;, а тот &ndash; внутреннему максимизатору. Внутренний максимизатор начнет
вычисления, но пока ничего не выдаст на выход &ndash; он перезапустится. В следующем такте он снова
перезапустится, потом еще раз, и так будет продолжаться до тех пор, пока его расчет не будет завершен.
Но на протяжении всех тактов, когда он перезапускается и продолжает расчет, по связям, обозначенным синим
цветом, не будет передаваться новых значений. Блок &laquo;Готовность&raquo; решит, что переходный
процесс закончился, и выдаст внешнему максимизатору сигнал для начала новой итерации, что
будет ошибкой.</p>

<p>Чтобы избежать этого, блоки могут установить у себя признак продолжающегося расчета. Если в
анализируемом подграфе связей есть хотя бы один блок с таким признаком, переходный процесс в
этом подграфе не будет считаться законченным. Внутренний максимизатор на
<a href="#pic5" class="hidden">рисунке</a> будет устанавливать этот признак при каждом перезапуске,
поэтому, хотя данные по связям и не будут передаваться, сигнал готовности не будет выдан
раньше времени.</p>

<p>На данный момент установка этого признака включена во внутренний максимизатор, блок вычисления
табличной функции и блок поиска равновесия (конкретный пример схемы с внутренним максимизатором приведен
в п.&nbsp;<a href="#light_p4_9">4.9</a>). Если пользователь создает собственный блок, перезапускающийся
для продолжения расчета, он должен программно устанавливать этот признак в модели блока при
каждом перезапуске (см. п.&nbsp;<a href="#light_p6_5">6.5</a>).</p>

<h1 id="light_p3">3. Блок обнаружения переходного процесса</h1>

<p>В набор стандартных блоков RDS введен блок, специально предназначенный для определения начала
и окончания переходного процесса в части схемы, подключенной к его входу. На выходы этот блок выдает
сигналы начала и окончания процесса, а также логический признак того, что переходный процесс
в данный момент идет. Блок добавлен на вкладку &laquo;Управление&raquo; стандартной и
альтернативной панелей блоков, в схеме он изображается прямоугольником с текстом
&laquo;переходный процесс&raquo;.</p>

<div class="pic"><div class="container"
                    id="pic6">
<img src="img/ConnWatch_pic6.png" width="766" height="149" alt="Панель блоков" />
<p            id="light_pic6">Новый блок на панели блоков</p>
</div></div>

<div class="pic"><div class="container"
                    id="pic7">
<img src="img/ConnWatch_pic7.png" width="263" height="77" alt="Внешний вид блока" />
<p            id="light_pic7">Внешний вид блока в схеме</p>
</div></div>

<p>Блок имеет следующие входы и выходы (примеры подключения приведены в п.&nbsp;<a href="#light_p4">4</a>):</p>

<p><b>Check</b> (вход, массив переменных произвольного типа) &ndash; вход для подключения связей, в
подграфах которых отслеживаются переходные процессы. Этот вход &ndash; массив, поэтому связи нужно
подключать к его отдельным элементам. Блок выдает сигнал об окончании переходных процессов только тогда,
когда они завершатся во <span class="emph">всех</span> подключенных к этому входу подграфах (см.
пример в п.&nbsp;<a href="#light_p4_2">4.2</a>).</p>

<p><b>Reset</b> (вход, сигнал) &ndash; вход сброса блока, используемый в специальном режиме работы,
задаваемом в настройках. Если в настройках включено использование этого сигнала, до его
поступления блок будет находиться в режиме ожидания и не будет регистрировать переходные процессы.
После поступления сигнала блок начинает слежение за связями, и снова переходит в режим ожидания по
окончании переходных процессов. Такой режим работы может быть полезен, если блок стоит в обратной связи
максимизатора и формирует для него сигнал очередной итерации, как на
<a href="#pic2">рисунке</a> выше в тексте. Нахождение в режиме ожидания до сообщения от максимизатора
(или другого управляющего блока) о начале итерации позволяет игнорировать переходные процессы,
возникающие в схеме тогда, когда максимизатор выключен (например, при первом запуске расчета), и не
выдавать на него &laquo;лишние&raquo; сигналы готовности. Пример такого подключения приведен в
п.&nbsp;<a href="#light_p4_8">4.8</a>.</p>

<p><b>Begin</b> (выход, сигнал) &ndash; выходной сигнал начала переходного процесса.</p>

<p><b>End</b> (выход, сигнал) &ndash; выходной сигнал окончания переходного процесса (именно
он обычно используется в качестве сигнала готовности для управляющего блока).</p>

<p><b>Calc</b> (выход, логический) &ndash; признак наличия переходного процесса в данный момент.</p>

<p><b>Bad</b> (выход, логический) &ndash; признак расходящегося процесса (если в настройках
блока разрешено обнаружение таких процессов).</p>

<p><b>Error</b> (выход, сигнал) &ndash; выходной сигнал обнаружения расходящегося процесса (см. пример в
п.&nbsp;<a href="#light_p4_11">4.11</a>).</p>

<p><b>Out</b> (выход, массив переменных произвольного типа) &ndash; выходной массив значений,
поступивших на вход &laquo;Check&raquo; на момент окончания переходного процесса (см. пример в
п.&nbsp;<a href="#light_p4_10">4.10</a>).</p>

<p>В окне настроек блока задаются погрешности сравнения вещественных чисел при передаче по связям и
включаются специальные режимы работы.</p>

<div class="pic"><div class="container"
                    id="pic8">
<img src="img/ConnWatch_pic8.png" width="459" height="331" alt="Окно настроек" />
<p            id="light_pic8">Окно настройки блока</p>
</div></div>

<p>Окно содержит следующие настройки:</p>

<p>&laquo;<b>Абсолютная погрешность</b>&raquo; &ndash; если флажок включен, то при передаче
вещественного значения по связи оно будет считаться не изменившимся, если его изменение
по модулю не превышает значения в поле ввода справа (здесь значение, как и в других полях погрешностей,
можно вводить в стандартном формате &laquo;<i>N</i>e<i>M</i>&raquo;, обозначающем
<i>N</i>&times;10<sup><i>M</i></sup>).</p>

<p>&laquo;<b>Относительная погрешность (%)</b>&raquo; &ndash; если флажок включен, то при передаче
вещественного значения по связи оно будет считаться не изменившимся, если его изменение по модулю не
превышает вычисленного по введенной относительной погрешности значения. Абсолютное значение для этой
относительной погрешности вычисляется следующим образом: из старого (до передачи) и нового (после
передачи) значения входа блока берется максимальное по модулю, умножается на введенную относительную
погрешность и делится на 100. Если изменение входа блока по модулю не превышает это вычисленное
значение, вход считается не изменившимся.</p>

<p>&laquo;<b>Абс. порог относительной погрешности</b>&raquo; &ndash; порог изменения, ниже которого
проверка относительной погрешности не производится. Введение этого параметра связано с тем, что при
переходных процессах, плавно сходящихся к нулевому значению на входе блока, вычисляемое значение
относительной погрешности стремится к нулю вместе с самим значением, и проверка попадания в эту
погрешность никогда не выполнится. Поэтому при достижении погрешностью, вычисленной по введенному
значению в процентах, заданного порога, проверка отключается.</p>

<p>Если включены оба флажка погрешностей, значение будет считаться не изменившимся только если
его изменение будет не будет превышать наименьшей из двух погрешностей. Если оба флажка выключены,
для отсутствия изменений значение до передачи должно в точности (до бита) совпадать со значением
после нее.</p>

<p><span class="emph">Важное замечание про погрешности.</span> Следует учитывать, что введенные
значения погрешностей относятся не только к значению, передаваемому связью, подключенной к входу блока
&laquo;Check[&hellip;]&raquo;, но и ко всем значениям всех связей в той части схемы, которая
влияет на вход блока. Будет ошибкой задавать погрешности, исходя из требуемой точности вычисления
конечного значения. Например, если требуемая точность значения выхода &laquo;черного ящика&raquo;,
подключенного к блоку обнаружения переходного процесса, составляет одну десятую, будет ошибкой задать
эту одну десятую в качестве абсолютной погрешности, не учитывая структуру схемы. Если, например,
перед выходом схемы находится блок умножения на десять, то изменению в одну десятую на выходе будет
соответствовать изменение в одну сотую на входе этого умножителя. И это изменение в одну сотую
блок обнаружения переходного процесса не должен пропускать, потому что через несколько тактов оно
доберется до выхода и существенно повлияет на него. Поэтому на практике либо следует задавать в
качестве погрешностей очень маленькие числа, либо вообще отключать оба флажка погрешностей.
В последнем случае переходные процессы будут считаться законченными, только если в схеме не будет
вообще никаких изменений значений. Это может несколько затянуть расчет, особенно схема устроена так,
что значения в ней подходят к установившимся, например, по экспоненте. Но, зато, блок выдаст сигнал
готовности только тогда, когда изменения в схеме полностью прекратятся.</p>

<p>Кроме того, следует учитывать, что задаваемые погрешности описывают изменение значений в
схеме не за какой-то период времени, а за один такт. В отличие от динамических расчетов, где
можно оперировать понятием &laquo;скорость изменения значения&raquo;, здесь речь идет не
о скорости, а о разности между соседними членами числовой последовательности, которую формирует
схема в процесс расчета. Оценить допустимый порог этой разности может быть достаточно сложно.</p>

<p>&laquo;<b>Число тактов ожидания</b>&raquo; &ndash; число тактов расчета, в течение которого
изменения во всех связях исследуемого подграфа схемы должны укладываться в допустимые погрешности,
прежде чем блок выдаст сигнал окончания переходного процесса.</p>

<p>&laquo;<b>Обнаруживать расходящиеся процессы</b>&raquo; &ndash; флажок, включение которого
разрешает блоку проверять, не расходится ли переходный процесс в наблюдаемом подграфе связей.
Проверка работает следующим образом: на протяжении заданного в поле ввода ниже числа тактов
интервала измерения блок определяет максимальное изменение значений входов блока в подграфе.
Если в двух соседних интервалах измерения это значение не уменьшается, процесс считается расходящимся,
и вместо сигнала &laquo;End&raquo; блок выдаст сигнал &laquo;Error&raquo;. Если флажок выключен,
проверка не производится, и при расходящемся переходном процессе блок будет все равно ждать
его окончания (сигнал &laquo;Error&raquo; при этом не выдается).</p>

<p>&laquo;<b>Минимальное число тактов в периоде измерения</b>&raquo; &ndash; число тактов в
интервале измерения для определения расходящегося переходного процесса (блок может автоматически
скорректировать это значение в большую сторону, если в подграфе много связей и блоков). Следует
учитывать, что слишком маленькое число в этом поле ввода может вызвать ложные срабатывания проверки
на расходящийся процесс.</p>

<p>&laquo;<b>Работать только после сигнала &laquo;Reset&raquo;</b>&raquo; &ndash; флажок включает
режим работы, при котором блок переходит в режим ожидания при первом запуске расчета и
после обнаружения окончания переходного процесса. В режиме ожидания блок не будет реагировать
на новые переходные процессы до прихода на вход сигнала &laquo;Reset&raquo;, описанного выше.
Пример использования этого режима приведен в
п.&nbsp;<a href="#light_p4_8">4.8</a>.</p>

<p>&laquo;<b>Ограничить родительской подсистемой и вложенными</b>&raquo; &ndash; флажок включает режим
работы, при котором будут игнорироваться все изменения на входах блоков, находящихся снаружи подсистемы,
в которой находится данный блок, даже если выходы этих блоков влияют на внутренние блоки подсистемы.
В настоящее время этот режим не используется, но может понадобиться в будущем.</p>

<h1 id="light_p4">4. Примеры схем с использованием блока</h1>

<p>Большинство реальных переходных процессов в схемах происходят слишком быстро, чтобы их можно
было наблюдать. Достаточно типичным примером схемы с естественным переходным процессом может
служить сумматор с коэффициентом, меньшим единицы в обратной связи на
<a href="#pic9" class="hidden">рисунке ниже</a> (именно эта схема использовалась для отладки при
разработке блока).</p>

<div class="pic"><div class="container"
                    id="pic9">
<img src="img/ConnWatch_pic9.png" width="577" height="121" alt="Сумматор с обратной связью" />
<p            id="light_pic9">Сумматор с обратной связью</p>
</div></div>

<p>Выход сумматора в такой схеме всегда сходится к какому-либо значению. Число тактов, за
которое переходный процесс прекратится, зависит от коэффициента в обратной связи, а реальное время
переходного процесса &ndash; от быстродействия конкретной машины. Такая схема плохо подходит
для демонстрации работы блока, поскольку в ней приходится подбирать коэффициент индивидуально для каждой
машины, чтобы переходный процесс можно было увидеть в реальном времени.</p>

<p>Из-за этого во всех описываемых ниже примерах схем в качестве тестового переходного процесса
используется работа специально созданного блока (<a href="#pic10" class="hidden">рисунок ниже</a>,
блок &laquo;Счет&raquo;), который сглаживает изменения своего входного значения, дополнительно в
каждом такте модулируя его шумом с амплитудой, уменьшающейся до нуля в течение заданного времени после
приближения выходного значения ко входному.</p>

<div class="pic"><div class="container"
                    id="pic10">
<img src="img/ConnWatch_pic10.png" width="848" height="410" alt="Тестовый блок расчета" />
<p            id="light_pic10">Тестовый блок расчета</p>
</div></div>

<p>Таким образом, если значение на выходе этого блока равно входному, ничего не происходит. Если
входное значение изменится, выходное начнет &laquo;дергаться&raquo; то вверх, то вниз в
каждом такте, постепенно приближаясь к входному (внутрь блока заложен аналог апериодического
звена первого порядка, работающего по реальному времени системы). Когда незашумленное расчетное
значение выхода приблизится к входному, шум начнет линейно уменьшаться до нуля и, в конце
концов, выходное значение снова станет равным входному, и переходный процесс прекратится. Поскольку
блок работает в реальном времени, его переходный процесс будет продолжаться примерно одинаковое время
на машине с любым быстродействием. Кроме того, его можно вывести на график, как на
<a href="#pic10" class="hidden">рисунке</a>, что удобно для наблюдений. Пример схемы с этим блоком
(пока без блока обнаружения переходного процесса), а также с сумматором с обратной связью,
находится в файле &laquo;0_TestProcess.rds&raquo;.</p>

<p>В описанных ниже примерах схем к выходам блока обнаружения переходного процесса обычно
подключены два счетчика и индикатор-семафор, как на <a href="#pic7">рисунке</a> выше в тексте:</p>

<ul>
  <li>к сигнальному выходу &laquo;Begin&raquo; подключен счетчик, выход которого будет
  увеличиваться на единицу при каждом поступлении сигнала о начале переходного процесса;</li>
  <li>к логическому выходу &laquo;Calc&raquo; подключен индикатор-семафор, зажигающийся зеленым,
  если в исследуемом подграфе схемы нет переходного процесса, и красным, если процесс идет;</li>
  <li>к сигнальному выходу &laquo;End&raquo; подключен счетчик, выход которого будет увеличиваться
  на единицу при каждом поступлении сигнала об окончании переходного процесса.</li>
</ul>

<h2 id="light_p4_1">4.1. Схема &laquo;1_Ready.rds&raquo; &ndash; наблюдение за процессом</h2>

<p>Схема &laquo;1_Ready.rds&raquo; содержит три ветви, к каждой из которых подключен блок
обнаружения переходного процесса.</p>

<div class="pic"><div class="container"
                    id="pic11">
<img src="img/ConnWatch_pic11.png" width="992" height="622" alt="1_Ready.rds" />
<p            id="light_pic11">Три переходных процесса в трех ветвях схемы</p>
</div></div>

<p>В средней ветви к тестовому блоку &laquo;Счет&raquo; подключено поле ввода
&laquo;A&raquo;, и наблюдение за переходным процессом ведется относительно выхода тестового блока.
В нижней ветви выход блока &laquo;Счет&raquo; из средней ветви складывается со значением из поля ввода
&laquo;B&raquo; и подается на второй тестовый блок, на выходе которого ведется наблюдение за
переходным процессом. Наконец, в верхней ветви схемы находится блок сравнения значения из поля ввода
&laquo;A&raquo; и выхода первого тестового блока, и ведется наблюдение за переходным процессом на
логическом выходе блока сравнения.</p>

<p>Если запустить расчет, начнутся все три переходных процесса: все три семафора окрасятся
в красный цвет, и на выходах счетчиков, подключенных к сигналам &laquo;Begin&raquo;, появятся
единицы. На среднем и нижнем графиках можно будет наблюдать изменения выходов блоков
&laquo;Счет&raquo; в процессе их работы. Верхний график, подключенный к логическому блоку
сравнения, будет показывать горизонтальную линию на уровне нуля с возможными одиночными выбросами до
единицы: пока блок &laquo;Счет&raquo; в средней ветви не закончит расчет и шум на его
выходе не прекратится, выход этого блока не будет равен его входу, за исключением редких моментов
из-за шума. Поэтому логическое значение на выходе блока сравнения будет держаться на нуле. Но,
несмотря на это, блок обнаружения переходного процесса, подключенный к этому выходу,
будет регистрировать процесс, поскольку в другой части схемы, от которой зависит наблюдаемый выход,
значения меняются.</p>

<p>Когда блок &laquo;Счет&raquo; в средней ветви схемы закончит работу, практически одновременно
закончатся переходные процессы в средней и зависящей от нее верхней ветвях: семафоры окрасятся
в зеленый, и на выходах счетчиков, подключенных к сигналам &laquo;End&raquo;, увеличатся значения.
Переходный процесс в нижней ветви схемы будет идти еще некоторое время, пока не завершит работу
второй блок &laquo;Счет&raquo;. Теперь изменение значения в поле ввода &laquo;A&raquo;
будет вызывать переходные процессы во всех трех ветвях, поскольку нижняя и верхняя зависят
от средней. Изменение значения в поле ввода &laquo;B&raquo; будет вызывать переходный процесс
только в нижней ветви. Это будет наглядно видно по семафорам и счетчикам сигналов, подключенным
к блокам обнаружения переходных процессов.</p>

<h2 id="light_p4_2">4.2. Схема &laquo;2_Ready.rds&raquo; &ndash; один блок на два процесса</h2>

<p>Схема &laquo;2_Ready.rds&raquo; содержит две независимых ветви с общим блоком
обнаружения переходного процесса.</p>

<div class="pic"><div class="container"
                    id="pic12">
<img src="img/ConnWatch_pic12.png" width="986" height="416" alt="2_Ready.rds" />
<p            id="light_pic12">Общий блок наблюдения для двух независимых процессов</p>
</div></div>

<p>Выход верхней ветви схемы присоединен к входу блока &laquo;Check[0]&raquo;, выход нижней
&ndash; к &laquo;Check[1]&raquo;. Это значит, что блок сообщит об окончании переходного процесса
только тогда, когда прекратятся изменения данных в обеих частях схемы. Это видно на рисунке:
в нижней ветви процесс уже закончился (график показывает ровную линию), но в верхней он еще
идет, поэтому семафор окрашен в красный цвет, а выход счетчика сигналов &laquo;Begin&raquo;
на единицу больше выхода счетчика сигналов &laquo;End&raquo; (соответствующий сигнал об
окончании процесса еще не поступил).</p>

<h2 id="light_p4_3">4.3. Схема &laquo;3_Spoiler.rds&raquo; &ndash; обнуляющий выход блок</h2>

<p>Схема &laquo;3_Spoiler.rds&raquo; содержит две ветви. В верхней ветви поле ввода
&laquo;A&raquo; подключено к входу тестового блока &laquo;Счет&raquo;, на выходе которого
наблюдается переходный процесс. К этому же выходу подключен специальный блок
&laquo;Ноль&raquo;, который, независимо от того, что поступает на его вход, выдает ноль
на свой выход. Этот выход в нижней ветви суммируется со значением поля ввода &laquo;B&raquo;,
и на выходе сумматора наблюдается второй переходный процесс.</p>

<div class="pic"><div class="container"
                    id="pic13">
<img src="img/ConnWatch_pic13.png" width="977" height="452" alt="3_Spoiler.rds" />
<p            id="light_pic13">Обнуляющий выход блок не мешает обнаружению переходного процесса</p>
</div></div>

<p>Можно видеть что, несмотря на то, что на выходе сумматора в нижней ветви значение остается
постоянным и равным значению поля ввода &laquo;B&raquo;, блок показывает там наличие переходного
процесса. Это происходит потому, что блок обнаружения переходного процесса в нижней ветви видит,
что на входе блока &laquo;Ноль&raquo;, который формально может влиять на нижнюю ветвь,
изменяется значение. Механизм обнаружения переходных процессов, естественно, не знает о том, что
модель блока &laquo;Ноль&raquo; написана так, что его вход игнорируется и не влияет на выход.
Это было полезно в схеме из <a href="#light_p4_1">примера &laquo;1_Ready.rds&raquo;</a>,
где переходный процесс обнаруживался на выходе блока сравнения, хотя само значение на его выходе
не менялось. Но, в данном случае, если бы блок &laquo;Ноль&raquo; был выключателем, переведенным
в выключенное состояние пользователем, его вход нужно было бы игнорировать. Именно поэтому, как
уже упоминалось в п.&nbsp;<a href="#light_p2_1">2.1</a>, модели блоков-переключателей должны быть написаны
специальным образом, чтобы правильно передавать на выход информацию о переходных процессах
на своих входах. Общие правила написания таких моделей приведены в
п.&nbsp;<a href="#light_p6">6</a>.</p>

<h2 id="light_p4_4">4.4. Схема &laquo;4_Switcher.rds&raquo; &ndash; влияние выключателей</h2>

<p>Схема &laquo;4_Switcher.rds&raquo; состоит из трех ветвей. В верхней ветви к полю ввода
&laquo;A&raquo; подключен блок &laquo;Счет&raquo;, выход которого через стандартные
блоки-выключатели подключается к сумматорам в средней и нижней ветви, причем в нижней ветви
этот выход подается на сумматор через обнуляющий выход блок &laquo;Ноль&raquo; из
<a href="#light_p4_3">предыдущего примера</a> &laquo;3_Spoiler.rds&raquo;.</p>

<div class="pic"><div class="container"
                    id="pic14">
<img src="img/ConnWatch_pic14.png" width="981" height="622" alt="4_Switcher.rds" />
<p            id="light_pic14">Блоки-выключатели отсекают информацию о переходных процессах на входах в выключенном состоянии</p>
</div></div>

<p>Модели блоков-выключателей сделаны так, что в выключенном состоянии информация о переходном
процессе на входе блока не доходит до выхода. На рисунке видно, что в верхней ветви схемы идет
переходный процесс. В средней ветви схемы выключатель включен (кнопка &laquo;Вкл 1&raquo; нажата),
поэтому переходный процесс там тоже наблюдается. В нижней же ветви выключатель разрывает соединение, и
переходный процесс там не обнаруживается &ndash; семафор окрашен в зеленый цвет.</p>

<p>Если нажать кнопку &laquo;Вкл 2&raquo;, подключив тем самым нижнюю ветвь схемы к верхней,
переходный процесс, идущий в верхней ветви, будет обнаруживаться и в нижней, несмотря на то,
что реальные данные с выхода блока &laquo;Счет&raquo; на нижнюю ветвь не проходят из-за блока
&laquo;Ноль&raquo;, и значение на графике не будет изменяться.</p>

<p>С точки зрения обнаружения переходных процессов блоки-выключатели работают следующим образом:</p>

<ul>
  <li>переходный процесс на входе включения &laquo;Enable&raquo; всегда
  обнаруживается на выходе блока;</li>
  <li>переходный процесс на входе данных &laquo;x&raquo; обнаруживается на выходе блока
  только тогда, когда блок включен, т. е. на входе &laquo;Enable&raquo; не нулевое значение.</li>
</ul>

<h2 id="light_p4_5">4.5. Схема &laquo;5_MS.rds&raquo; &ndash; мультиплексор</h2>

<p>В схеме &laquo;5_MS.rds&raquo; мультиплексор переключает два входа на один выход.</p>

<div class="pic"><div class="container"
                    id="pic15">
<img src="img/ConnWatch_pic15.png" width="1001" height="602" alt="5_MS.rds" />
<p            id="light_pic15">Мультиплексор &laquo;MS dbl&raquo; передает на выход только один из входов</p>
</div></div>

<p>Левая часть схемы состоит из двух независимых ветвей: верхняя подключена к входу мультиплексора
&laquo;X[0]&raquo;, нижняя &ndash; к &laquo;X[1]&raquo;. Выход мультиплексора через сумматор
подключен к третьей (правой) ветви схемы.</p>

<p>Мультиплексор передает на свой выход значение только с того элемента входного массива &laquo;X&raquo;,
индекс которого поступает на вход &laquo;N&raquo;. Информацию о переходных процессах он передает
таким же образом. На рисунке видно, что в левой нижней ветви схемы идет переходный процесс.
Но в правой ветви он не обнаруживается: блок выбора варианта, подключенный к входу
&laquo;N&raquo; мультиплексора, разрешает передачу на выход только данных с входа
&laquo;X[0]&raquo;, а в подключенной к нему ветви переходного процесса нет. Если щелкнуть мышью по
надписи &laquo;Нижний&raquo;, к выходу мультиплексора подключится вход &laquo;X[1]&raquo;,
и переходный процесс на выходе сразу же будет обнаружен.</p>

<p>С точки зрения обнаружения переходных процессов мультиплексоры работают следующим образом:</p>

<ul>
  <li>переходный процесс на входе номера &laquo;N&raquo; всегда обнаруживается на выходе блока;</li>
  <li>из всех переходных процессов в частях схемы, подключенных к <i>отдельным элементам</i>
  входного массива &laquo;X&raquo;, на выходе будет обнаружен только тот, который подключен к
  элементу с индексом, равным значению входа &laquo;N&raquo;;</li>
  <li>если к входу &laquo;Х&raquo; подключена матрица (этот вариант практически не используется),
  переходный процесс на таком входе будет всегда обнаруживаться на выходе.</li>
</ul>

<h2 id="light_p4_6">4.6. Схема &laquo;6_SW.rds&raquo; &ndash; демультиплексор</h2>

<p>В схеме &laquo;6_SW.rds&raquo; демультиплексор переключает один вход на два выхода.</p>

<div class="pic"><div class="container"
                    id="pic16">
<img src="img/ConnWatch_pic16.png" width="1000" height="622" alt="6_SW.rds" />
<p            id="light_pic16">Демультиплексор &laquo;SW dbl&raquo; передает вход только на один из выходов</p>
</div></div>

<p>В левой части схемы находится тестовый блок &laquo;Счет&raquo;, выход которого подключен к входу
&laquo;x&raquo; демультиплексора &laquo;SW dbl&raquo;. В правой части схемы &ndash;
две независимых ветви: верхняя подключена к выходу демультиплексора &laquo;Y[0]&raquo;, правая &ndash;
к &laquo;Y[1]&raquo;. К входу &laquo;N&raquo; подключен блок выбора варианта, с помощью
которого можно выбирать выход, получающий значение входа.</p>

<p>На <a href="#pic16">рисунке</a> видно, что в левой части схемы идет переходный процесс.
Блок выбора варианта разрешает передачу данных оттуда только в правую верхнюю ветвь, поэтому
переходный процесс обнаруживается и там (семафор окрашен в красный цвет). Данные в нижнюю
правую ветвь не передаются, поэтому там не виден переходный процесс (семафор зеленый), хотя формально
на входе одного из блоков во влияющем подграфе есть изменение данных.</p>

<p>С точки зрения обнаружения переходных процессов демультиплексоры работают следующим образом:</p>
<ul>
  <li>переходный процесс на входе номера &laquo;N&raquo; всегда обнаруживается на всех
  выходах блока;</li>
  <li>переходный процесс на входе данных обнаруживается только в той части схемы, которая
  подключена к элементу выходного массива данных &laquo;Y[&hellip;]&raquo;, индекс которого равен
  текущему значению входа &laquo;N&raquo;.</li>
</ul>

<h2 id="light_p4_7">4.7. Схема &laquo;7_DynVar.rds&raquo; &ndash; передача данных через динамическую переменную</h2>

<p>Схема &laquo;7_DynVar.rds&raquo; представляет собой схему
<a href="#pic11">примера</a> &laquo;1_Ready.rds&raquo;, в которой линии связи,
соединяющие ветви схемы, заменены на передачу данных через динамические переменные.</p>

<div class="pic"><div class="container"
                    id="pic17">
<img src="img/ConnWatch_pic17.png" width="981" height="624" alt="7_DynVar.rds" />
<p            id="light_pic17">Несмотря на отсутствие линий связи, переходные процессы
обнаруживаются в частях схемы, получающих данные через динамические переменные</p>
</div></div>

<p>На <a href="#pic17" class="hidden">рисунке</a> можно видеть, что, несмотря на то, что между блоком
&laquo;Счет&raquo;, присоединенным к полю ввода &laquo;A&raquo;, и остальными частями схемы нет
линий связи, переходный процесс, вызванный его работой, обнаруживается во всех трех ветвях.
Причем в верхней ветви схемы, получающей логическое значение через динамическую переменную
&laquo;Equal&raquo;, данные не изменяются, то есть обнаружение переходного процесса (красный
семафор) вызвано не изменением значений в самой ветви и ее подграфе связей, а изменениями значений
&laquo;по ту сторону&raquo; динамической переменной.</p>

<p>Такое обнаружение переходного процесса возможно из-за изменений, внесенных в стандартный блок
работы с динамическими переменными. Если пользователь создает собственные (например, автокомпилируемые)
блоки, записывающие данные в динамические переменные, ему нужно уведомить RDS об этом
(см. п.&nbsp;<a href="#light_p2_2">2.2</a> и <a href="#light_p6_4">6.4</a>).</p>

<p>В левой нижней части схемы находится подсистема (ее содержимое на <a href="#pic17" class="hidden">рисунке</a>
не приводится), внутри которой переходный процесс в данных, передающихся через динамическую
переменную &laquo;DynVar1&raquo;, тоже обнаруживается, несмотря на полное отсутствие связей,
входящих в эту подсистему.</p>

<h2 id="light_p4_8">4.8. Схема &laquo;8_Max.rds&raquo; &ndash; &laquo;черный ящик&raquo; с внешним максимизатором</h2>

<p>В схеме &laquo;8_Max.rds&raquo; блок наблюдения за переходным процессом используется для
формирования сигнала готовности данных очередной итерации в обратной связи
внешнего максимизатора.</p>

<div class="pic"><div class="container"
                    id="pic18">
<img src="img/ConnWatch_pic18.png" width="1004" height="609" alt="8_Max.rds" />
<p            id="light_pic18">Блок наблюдения за переходным процессом, формирующий сигнал готовности
данных для внешнего максимизатора</p>
</div></div>

<p>В верхней части схемы из отдельных блоков собран &laquo;черный ящик&raquo;, вычисляющий формулу</p>

<p class="center">&minus;(<i>x</i><sub>1</sub>&minus;<i>x</i><sub>1o</sub>)<sup>2</sup>&nbsp;&minus;&nbsp;(<i>x</i><sub>2</sub>&minus;<i>x</i><sub>2o</sub>)<sup>2</sup>.</p>

<p>Чтобы переходные процессы в этой части схемы можно было увидеть, в нее включены два тестовых
блока &laquo;Счет&raquo;, задерживающих установление конечных значений. В нижней части
схемы находится внешний максимизатор, настроенный на перебор двух параметров:
<i>x</i><sub>1</sub> (&laquo;P[0]&raquo;) и <i>x</i><sub>2</sub> (&laquo;P[1]&raquo;) в диапазоне
[&minus;5,5] с шагом 1. В качестве значений <i>x</i><sub>1o</sub> и <i>x</i><sub>2o</sub> заданы 1 и 2 соответственно.
Таким образом, очевидно, что максимизируемая функция представляет собой перевернутый параболоид вращения
с максимумом в точке (1,2).</p>

<p>Для того, чтобы максимизатор не начинал следующую итерацию раньше времени, к выходу схемы вычисления
максимизируемой функции (&laquo;черного ящика&raquo;) подключен вход &laquo;Check[0]&raquo; блока
наблюдения за переходным процессом, выходной сигнал &laquo;End&raquo; (окончание процесса)
которого подается на вход &laquo;CritReady&raquo; (готовность значения критерия) максимизатора.
Сигнал начала итерации максимизатора &laquo;Go&raquo; одновременно подается на входы
&laquo;Check[1]&raquo; и &laquo;Reset&raquo; блока наблюдения, причем блок настроен так,
чтобы не реагировать на новый переходный процесс до сигнала &laquo;Reset&raquo;
(см. п.&nbsp;<a href="#light_p3">3</a>). На вход &laquo;Crit&raquo; максимизатора подается вычисленное
значение функции.</p>

<p>Когда максимизатор начинает очередную итерацию, он устанавливает на своих выходах
&laquo;P[&hellip;]&raquo; очередную пару значений параметров, выдает сигнал &laquo;Go&raquo;
и начинает ждать сигнала на входе &laquo;CritReady&raquo;. Сигнал &laquo;Go&raquo; попадает на
вход &laquo;Reset&raquo; блока наблюдения и выводит его из режима ожидания. Одновременно он
попадает на вход &laquo;Check[1]&raquo; этого же блока, из-за чего блок немедленно
регистрирует начало переходного процесса. В схеме &laquo;черного ящика&raquo; при этом
начинается изменение данных в процессе вычисления значения функции для новых значений
параметров. Только когда эти изменения закончатся и выходное значение установится, блок
наблюдения выдаст сигнал &laquo;End&raquo;, который, поступив в максимизатор, заставит
его взять вычисленное значение функции с входа &laquo;Crit&raquo; и перейти к следующей итерации.</p>

<p>Если запустить расчет, можно увидеть, что, несмотря на сильные колебания значений на входе
максимизатора &laquo;Crit&raquo;, трехмерный график отобразит правильный вид исследованной
функции &ndash; это значит, что значения функции считывались в правильные моменты. Счетчик сигналов
&laquo;End&raquo; при этом покажет значение &laquo;122&raquo;: значения функции были вычислены
в сетке 11&times;11 точек, и последнюю итерацию максимизатор выполнил с найденными
оптимальными значениями параметров.</p>

<p>В данной схеме можно было не настраивать блок наблюдения на переход в режим ожидания по
окончании переходного процесса и не подключать сигнал к его входу &laquo;Reset&raquo; &ndash;
схема работала бы и так. Но в более сложных схемах, где в некоторых режимах работы
&laquo;черный ящик&raquo; может использоваться не только для максимизации, лучше
сделать эти настройки и подключения, чтобы переходные процессы, не связанные с максимизацией,
игнорировались и не подавали сигналов на максимизатор.</p>

<p>Подача сигнала &laquo;Go&raquo; с максимизатора на вход &laquo;Check[1]&raquo;
блока наблюдения в данной схеме необходима в любом случае. Дело в том, что вычисляемая
&laquo;черным ящиком&raquo; функция может оказаться такой, что ее максимум будет найден в
самой последней итерации перебора. Если это произойдет, после окончания перебора
для последнего прохода с максимальными значениями максимизатор снова установит на выходе те
же самые значения параметров, и будет ждать сигнала о готовности данных функции. Но,
поскольку значения на входе &laquo;черного ящика&raquo; не изменились, переходного процесса в
схеме не будет, и блок наблюдения никогда на подаст сигнала &laquo;End&raquo; на основании
наблюдения только за самим &laquo;черным ящиком&raquo; через вход &laquo;Check[0]&raquo;.
Подача сигнала &laquo;Go&raquo; на &laquo;Check[1]&raquo; гарантирует, что блок
зарегистрирует начало переходного процесса в каждой, даже &laquo;лишней&raquo;, итерации,
какие бы значения максимизатор не подал на &laquo;черный ящик&raquo;.</p>

<h2 id="light_p4_9">4.9. Схема &laquo;9_Restarter.rds&raquo; &ndash; перезапускающийся внутренний максимизатор</h2>

<p>Схема &laquo;9_Restarter.rds&raquo; иллюстрирует обнаружение переходного процесса в схеме,
блоки которой разбивают свой внутренний расчет на несколько тактов, перезапуская сами себя.
Обычно это делается для того, чтобы не блокировать полностью работу RDS до завершения длительного
расчета: пока модель блока не вернет управление, RDS не будет реагировать на действия пользователя и
другие события. В данной схеме в качестве такого перезапускающегося блока используется
внутренний максимизатор, внутрь которого заложена функция</p>

<p class="center">&minus; <i>x</i><sup>2</sup> &minus; <i>k</i> <i>y</i><sup>2</sup>.</p>

<p class="noindent">Для того, чтобы переходный процесс в схеме не протекал слишком быстро,
и его можно было увидеть, к оператору вычисления функции добавлена задержка при помощи вызова
&laquo;<span class="cpp">Sleep(5)</span>&raquo;.</p>

<div class="pic"><div class="container"
                    id="pic19">
<img src="img/ConnWatch_pic19.png" width="924" height="409" alt="9_Restarter.rds, расчет идет" />
<p            id="light_pic19">Схема с перезапускающимся блоком &ndash; переходный процесс идет,
хотя изменений в наблюдаемом подграфе нет</p>
</div></div>

<p>На <a href="#pic19" class="hidden">рисунке выше</a> схема изображена в середине переходного
процесса &ndash; максимизатор продолжает вычислять функцию и перезапускаться, это видно по
не заполненному до конца индикатору, подключенному к выходу &laquo;Progress_out&raquo;.
Блок наблюдения за переходным процессом, подключенный к выходу &laquo;AllMax_out&raquo;
(матрица всех найденных максимумов) показывает наличие переходного процесса, несмотря на то,
что никакие данные в подграфе, влияющем на этот выход (в него входит связь от
&laquo;AllMax_out&raquo; и все входные связи максимизатора) не передаются уже в течение
многих тактов, и значения на входах не меняются. Это достигается за счет того, что максимизатор,
перезапускаясь, <a href="#light_p6_5" class="hidden">устанавливает</a>
специальный признак незавершенного расчета.</p>

<p>Когда расчет в макисимизаторе закончится, он уже не будет устанавливать этот признак,
и блок наблюдения получит информацию о завершении переходного процесса.</p>

<div class="pic"><div class="container"
                    id="pic20">
<img src="img/ConnWatch_pic20.png" width="924" height="409" alt="9_Restarter.rds, расчет завершен" />
<p            id="light_pic20">Схема с перезапускающимся блоком &ndash; переходный процесс завершен</p>
</div></div>

<p>Модели всех стандартных перезапускающихся блоков уже изменены таким образом, чтобы сообщать
в RDS о переходных процессах. Если пользователь будет создавать собственные модели подобных блоков,
ему нужно будет ввести в них установку признака незавершенного расчета
(см. п.&nbsp;<a href="#light_p6_5">6.5</a>).</p>

<h2 id="light_p4_10">4.10. Схема &laquo;10_Lock.rds&raquo; &ndash; запоминание входных значений</h2>

<p>Схема &laquo;10_Lock.rds&raquo; иллюстрирует использование блока обнаружения переходного
процесса в качестве регистра-защелки для входа &laquo;Check&raquo;.</p>

<div class="pic"><div class="container"
                    id="pic21">
<img src="img/ConnWatch_pic21.png" width="992" height="244" alt="10_Lock.rds" />
<p            id="light_pic21">Запоминание входных значений блока</p>
</div></div>

<p>У блока есть выходной массив &laquo;Out&raquo;, на который выдаются значения,
оказавшиеся во входном массиве &laquo;Check&raquo; на момент окончания переходного процесса.
Значение, поданное на &laquo;Check[0]&raquo;, будет передано на &laquo;Out[0]&raquo;,
&laquo;Check[1]&raquo; &ndash; на &laquo;Out[1]&raquo; и т. д. Значения выдаются только тогда,
когда переходный процесс закончится, они не меняются, пока процесс идет. Хотя значение на входе
&laquo;Check[0]&raquo; изменяется постоянно, значение на индикаторе под графиком на рисунке
изменится только по окончании переходного процесса. Если изменить значение в поле ввода &laquo;A&raquo;,
значение на индикаторе будет оставаться неизменным до окончания нового переходного процесса в схеме,
и только потом скачком изменится на новое, установившееся, значение.</p>

<h2 id="light_p4_11">4.11. Схема &laquo;11_Bad.rds&raquo; &ndash; расходящийся процесс</h2>

<p>Схема &laquo;11_Bad.rds&raquo; содержит специальный демонстрационный блок &laquo;Шум&raquo;,
выдающий на выход постоянно изменяющиеся значения. Выход этого блока пропускается через обнуляющий блок
и через выключатель суммируется со схемой, выдающей сходящийся переходный процесс
(см. <a href="#pic9">рисунок</a> в начале описания примеров). К выходу сумматора подключен блок
обнаружения переходного процесса, в настройках которого разрешена проверка на расхождение
(см. п.&nbsp;<a href="#light_p3">3</a>).</p>

<div class="pic"><div class="container"
                    id="pic22">
<img src="img/ConnWatch_pic22.png" width="908" height="328" alt="11_Bad.rds" />
<p            id="light_pic22">Обнаружение расходящегося переходного процесса</p>
</div></div>

<p>В этой схеме для иллюстрации расходящегося процесса нельзя использовать блок
&laquo;<a href="#pic10">Счет</a>&raquo;, создававший тестовый переходный процесс во
всех предыдущих примерах. Дело в том, что блок &laquo;Счет&raquo; заканчивает свой
процесс по времени, чтобы его хорошо было видно на графиках. Из-за этого процесс может
занимать очень много тактов, причем число тактов зависит от быстродействия машины, на которой
работает схема. А обнаружение расходящегося процесса работает именно по числу тактов,
поэтому, в большинстве случаев, выход блока &laquo;Счет&raquo; будет считаться расходящимся
процессом &ndash; по числу тактов он слишком длинный. Здесь для генерации сходящегося
процесса используется сумматор с меньшим единицы коэффициентом в обратной связи,
его выход плавно увеличивается до установившегося значения с постоянно уменьшающимся приращением &ndash;
это типичный сходящийся процесс. Скорость схождения можно регулировать, увеличивая
коэффициент в обратной связи: чем ближе он к единице, тем дольше будет идти процесс (при
коэффициенте, равном единице или большем, процесс расходится).</p>

<p>Если выключатель включен, в анализируемый подграф будет входить выход блока &laquo;Шум&raquo;,
и блок обнаружения переходного процесса вместо сигнала &laquo;End&raquo; выдаст сигнал
&laquo;Error&raquo;.</p>

<h1 id="light_p5">5. Новые описания, функции и события для наблюдения за переходными процессами</h1>

<p>Здесь описываются дополнения к программному интерфейсу RDS, предназначенные для создания
моделей блоков с наблюдением за переходными процессами. Общие принципы использования этих дополнений
для различных типовых моделей приведены в п.&nbsp;<a href="#light_p6">6</a>.</p>

<h2 id="light_p5_1">5.1. Дополнительные флаги блока</h2>

<p>Для того, чтобы модели блоков-переключателей и перезапускающих себя блоков
(см. п.&nbsp;<a href="#light_p2">2</a>) могли участвовать в обнаружении переходных процессов, в поле
<span class="cpp">Flags</span> структуры данных блока <span class="cpp">RDS_BLOCKDATA</span>
(см. приложение А.2.3) добавлено несколько новых флагов:</p>

<dl>
  <dt><span class="cpp">RDS_CONNCHANGECTRL</span></dt>
  <dd>Если этот флаг взведен, блок &laquo;разрывает&raquo; анализируемый подграф связей.
  При этом он должен самостоятельно определять, как переходные процессы на его входах влияют
  на переходные процессы на выходах. Обычно этот флаг взводят модели блоков-переключателей,
  мультиплексоров и т. п. (см. п.&nbsp;<a href="#light_p2_1">2.1</a>). После установки этого флага
  блок начинает реагировать на <a href="#light_p5_5">дополнительные события</a>.</dd>

  <dt><span class="cpp">RDS_DYNVARBYINPUT</span></dt>
  <dd>Если этот флаг взведен, входы блока влияют на значения всех динамических переменных, на
  которые он подписан. Этот факт используется при анализе подграфа связей, влияющего на какое-либо
  выходное значение (см. п.&nbsp;<a href="#light_p2_2">2.2</a>). При этом считается, что любой
  вход влияет на все динамические переменные, как-либо разделить их невозможно.</dd>

  <dt><span class="cpp">RDS_MULTICALC</span></dt>
  <dd>Взведением этого флага блок сообщает о том, что он может перезапускать сам себя
  для выполнения длительных расчетов (см. п.&nbsp;<a href="#light_p2_3">2.3</a>). Для таких блоков
  будет проверяться состояние флага <span class="cpp">RDS_MULTICALCON</span>, описанного ниже,
  и переходный процесс не будет считаться завершенным, пока блок не прекратит перезапускаться.</dd>

  <dt><span class="cpp">RDS_MULTICALCON</span></dt>
  <dd>Если блок перезапустил сам себя для продолжения длительного расчета, который он не успел
  выполнить за прошедший такт, этот флаг необходимо установить. Флаг автоматически сбрасывается перед
  каждым вызовом реакции блока на такт расчета, поэтому его необходимо устанавливать при каждом
  перезапуске. Флаг проверяется только у блоков, у которых установлен еще и
  <span class="cpp">RDS_MULTICALC</span>.</dd>
</dl>

<h2 id="light_p5_2">5.2. <span class="cpp">RDS_CWCREATEDATA</span> &ndash; структура описания наблюдения за процессом</h2>

<p>Структура <span class="cpp">RDS_CWCREATEDATA</span> используется при создании вспомогательного
объекта для наблюдения за переходным процессом, в ней указываются значения погрешностей и другие
параметры наблюдения. Поля структуры соответствуют <a href="#pic8">настройкам</a>
стандартного блока обнаружения переходного процесса, описанного в п.&nbsp;<a href="#light_p3">3</a>.</p>

<pre class="cpp">  <span class="kw">typedef</span> <span class="kw">struct</span>
  { DWORD servSize;      <span class="rem">// Размер этой структуры в байтах</span>
    <span class="kw">int</span> Ticks;           <span class="rem">// Число последовательных тактов</span>
                         <span class="rem">// без изменений</span>
    <span class="kw">double</span> RelDelta;     <span class="rem">// Относительная погрешность в долях</span>
                         <span class="rem">// значения, или -1 для отключения</span>
    <span class="kw">double</span> MinDeltaRel;  <span class="rem">// Абсолютный порог относительной погрешности</span>
    <span class="kw">double</span> AbsDelta;     <span class="rem">// Абсолютная погрешность или -1</span>
                         <span class="rem">// для отключения</span>
    BOOL CheckBadProcess;  <span class="rem">// Проверка на расходящийся процесс</span>
    <span class="kw">int</span> MinBadProcessTicks;<span class="rem">// Интервал измерения (в тактах) для</span>
                           <span class="rem">// расходящегося процесса</span>
  } RDS_CWCREATEDATA;
  <span class="kw">typedef</span> RDS_CWCREATEDATA *RDS_PCWCREATEDATA;</pre>

<p class="apphdr">Поля структуры</p>

<dl>
  <dt><span class="cpp">servSize</span>&emsp;(<span class="cpp"><i>DWORD</i></span>)</dt>
  <dd>Размер этой структуры в байтах. Перед вызовом любой сервисной функции, работающей с этой
  структурой, полю <span class="cpp">servSize</span> необходимо присвоить значение
  <span class="cpp">sizeof(RDS_CWCREATEDATA)</span>.</dd>

  <dt><span class="cpp">Ticks</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Число последовательных тактов расчета, в течение которых изменения во всех связях
  исследуемого подграфа схемы должны укладываться в допустимые погрешности, прежде чем наступит событие
  окончания переходного процесса.</dd>

  <dt><span class="cpp">RelDelta</span>&emsp;(<span class="cpp"><i>double</i></span>)</dt>
  <dd>Относительная погрешность изменения входа блока при срабатывании связи, ниже которой вход будет
  считаться не изменившимся. Погрешность задается в долях значения входа (не в процентах, как
  в настройках стандартного блока), задание &laquo;&minus;1&raquo; отключает проверку
  относительной погрешности.</dd>

  <dt><span class="cpp">MinDeltaRel</span>&emsp;(<span class="cpp"><i>double</i></span>)</dt>
  <dd>Порог абсолютного изменения входа блока при срабатывании связи, ниже которого проверка относительной
  погрешности не производится. Без этого порога при переходных процессах, плавно сходящихся
  к нулевому значению на входе блока, вычисляемое значение относительной погрешности стремится
  к нулю вместе с самим значением, и проверка попадания в эту погрешность никогда не выполнится.</dd>

  <dt><span class="cpp">AbsDelta</span>&emsp;(<span class="cpp"><i>double</i></span>)</dt>
  <dd>Абсолютная погрешность изменения входа блока при срабатывании связи, ниже которой вход
  будет считаться не изменившимся. Задание &laquo;&minus;1&raquo; отключает
  проверку абсолютной погрешности.</dd>

  <dt><span class="cpp">CheckBadProcess</span>&emsp;(<span class="cpp"><i>BOOL</i></span>)</dt>
  <dd>Разрешение (<span class="cpp">TRUE</span>) или запрет (<span class="cpp">FALSE</span>)
  определения расходящихся переходных процессов.</dd>

  <dt><span class="cpp">MinBadProcessTicks</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Минимально допустимое число тактов в интервале проверки уменьшения изменений на входах
  блоков для определения расходящегося переходного процесса (блок может автоматически скорректировать это
  значение в большую сторону, если в подграфе много связей и блоков).</dd>
</dl>

<p class="noindent">Если не заданы ни относительная, ни абсолютная погрешности, отсутствием
изменений при передаче значения по связи будет считаться точное (до бита) совпадение значений.</p>

<h2 id="light_p5_3">5.3. Функции и макросы</h2>

<h3 id="light_p5_3_1">5.3.1. Макрос <span class="cpp">RDS_CWCREATEDATA_RESET</span> &ndash; инициализация структуры описания</h3>

<p>Макрос <span class="cpp">RDS_CWCREATEDATA_RESET</span> предназначен для начальной установки
всех полей в структуре <a href="#light_p5_2"><span class="cpp">RDS_CWCREATEDATA</span></a> таким
образом, чтобы все погрешности и все дополнительные проверки были отключены.</p>

<pre class="cpp">  RDS_CWCREATEDATA_RESET(
    data    <span class="rem">// Структура RDS_CWCREATEDATA</span>
  )</pre>

<p class="apphdr">Определение</p>
<pre class="cpp">  <span class="preproc">#define RDS_CWCREATEDATA_RESET(data) \</span>
<span class="preproc">    {data.servSize=sizeof(data); \</span>
<span class="preproc">     data.Ticks=data.MinBadProcessTicks=0; \</span>
<span class="preproc">     data.RelDelta=data.MinDeltaRel=data.AbsDelta=-1.0; \</span>
<span class="preproc">     data.CheckBadProcess=FALSE;}</span></pre>

<p class="apphdr">Параметр</p>

<dl>
  <dt><span class="cpp">data</span>&emsp;(<span class="cpp"><i>RDS_CWCREATEDATA</i></span>)</dt>
  <dd>Очищаемая структура <span class="cpp">RDS_CWCREATEDATA</span> (сам объект, не указатель).</dd>
</dl>

<p class="apphdr">Примечания</p>

<p>Этим макросом желательно очищать структуру <span class="cpp">RDS_CWCREATEDATA</span>
перед использованием и вызовом функций, принимающих в качестве параметра указатель на нее. Если в будущем в структуру
будут добавлены новые поля, использование этого макроса гарантирует, что при компиляции
старых моделей блоков эти новые поля структуры будут инициализированы так, что соответствующие
им проверки будут отключены.</p>

<h3 id="light_p5_3_2">5.3.2. <span class="cpp">rdsCWCreate</span> &ndash; функция создания объекта-наблюдателя</h3>

<p>Функция <span class="cpp">rdsCWCreate</span> создает вспомогательный объект RDS, который
наблюдает за переходным процессом и сообщает указанному блоку о его начале, окончании
или расхождении.</p>

<pre class="cpp">  RDS_HOBJECT RDSCALL rdsCWCreate(
    RDS_BHANDLE Block,      <span class="rem">// Блок</span>
    LPSTR VarName,          <span class="rem">// Имя входа или NULL</span>
    <span class="kw">int</span> VarNum,             <span class="rem">// Номер входа</span>
    <span class="kw">int</span> Id,                 <span class="rem">// Произвольное число для реакции блока</span>
    <a href="#light_p5_2" class="hidden">RDS_PCWCREATEDATA</a> Data, <span class="rem">// Параметры наблюдения</span>
    DWORD Flags             <span class="rem">// </span><a href="#light_p5_1" class="hidden"><span class="rem">Флаги (RDS_CWF_*)</span></a>
  );</pre>

<p class="apphdr">Тип указателя на эту функцию</p>
<p><span class="cpp">RDS_HoBhSIICwDw</span></p>

<p class="apphdr">Параметры</p>

<dl>
  <dt><span class="cpp">Block</span>&emsp;(<span class="cpp"><i>RDS_BHANDLE</i></span>)</dt>
  <dd>Идентификатор блока, на входах которого требуется наблюдение за переходным процессом,
  или <span class="cpp">NULL</span>, если объект создается для блока, вызвавшего функцию. Именно
  у этого блока будут вызываться реакции на события, связанные с переходными процессами
  (п.&nbsp;<a href="#light_p5_4">5.4</a> и <a href="#light_p5_5">5.5</a>).</dd>

  <dt><span class="cpp">VarName</span>&emsp;(<span class="cpp"><i>LPSTR</i></span>)</dt>
  <dd>Имя входа блока, на котором будет определяться переходный процесс, или <span class="cpp">NULL</span>,
  если имя не задается (имена и номера входов можно добавить позднее установкой параметров объекта
  <a href="#light_p5_3_5"><span class="cpp">RDS_CWPARAM_ADDVARNAME</span></a> и
  <a href="#light_p5_3_6"><span class="cpp">RDS_CWPARAM_ADDVARNUM</span></a>.
  Имя может содержать индексы массивов, поля структур и т. д.</dd>

  <dt><span class="cpp">VarNum</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Номер входа блока, на котором будет определяться переходный процесс, или &minus;1, если номер не
  задается (имена и номера входов можно добавить позднее). Если к входу с данным номером подключено
  несколько связей, например, к разным элементам массива, будет обнаруживаться переходный процесс
  в любой из них.</dd>

  <dt><span class="cpp">Id</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Произвольное целое число, передающееся в реакции блока
  <a href="#light_p5_4_1"><span class="cpp">RDS_BFM_CONNCHANGEON</span></a>,
  <a href="#light_p5_4_2"><span class="cpp">RDS_BFM_CONNCHANGEOFF</span></a> и
  <a href="#light_p5_4_3"><span class="cpp">RDS_BFM_CONNCHANGEERROR</span></a>.
  В наблюдении за процессом не участвует.</dd>

  <dt><span class="cpp">Data</span>&emsp;(<span class="cpp"><i>RDS_PCWCREATEDATA</i></span>)</dt>
  <dd>Указатель на структуру <a href="#light_p5_2"><span class="cpp">RDS_CWCREATEDATA</span></a>,
  которая должна быть заполнена параметрами наблюдения.</dd>

  <dt><span class="cpp">Flags</span>&emsp;(<span class="cpp"><i>DWORD</i></span>)</dt>
  <dd>Объединенные битовым ИЛИ флаги, управляющие наблюдением:
    <div class="tableleft"><div class="tcont">
      <table class="list">
        <tr>
          <td class="term"><span class="cpp">RDS_CWF_NOREACTION</span></td>
          <td>Не вызывать <a href="#light_p5_4">стандартные реакции</a> блока при
          начале/окончании/расхождении переходного процесса (используется для организации
          &laquo;подчиненных&raquo; наблюдателей в блоках-переключателях, см.
          п.&nbsp;<a href="#light_p6">6</a>).</td>
        </tr>
        <tr>
          <td class="term"><span class="cpp">RDS_CWF_EXACTNAMEMATCH</span></td>
          <td>При указании имени наблюдаемого входа вместо номера имя в присоединенной связи должно
          в точности совпадать с указанным, иначе проверяется только начало имени (например, при указании
          &laquo;x&raquo; будет найдена и &laquo;x[0]&raquo;).</td>
        </tr>
        <tr>
          <td class="term"><span class="cpp">RDS_CWF_PARENTONLY</span></td>
          <td>Ограничить отслеживание переходного процесса только родительской подсистемой блока и
          вложенными в нее.</td>
        </tr>
      </table>
    </div></div>
  </dd>

</dl>

<p class="apphdr">Возвращаемое значение</p>
<p>Уникальный идентификатор созданного объекта.</p>

<p class="apphdr">Примечания</p>
<p>Эта функция создает вспомогательный объект для наблюдения за переходным процессом в
заданном блоке. Созданный объект будет вызывать у блока реакции на начало, окончание и
расхождение (если разрешено в параметрах) переходного процесса. Для уничтожения объекта и
прекращения наблюдения используется стандартная функция <span class="cpp">rdsDeleteObject</span>
(см. приложение А.5.22.4).</p>

<h3 id="light_p5_3_3">5.3.3. <span class="cpp">rdsCWCreateCopy</span> &ndash; функция создания копии объекта-наблюдателя</h3>

<p>Функция <span class="cpp">rdsCWCreateCopy</span> создает вспомогательный объект RDS, который
наблюдает за переходным процессом, считывая параметры наблюдения из другого, ранее созданного,
объекта (чаще всего привязанного к какому-то другому блоку).
Обычно она применяется в блоках-переключателях для создания &laquo;подчиненных&raquo;
наблюдателей (см. п.&nbsp;<a href="#light_p6">6</a>).</p>

<pre class="cpp">  RDS_HOBJECT RDSCALL rdsCWCreateCopy(
    RDS_BHANDLE Block,      <span class="rem">// Блок</span>
    LPSTR VarName,          <span class="rem">// Имя входа или NULL</span>
    <span class="kw">int</span> VarNum,             <span class="rem">// Номер входа</span>
    <span class="kw">int</span> Id,                 <span class="rem">// Произвольное число для реакции блока</span>
    DWORD Flags,            <span class="rem">// </span><a href="#light_p5_1" class="hidden"><span class="rem">Флаги (RDS_CWF_*)</span></a>
    RDS_HOBJECT Copy        <span class="rem">// Объект для копирования</span>
  );</pre>

<p class="apphdr">Тип указателя на эту функцию</p>
<p><span class="cpp">RDS_HoBhSIIDwHo</span></p>

<p class="apphdr">Параметры</p>

<dl>
  <dt><span class="cpp">Block</span>&emsp;(<span class="cpp"><i>RDS_BHANDLE</i></span>)</dt>
  <dd>Идентификатор блока, на входах которого требуется наблюдение за переходным процессом,
  или <span class="cpp">NULL</span>, если объект создается для блока, вызвавшего функцию. Именно
  у этого блока будут вызываться реакции на события, связанные с переходными процессами
  (п.&nbsp;<a href="#light_p5_4">5.4</a> и <a href="#light_p5_5">5.5</a>).</dd>

  <dt><span class="cpp">VarName</span>&emsp;(<span class="cpp"><i>LPSTR</i></span>)</dt>
  <dd>Имя входа блока, на котором будет определяться переходный процесс, или <span class="cpp">NULL</span>,
  если имя не задается (имена и номера входов можно добавить позднее установкой параметров объекта
  <a href="#light_p5_3_5"><span class="cpp">RDS_CWPARAM_ADDVARNAME</span></a> и
  <a href="#light_p5_3_6"><span class="cpp">RDS_CWPARAM_ADDVARNUM</span></a>.
  Имя может содержать индексы массивов, поля структур и т. д.</dd>

  <dt><span class="cpp">VarNum</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Номер входа блока, на котором будет определяться переходный процесс, или &minus;1, если номер не
  задается (имена и номера входов можно добавить позднее). Если к входу с данным номером подключено
  несколько связей, например, к разным элементам массива, будет обнаруживаться переходный процесс
  в любой из них.</dd>

  <dt><span class="cpp">Id</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Произвольное целое число, передающееся в реакции блока
  <a href="#light_p5_4_1"><span class="cpp">RDS_BFM_CONNCHANGEON</span></a>,
  <a href="#light_p5_4_2"><span class="cpp">RDS_BFM_CONNCHANGEOFF</span></a> и
  <a href="#light_p5_4_3"><span class="cpp">RDS_BFM_CONNCHANGEERROR</span></a>.
  В наблюдении за процессом не участвует.</dd>

  <dt><span class="cpp">Flags</span>&emsp;(<span class="cpp"><i>DWORD</i></span>)</dt>
  <dd>Объединенные битовым ИЛИ флаги, управляющие наблюдением (совпадают с флагами функции
  <a href="#light_p5_3_2"><span class="cpp">rdsCWCreate</span></a>):
    <div class="tableleft"><div class="tcont">
      <table class="list">
        <tr>
          <td class="term"><span class="cpp">RDS_CWF_NOREACTION</span></td>
          <td>Не вызывать <a href="#light_p5_4">стандартные реакции</a> блока при
          начале/окончании/расхождении переходного процесса (используется для организации
          &laquo;подчиненных&raquo; наблюдателей в блоках-переключателях, см.
          п.&nbsp;<a href="#light_p6">6</a>).</td>
        </tr>
        <tr>
          <td class="term"><span class="cpp">RDS_CWF_EXACTNAMEMATCH</span></td>
          <td>При указании имени наблюдаемого входа вместо номера имя в присоединенной связи должно
          в точности совпадать с указанным, иначе проверяется только начало имени (например, при указании
          &laquo;x&raquo; будет найдена и &laquo;x[0]&raquo;).</td>
        </tr>
        <tr>
          <td class="term"><span class="cpp">RDS_CWF_PARENTONLY</span></td>
          <td>Ограничить отслеживание переходного процесса только родительской подсистемой блока и
          вложенными в нее.</td>
        </tr>
      </table>
    </div></div>
  </dd>

  <dt><span class="cpp">Сopy</span>&emsp;(<span class="cpp"><i>RDS_HOBJECT</i></span>)</dt>
  <dd>Идентификатор уже существующего объекта-наблюдателя, параметры которого копируются.</dd>

</dl>

<p class="apphdr">Возвращаемое значение</p>
<p>Уникальный идентификатор созданного объекта.</p>

<p class="apphdr">Примечания</p>
<p>Эта функция создает вспомогательный объект для наблюдения за переходным процессом в
заданном блоке по данным другого такого же объекта. Созданный объект будет вызывать у
блока реакции на начало, окончание и расхождение (если разрешено в параметрах) переходного процесса.
Для уничтожения объекта и прекращения наблюдения используется стандартная функция
<span class="cpp">rdsDeleteObject</span> (см. приложение А.5.22.4).</p>

<h3 id="light_p5_3_4">5.3.4. <span class="cpp">rdsCWGetParameters</span> &ndash; функция чтения параметров объекта-наблюдателя</h3>

<p>Функция <span class="cpp">rdsCWGetParameters</span> считывает параметры вспомогательного
объекта-наблюдателя в структуру <a href="#light_p5_2"><span class="cpp">RDS_CWCREATEDATA</span></a>.</p>

<pre class="cpp">  BOOL RDSCALL rdsCWGetParameters(
    RDS_HOBJECT Watcher,   <span class="rem">// Объект-наблюдатель</span>
    <a href="#light_p5_2" class="hidden">RDS_PCWCREATEDATA</a> Data <span class="rem">// Параметры наблюдения</span>
  );</pre>

<p class="apphdr">Тип указателя на эту функцию</p>
<p><span class="cpp">RDS_BHoCw</span></p>

<p class="apphdr">Параметры</p>

<dl>
  <dt><span class="cpp">Watcher</span>&emsp;(<span class="cpp"><i>RDS_HOBJECT</i></span>)</dt>
  <dd>Идентификатор объекта-наблюдателя, параметры которого считываются.</dd>

  <dt><span class="cpp">Data</span>&emsp;(<span class="cpp"><i>RDS_PCWCREATEDATA</i></span>)</dt>
  <dd>Указатель на структуру <a href="#light_p5_2"><span class="cpp">RDS_PCWCREATEDATA</span></a>,
  в которую записываются параметры наблюдения из объекта <span class="cpp">Watcher</span>. Поле
  <span class="cpp">servSize</span> у этой структуры должно быть заполнено до вызова.</dd>
</dl>

<p class="apphdr">Возвращаемое значение</p>
<p>Успешность операции.</p>

<h3 id="light_p5_3_5">5.3.5. Команда <span class="cpp">RDS_CWPARAM_ADDVARNAME</span> &ndash; добавление имени входа</h3>

<p>Команда <span class="cpp">RDS_CWPARAM_ADDVARNAME</span> добавляет новое имя входа
к набору входов блока, за переходными процессами в которых наблюдает объект.</p>

<pre class="cpp">  <span class="kw">char</span> *strVarName= &hellip; <span class="rem">// Имя входа блока</span>
  rdsSetObjectStr(Watcher,RDS_CWPARAM_ADDVARNAME,<span class="const">0</span>,strVarName);</pre>

<p class="apphdr">Параметры</p>

<dl>
  <dt><span class="cpp">Watcher</span>&emsp;(<span class="cpp"><i>RDS_HOBJECT</i></span>)</dt>
  <dd>Идентификатор объекта-наблюдателя.</dd>

  <dt><span class="cpp">strVarName</span>&emsp;(<span class="cpp"><i>char*</i></span>)</dt>
  <dd>Указатель на строку, в которой записано имя добавляемого входа блока.</dd>
</dl>

<h3 id="light_p5_3_6">5.3.6. Команда <span class="cpp">RDS_CWPARAM_ADDVARNUM</span> &ndash; добавление номера входа</h3>

<p>Команда <span class="cpp">RDS_CWPARAM_ADDVARNUM</span> добавляет новый номер входа
к набору входов блока, за переходными процессами в которых наблюдает объект.</p>

<pre class="cpp">  <span class="kw">int</span> iVarNum= &hellip; <span class="rem">// Номер входа блока</span>
  rdsSetObjectInt(Watcher,RDS_CWPARAM_ADDVARNUM,<span class="const">0</span>,iVarNum);</pre>

<p class="apphdr">Параметры</p>

<dl>
  <dt><span class="cpp">Watcher</span>&emsp;(<span class="cpp"><i>RDS_HOBJECT</i></span>)</dt>
  <dd>Идентификатор объекта-наблюдателя.</dd>

  <dt><span class="cpp">iVarNum</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Номер добавляемого входа блока.</dd>
</dl>


<h3 id="light_p5_3_7">5.3.7. <span class="cpp">rdsCWTranslateChanges</span> &ndash; функция передачи признака изменения из одного объекта в другой</h3>

<p>Функция <span class="cpp">rdsCWTranslateChanges</span> передает признаки изменения в подграфе
связей, за которым наблюдает один объект, в другой объект. Используется при создании
блоков-переключателей для передачи информации о переходном процессе из &laquo;подчиненного&raquo;
подграфа связей в основной (см. п.&nbsp;<a href="#light_p6">6</a>).</p>

<pre class="cpp">  BOOL RDSCALL rdsCWTranslateChanges(
    RDS_HOBJECT FromWatcher, <span class="rem">// Исходный объект</span>
    RDS_HOBJECT ToWatcher    <span class="rem">// Объект-получатель</span>
  );</pre>

<p class="apphdr">Тип указателя на эту функцию</p>
<p><span class="cpp">RDS_BHoHo</span></p>

<p class="apphdr">Параметры</p>

<dl>
  <dt><span class="cpp">FromWatcher</span>&emsp;(<span class="cpp"><i>RDS_HOBJECT</i></span>)</dt>
  <dd>Идентификатор объекта-наблюдателя, признаки изменения которого считываются для
  передачи в другой объект.</dd>

  <dt><span class="cpp">ToWatcher</span>&emsp;(<span class="cpp"><i>RDS_HOBJECT</i></span>)</dt>
  <dd>Идентификатор объекта-наблюдателя, получающего считанные признаки изменения.</dd>
</dl>

<p class="apphdr">Возвращаемое значение</p>
<p>Наличие изменений в подграфе, за которым следит объект <span class="cpp">FromWatcher</span>.</p>

<p class="apphdr">Примечания</p>

<p>Эта функция используется в сложных блоках-переключателях, которые &laquo;разрывают&raquo;
анализируемый подграф. Например, модель <a href="#light_p4_5">мультиплексора</a> должна
передавать наблюдателю за выходным подграфом признаки изменения только в той входной ветви,
которая сейчас подключена к выходу. Это делается при помощи <span class="cpp">rdsCWTranslateChanges</span>.</p>





<h2 id="light_p5_4">5.4. Основные реакции блоков</h2>

<h3 id="light_p5_4_1">5.4.1. <span class="cpp">RDS_BFM_CONNCHANGEON</span> &ndash; начало переходного процесса</h3>

<p class="apphdr">Поток, в котором вызывается функция модели</p>
<p>Поток расчета.</p>

<p class="apphdr">Первый параметр функции модели (<span class="cpp">int&nbsp;CallMode</span>)</p>
<p>Константа <span class="cpp">RDS_BFM_CONNCHANGEON</span>.</p>

<p class="apphdr">Третий параметр функции модели (<span class="cpp">void&nbsp;*ExtParam</span>)</p>
<p>Указатель на структуру <span class="cpp">RDS_CONNCHANGEDATA</span>, в которой содержится
идентификатор объекта-наблюдателя и описание события.</p>

<p class="apphdr">Возвращаемое функцией модели значение</p>
<p>Не используется, можно возвращать любое значение.</p>

<p class="apphdr">Примечания</p>

<p>Событие <span class="cpp">RDS_BFM_CONNCHANGEON</span> возникает в момент начала переходного
процесса в наблюдаемом подграфе связей у блока, если реакции при
<a href="#light_p5_3_2">создании</a> объекта-наблюдателя не были явно запрещены
(флаг <span class="cpp">RDS_CWF_NOREACTION</span>).</p>

<p id="RDS_CONNCHANGEDATA">При реакции на это событие в параметре <span class="cpp">ExtParam</span> передается указатель на
структуру <span class="cpp">RDS_CONNCHANGEDATA</span>:</p>

<pre class="cpp">  <span class="kw">typedef</span> <span class="kw">struct</span>
  { RDS_HOBJECT Object;   <span class="rem">// Объект-наблюдатель</span>
    <span class="kw">int</span> Id;               <span class="rem">// Идентификатор</span>
    BOOL Changes;         <span class="rem">// Начало или конец процесса</span>
    BOOL Error;           <span class="rem">// Процесс расходится</span>
    RDS_BHANDLE ObjBlock; <span class="rem">// Запросивший блок</span>
  } <span id="light_RDS_CONNCHANGEDATA">RDS_CONNCHANGEDATA</span>;
  <span class="kw">typedef</span> RDS_CONNCHANGEDATA *RDS_PCONNCHANGEDATA;</pre>

<p class="apphdr">Поля структуры</p>

<dl>
  <dt><span class="cpp">Object</span>&emsp;(<span class="cpp"><i>RDS_HOBJECT</i></span>)</dt>
  <dd>Идентификатор объекта-наблюдателя, вызвавшего реакцию блока, созданный функциями
  <a href="#light_p5_3_2"><span class="cpp">rdsCWCreate</span></a> или
  <a href="#light_p5_3_3"><span class="cpp">rdsCWCreateCopy</span></a>.</dd>

  <dt><span class="cpp">Id</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Идентификатор, переданный при создании объекта. Может использоваться в модели для
  более удобного определения, какой именно объект сигнализирует о переходном процессе, если
  блок создал несколько таких объектов.</dd>

  <dt><span class="cpp">Changes</span>&emsp;(<span class="cpp"><i>BOOL</i></span>)</dt>
  <dd>Признак начала (<span class="cpp">TRUE</span>) или окончания (<span class="cpp">FALSE</span>)
  переходного процесса. Структура <span class="cpp">RDS_CONNCHANGEDATA</span> используется
  в нескольких реакциях блока, это поле дублирует вызвавшее реакцию событие.</dd>

  <dt><span class="cpp">Error</span>&emsp;(<span class="cpp"><i>BOOL</i></span>)</dt>
  <dd>Признак расходящегося переходного процесса (содержит <span class="cpp">TRUE</span> только если
  структура передается как параметр в событии
  <a href="#light_p5_4_3"><span class="cpp">RDS_BFM_CONNCHANGEERROR</span></a>.</dd>

  <dt><span class="cpp">ObjBlock</span>&emsp;(<span class="cpp"><i>RDS_BHANDLE</i></span>)</dt>
  <dd>Идентификатор блока, за входным подграфом которого наблюдает объект.</dd>
</dl>

<p class="noindent">При реакции на событие <span class="cpp">RDS_BFM_CONNCHANGEON</span> поле
<span class="cpp">Changes</span> структуры параметров всегда содержит <span class="cpp">TRUE</span>,
поле <span class="cpp">Error</span> &ndash; <span class="cpp">FALSE</span>.</p>




<h3 id="light_p5_4_2">5.4.2. <span class="cpp">RDS_BFM_CONNCHANGEOFF</span> &ndash; окончание переходного процесса</h3>

<p class="apphdr">Поток, в котором вызывается функция модели</p>
<p>Поток расчета.</p>

<p class="apphdr">Первый параметр функции модели (<span class="cpp">int&nbsp;CallMode</span>)</p>
<p>Константа <span class="cpp">RDS_BFM_CONNCHANGEOFF</span>.</p>

<p class="apphdr">Третий параметр функции модели (<span class="cpp">void&nbsp;*ExtParam</span>)</p>
<p>Указатель на структуру <span class="cpp">RDS_CONNCHANGEDATA</span>, в которой содержится
идентификатор объекта-наблюдателя и описание события.</p>

<p class="apphdr">Возвращаемое функцией модели значение</p>
<p>Не используется, можно возвращать любое значение.</p>

<p class="apphdr">Примечания</p>

<p>Событие <span class="cpp">RDS_BFM_CONNCHANGEOFF</span> возникает в момент окончания переходного
процесса в наблюдаемом подграфе связей у блока, если реакции при <a href="#light_p5_3_2">создании</a>
объекта-наблюдателя не были явно запрещены (флаг <span class="cpp">RDS_CWF_NOREACTION</span>).
Если в параметрах объекта была разрешена проверка на расходящиеся процессы, и процесс
разошелся, это событие не будет вызвано, даже если позже переходный процесс окончится.</p>

<p>При реакции на это событие в параметре <span class="cpp">ExtParam</span> передается указатель на
структуру <a href="#RDS_CONNCHANGEDATA"><span class="cpp">RDS_CONNCHANGEDATA</span></a>.
Поля <span class="cpp">Changes</span> и <span class="cpp">Error</span> переданной структуры будут
содержать содержать значение <span class="cpp">FALSE</span>.</p>





<h3 id="light_p5_4_3">5.4.3. <span class="cpp">RDS_BFM_CONNCHANGEERROR</span> &ndash; переходный процесс расходится</h3>

<p class="apphdr">Поток, в котором вызывается функция модели</p>
<p>Поток расчета.</p>

<p class="apphdr">Первый параметр функции модели (<span class="cpp">int&nbsp;CallMode</span>)</p>
<p>Константа <span class="cpp">RDS_BFM_CONNCHANGEERROR</span>.</p>

<p class="apphdr">Третий параметр функции модели (<span class="cpp">void&nbsp;*ExtParam</span>)</p>
<p>Указатель на структуру <span class="cpp">RDS_CONNCHANGEDATA</span>, в которой содержится
идентификатор объекта-наблюдателя и описание события.</p>

<p class="apphdr">Возвращаемое функцией модели значение</p>
<p>Не используется, можно возвращать любое значение.</p>

<p class="apphdr">Примечания</p>

<p>Событие <span class="cpp">RDS_BFM_CONNCHANGEERROR</span> возникает при срабатывании проверки
расхождения переходного процесса в наблюдаемом подграфе связей у блока, если при
<a href="#light_p5_3_2">создании</a> объекта-наблюдателя эта проверка была включена,
а реакции не были явно запрещены (флаг <span class="cpp">RDS_CWF_NOREACTION</span>). После этого
событие окончания переходного процесса не возникает, даже если процесс позже сойдется.</p>

<p>При реакции на <span class="cpp">RDS_BFM_CONNCHANGEERROR</span> в параметре
<span class="cpp">ExtParam</span> передается указатель на структуру
<a href="#RDS_CONNCHANGEDATA"><span class="cpp">RDS_CONNCHANGEDATA</span></a>.
Поля <span class="cpp">Error</span> и <span class="cpp">Changes</span> этой структуры
будут содержать содержать значение <span class="cpp">TRUE</span>.</p>





<h2 id="light_p5_5">5.5. Дополнительные реакции блоков-переключателей</h2>

<p>У блоков-переключателей, установивших <a href="#light_p5_1">флаг</a>
<span class="cpp">RDS_CONNCHANGECTRL</span>, есть дополнительный набор событий, необходимых
для работы сложной логики влияния процессов на разных входах на процессы на разных выходах
(см. п.&nbsp;<a href="#light_p6">6</a>). Такие блоки при переходе в режим моделирования обычно
создают объекты-наблюдатели для разных по назначению входов, а затем, уже в режиме расчета,
передают информацию о наличии изменений в отдельных входных подграфах в другие объекты,
наблюдающие за их выходами.</p>

<p>В момент перехода в режим моделирования все блоки-переключатели (т. е. блоки с флагом
<span class="cpp">RDS_CONNCHANGECTRL</span>) вызываются для реакции на событие
<a href="#light_p5_5_1"><span class="cpp">RDS_BFM_CONNCHGCTRLSTART</span></a>.
В этой реакции они могут, если это необходимо, инициализировать какие-либо
внутренние структуры данных, которые понадобятся им для дальнейшей работы.</p>

<p>Затем RDS выполняет составление подграфов связей для уже созданных объектов наблюдателей.
В процессе этого анализа для каждой уже добавленной в подграф связи рассматриваются блоки,
к выходам которых эти связи подключены. Если у такого блока не взведен флаг
<span class="cpp">RDS_CONNCHANGECTRL</span>, т. е. блок не является переключателем,
в подграф, как обычно, добавляются все его входные связи, и процесс повторяется.
Если же флаг взведен, вместо автоматического добавления входных связей сам блок вызывается для
реакции на событие
<a href="#light_p5_5_2"><span class="cpp">RDS_BFM_CONNCHGCTRLASK</span></a>,
при этом ему сообщается, какой именно объект-наблюдатель запрашивает информацию о переходном
процессе для какого именно выхода. Реагируя на это событие, блок должен самостоятельно создать
новые объекты-наблюдатели для своих входов, влияющих на данный выход, и запомнить их &ndash;
они будут опрашиваться им в процессе расчета. Появление новых наблюдателей приводит к
новому анализу подграфов уже для них, и процедура продолжается до тех пор, пока все необходимые
дополнительные наблюдатели не будут созданы и их подграфы не будут проанализированы.</p>

<p>Когда анализ подграфов будет полностью завершен, все блоки-переключатели будут
вызваны для реакции на событие
<a href="#light_p5_5_3"><span class="cpp">RDS_BFM_CONNCHGCTRLEND</span></a>.
При этом блоки могут очистить вспомогательные структуры данных, если они были созданы
в реакции на <span class="cpp">RDS_BFM_CONNCHGCTRLSTART</span>.</p>

<p>Далее в режиме расчета у блоков-переключателей будет возникать событие
<a href="#light_p5_5_4"><span class="cpp">RDS_BFM_CONNCHGCTRLPROCESS</span></a>.
Реагируя на него, блок должен при помощи функции
<a href="#light_p5_3_7"><span class="cpp">rdsCWTranslateChanges</span></a>
передать наличие изменений из входных подграфов в выходные согласно своей логике работы.
Например, <a href="#light_p4_5">мультиплексор</a> передает на свой
выход изменения только в тех входных подграфах,
которые подключены к активному в данный момент входу данных или к входу выбора.</p>



<h3 id="light_p5_5_1">5.5.1. <span class="cpp">RDS_BFM_CONNCHGCTRLSTART</span> &ndash; предварительный вызов блоков-переключателей</h3>

<p class="apphdr">Поток, в котором вызывается функция модели</p>
<p>Главный поток RDS.</p>

<p class="apphdr">Первый параметр функции модели (<span class="cpp">int&nbsp;CallMode</span>)</p>
<p>Константа <span class="cpp">RDS_BFM_CONNCHGCTRLSTART</span>.</p>

<p class="apphdr">Третий параметр функции модели (<span class="cpp">void&nbsp;*ExtParam</span>)</p>
<p>Не используется (<span class="cpp">NULL</span>).</p>

<p class="apphdr">Возвращаемое функцией модели значение</p>
<p>Не используется, можно возвращать любое значение.</p>

<p class="apphdr">Примечания</p>

<p>Событие <span class="cpp">RDS_BFM_CONNCHGCTRLSTART</span> возникает у блоков, установивших
<a href="#light_p5_1">флаг</a> <span class="cpp">RDS_CONNCHANGECTRL</span>, при переходе
в режим моделирования. После него блок может быть вызван один или несколько раз для реакции на событие
<a href="#light_p5_5_2"><span class="cpp">RDS_BFM_CONNCHGCTRLASK</span></a>, чтобы он мог
создать вспомогательные объекты-наблюдатели для отдельных входов.</p>




<h3 id="light_p5_5_2">5.5.2. <span class="cpp">RDS_BFM_CONNCHGCTRLASK</span> &ndash; запрос изменений для выхода блока</h3>

<p class="apphdr">Поток, в котором вызывается функция модели</p>
<p>Главный поток RDS.</p>

<p class="apphdr">Первый параметр функции модели (<span class="cpp">int&nbsp;CallMode</span>)</p>
<p>Константа <span class="cpp">RDS_BFM_CONNCHGCTRLASK</span>.</p>

<p class="apphdr">Третий параметр функции модели (<span class="cpp">void&nbsp;*ExtParam</span>)</p>
<p>Указатель на структуру <span class="cpp">RDS_BFM_CONNCHGASKDATA</span>.</p>

<p class="apphdr">Возвращаемое функцией модели значение</p>
<p>Не используется, можно возвращать любое значение.</p>

<p class="apphdr">Примечания</p>

<p>Событие <span class="cpp">RDS_BFM_CONNCHGCTRLASK</span> возникает у блоков, установивших
<a href="#light_p5_1">флаг</a> <span class="cpp">RDS_CONNCHANGECTRL</span>,
если какому-то объекту-наблюдателю нужна информация о переходном процессе на выходе данного
блока. В реакции на него блок обычно создает свои объекты-наблюдатели для входов, чтобы
передавать их изменения на выходы в реакции на событие
<a href="#light_p5_5_4"><span class="cpp">RDS_BFM_CONNCHGCTRLPROCESS</span></a>.</p>

<p id="RDS_BFM_CONNCHGASKDATA">При реакции на событие <span class="cpp">RDS_BFM_CONNCHGCTRLASK</span>
в параметре <span class="cpp">ExtParam</span> передается указатель на структуру
<span class="cpp">RDS_BFM_CONNCHGASKDATA</span>:</p>

<pre class="cpp">  <span class="kw">typedef</span> <span class="kw">struct</span> {
    RDS_HOBJECT Object; <span class="rem">// Объект-наблюдатель за выходом блока</span>
    LPSTR VarName;      <span class="rem">// Имя переменной-выхода</span>
    RDS_CHANDLE Owner;  <span class="rem">// Связь-владелец точки выхода</span>
    <span class="kw">int</span> VarNum;         <span class="rem">// Номер переменной-выхода в блоке</span>
  } <span id="light_RDS_BFM_CONNCHGASKDATA">RDS_BFM_CONNCHGASKDATA</span>;
  <span class="kw">typedef</span> RDS_BFM_CONNCHGASKDATA *RDS_BFM_PCONNCHGASKDATA;</pre>

<p class="apphdr">Поля структуры</p>

<dl>
  <dt><span class="cpp">Object</span>&emsp;(<span class="cpp"><i>RDS_HOBJECT</i></span>)</dt>
  <dd>Идентификатор объекта-наблюдателя за данным выходом блока, которому
  требуется информация о переходных процессах на входах.</dd>

  <dt><span class="cpp">VarName</span>&emsp;(<span class="cpp"><i>LPSTR</i></span>)</dt>
  <dd>Указатель на строку с именем переменной-выхода, к которой подключена связь,
  входящая в подграф для объекта <span class="cpp">Object</span>.</dd>

  <dt><span class="cpp">Owner</span>&emsp;(<span class="cpp"><i>RDS_CHANDLE</i></span>)</dt>
  <dd>Идентификатор связи, подключенной к выходу.</dd>

  <dt><span class="cpp">VarNum</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Номер переменной-выхода.</dd>
</dl>

<p class="noindent">Для сложных переменных (например, структур и массивов) в поле
<span class="cpp">VarName</span> содержится полное имя со всеми индексами элементов или полями
структур. В поле <span class="cpp">VarNum</span> при этом будет содержаться только номер самого
выхода. Например, если выходной массив &laquo;Y&raquo; имеет в блоке номер 3, и связи подключены к
его элементам 0 и 1, при вызове реакции для нулевого элемента в <span class="cpp">VarName</span> будет
находиться &laquo;Y[0]&raquo;, а в <span class="cpp">VarNum</span> – &laquo;3&raquo;.
При вызове для первого элемента в <span class="cpp">VarName</span> будет находиться
&laquo;Y[1]&raquo;, а в <span class="cpp">VarNum</span> &ndash; снова &laquo;3&raquo;.</p>



<h3 id="light_p5_5_3">5.5.3. <span class="cpp">RDS_BFM_CONNCHGCTRLEND</span> &ndash; завершающий вызов блоков-переключателей</h3>

<p class="apphdr">Поток, в котором вызывается функция модели</p>
<p>Главный поток RDS.</p>

<p class="apphdr">Первый параметр функции модели (<span class="cpp">int&nbsp;CallMode</span>)</p>
<p>Константа <span class="cpp">RDS_BFM_CONNCHGCTRLEND</span>.</p>

<p class="apphdr">Третий параметр функции модели (<span class="cpp">void&nbsp;*ExtParam</span>)</p>
<p>Не используется (<span class="cpp">NULL</span>).</p>

<p class="apphdr">Возвращаемое функцией модели значение</p>
<p>Не используется, можно возвращать любое значение.</p>

<p class="apphdr">Примечания</p>

<p>Событие <span class="cpp">RDS_BFM_CONNCHGCTRLEND</span> возникает у блоков, установивших
<a href="#light_p5_1">флаг</a> <span class="cpp">RDS_CONNCHANGECTRL</span>, при
переходе в режим моделирования после того, как анализ всех подграфов связей для всех
объектов-наблюдателей закончен. Реагируя на него, блоки могут очистить вспомогательные
структуры данных, если они были созданы в реакции на
<a href="#light_p5_5_1"><span class="cpp">RDS_BFM_CONNCHGCTRLSTART</span></a>.</p>



<h3 id="light_p5_5_4">5.5.4. <span class="cpp">RDS_BFM_CONNCHGCTRLPROCESS</span> &ndash; передача изменений на выход</h3>

<p class="apphdr">Поток, в котором вызывается функция модели</p>
<p>Главный поток RDS.</p>

<p class="apphdr">Первый параметр функции модели (<span class="cpp">int&nbsp;CallMode</span>)</p>
<p>Константа <span class="cpp">RDS_BFM_CONNCHGCTRLPROCESS</span>.</p>

<p class="apphdr">Третий параметр функции модели (<span class="cpp">void&nbsp;*ExtParam</span>)</p>
<p>Не используется (<span class="cpp">NULL</span>).</p>

<p class="apphdr">Возвращаемое функцией модели значение</p>
<p>Не используется, можно возвращать любое значение.</p>

<p class="apphdr">Примечания</p>

<p>Событие <span class="cpp">RDS_BFM_CONNCHGCTRLPROCESS</span> возникает у блоков, установивших
<a href="#light_p5_1">флаг</a> <span class="cpp">RDS_CONNCHANGECTRL</span>, в каждом
такте расчета. Реагируя на это событие, блок должен передать наличие изменений из
своих входных подграфов в выходные при помощи функции
<a href="#light_p5_3_7"><span class="cpp">rdsCWTranslateChanges</span></a>.
Объекты-наблюдатели за входными подграфами должны быть созданы в реакции на событие
<a href="#light_p5_5_2"><span class="cpp">RDS_BFM_CONNCHGCTRLASK</span></a> для
каждого выходного подграфа, объект наблюдения за которым запросил данные. Основные принципы
реакции на это событие в разных типах блоков приведены ниже в
п.&nbsp;<a href="#light_p6">6</a>.</p>




<h1 id="light_p6">6. Общие правила построения некоторых типовых моделей блоков</h1>

<h2 id="light_p6_1">6.1. Блоки-выключатели связей</h2>

<p>Блоки-выключатели имеют один или несколько входов данных и соответствующие им выходы
данных. Кроме того, они имеют логический вход разрешения, при единице на котором данные
со входов передаются на выходы, а при нуле &ndash; не передаются (см. пример в
п.&nbsp;<a href="#light_p4_4">4.4</a>).</p>

<p>Чтобы такой выключатель мог &laquo;отсекать&raquo; переходные процессы на входах
в выключенном состоянии, его модель должна вести список объектов-наблюдателей за
выходами. Каждый элемент списка должен содержать идентификатор выходного наблюдателя,
сообщаемый блоку, а также идентификаторы наблюдателя за входом разрешения и наблюдателя за
входами данных, которые блок создает сам.</p>

<p>Модель блока должна быть построена следующим образом.</p>

<p>В реакции на
<a href="#light_p5_5_1"><span class="cpp">RDS_BFM_CONNCHGCTRLSTART</span></a>
список выходных наблюдателей очищается, все дополнительные наблюдатели за входами,
созданные самим блоком, уничтожаются при помощи вызовов <span class="cpp">rdsDeleteObject</span>
(см. приложение А.5.22.4).</p>

<p>В реакции на
<a href="#light_p5_5_2"><span class="cpp">RDS_BFM_CONNCHGCTRLASK</span></a>
блок выполняет следующие действия:</p>

<ul>
  <li>объект-наблюдатель выхода, вызвавший реакцию, добавляется в список выходных
  наблюдателей (назовем этот выходной объект-наблюдатель &laquo;Y<i>i</i>&raquo;, где
  <i>i</i> &ndash; номер добавленного элемента списка);</li>

  <li>в этом же <i>i</i>-м элементе списка при помощи вызова
  <a href="#light_p5_3_3"><span class="cpp">rdsCWCreateCopy</span></a>
  создается и запоминается объект-наблюдатель за входом разрешения (назовем его объектом
  &laquo;A<i>i</i>&raquo;), в него копируются параметры объекта, вызвавшего реакцию
  (т. е. выходного наблюдателя &laquo;Y<i>i</i>&raquo;);</li>

  <li>в этом же элементе списка таким же образом создается и запоминается объект-наблюдатель
  за входом данных (объект &laquo;X<i>i</i>&raquo;), причем если входов несколько, то
  дополнительные входы добавляются в объект при помощи команд
  <a href="#light_p5_3_5"><span class="cpp">RDS_CWPARAM_ADDVARNAME</span></a> и
  <a href="#light_p5_3_6"><span class="cpp">RDS_CWPARAM_ADDVARNUM</span></a>.</li>
</ul>

<p class="noindent">В реакции на
<a href="#light_p5_5_4"><span class="cpp">RDS_BFM_CONNCHGCTRLPROCESS</span></a>
для каждого элемента списка выходных наблюдателей (для всех <i>i</i>) выполняются
следующие действия:</p>

<ul>
  <li>изменения на входе разрешения (объект &laquo;A<i>i</i>&raquo;) при помощи
  <a href="#light_p5_3_7"><span class="cpp">rdsCWTranslateChanges</span></a>
  передаются выходному наблюдателю (объекту &laquo;Y<i>i</i>&raquo;);</li>

  <li>если на входе разрешения идет переходный процесс (<span class="cpp">rdsCWTranslateChanges</span>
  вернула <span class="cpp">TRUE</span>), другим вызовом <span class="cpp">rdsCWTranslateChanges</span>
  изменения с входов данных (объект &laquo;X<i>i</i>&raquo;) передаются выходному наблюдателю
  (объекту &laquo;Y<i>i</i>&raquo;);</li>

  <li>если на входе разрешения нет переходного процесса, и при этом значение этого входа
  не равно нулю (работа разрешена), изменения с входов данных (объект &laquo;X<i>i</i>&raquo;)
  передаются выходному наблюдателю (объекту &laquo;Y<i>i</i>&raquo;).</li>
</ul>

<p class="noindent">Таким образом, переходный процесс на входе разрешения будет
наблюдаться на выходах всегда. Переходный процесс на входах данных будет наблюдаться на
выходах либо если на входе разрешения тоже есть переходный процесс (еще не известно,
будет ли работа блока разрешена), либо если на входе разрешения не ноль (данные с
входов будут передаваться на выходы).</p>

<p>Список выходных наблюдателей нужен потому, что за выходами блока могут наблюдать
несколько объектов с разными параметрами (погрешностями, разрешением определения
расходящихся процессов), и информацию о процессе на входах нужно передавать
для них независимо.</p>



<h2 id="light_p6_2">6.2. Мультиплексоры (много входов, один выход)</h2>

<p>Мультиплексор имеет несколько одинаковых входов данных или входной массив,
к отдельным элементам которого подключаются связи, и один выход данных.
Кроме того, у него есть целочисленный вход управления, на который подается номер того входа
данных (элемента массива), значение которого передается на выход (см. пример в
п.&nbsp;<a href="#light_p4_5">4.5</a>).</p>

<p>Чтобы мультиплексор блокировал переходные процессы на неактивных входах, его
модель должна вести список объектов-наблюдателей за выходами. Каждый элемент списка
должен содержать:</p>

<ul>
  <li>идентификатор выходного наблюдателя;</li>
  <li>идентификатор наблюдателя за входом управления для данного выходного;</li>
  <li>массив идентификаторов наблюдателей за отдельными входами данных (элементами массива)
  для данного выходного &ndash; по одному наблюдателю на вход.</li>
</ul>

<p class="noindent">Модель блока должна быть построена следующим образом.</p>

<p>В реакции на
<a href="#light_p5_5_1"><span class="cpp">RDS_BFM_CONNCHGCTRLSTART</span></a>
список выходных наблюдателей очищается, все наблюдатели за входами,
созданные самим блоком, уничтожаются при помощи вызовов
<span class="cpp">rdsDeleteObject</span> (см. приложение А.5.22.4).</p>

<p>В реакции на
<a href="#light_p5_5_2"><span class="cpp">RDS_BFM_CONNCHGCTRLASK</span></a>
блок выполняет следующие действия:</p>

<ul>
  <li>объект-наблюдатель выхода, вызвавший реакцию, добавляется в список выходных наблюдателей
  (назовем этот выходной объект-наблюдатель &laquo;Y<i>i</i>&raquo;, где <i>i</i> &ndash;
  номер добавленного элемента списка);</li>

  <li>в этом же элементе списка при помощи вызова
  <a href="#light_p5_3_3"><span class="cpp">rdsCWCreateCopy</span></a>
  создается и запоминается объект-наблюдатель за входом управления (назовем его объектом
  &laquo;A<i>i</i>&raquo;), в него копируются параметры объекта, вызвавшего реакцию
  (выходного наблюдателя &laquo;Y<i>i</i>&raquo;);</li>

  <li>в этом же элементе списка создается массив идентификаторов входных наблюдателей (по
  одному объекту на каждый вход данных мультиплексора, назовем их объектами
  &laquo;X<i>i</i>[<i>j</i>]&raquo;, где <i>j</i> &ndash; номер входа), в них
  копируются параметры выходного наблюдателя.</li>
</ul>

<p class="noindent">В реакции на
<a href="#light_p5_5_4"><span class="cpp">RDS_BFM_CONNCHGCTRLPROCESS</span></a>
<span class="emph">для каждого элемента</span> списка выходных наблюдателей (для всех <i>i</i>) выполняются следующие действия:</p>

<ul>
  <li>изменения на входе управления (объект &laquo;A<i>i</i>&raquo;) при помощи
  <a href="#light_p5_3_7"><span class="cpp">rdsCWTranslateChanges</span></a>
  передаются выходному наблюдателю (объекту &laquo;Y<i>i</i>&raquo;) ;</li>

  <li>если на входе управления идет переходный процесс (<span class="cpp">rdsCWTranslateChanges</span>
  вернула <span class="cpp">TRUE</span>), данные о переходном процессе
  <span class="emph">в каждом</span> объекте-наблюдателе
  входа данных из созданного массива (т. е. по очереди все объекты &laquo;X<i>i</i>[<i>j</i>]&raquo;
  для всех <i>j</i>) передаются выходному наблюдателю (объекту &laquo;Y<i>i</i>&raquo;);</li>

  <li>если на входе управления нет переходного процесса, в выходной наблюдатель (объект &laquo;Y<i>i</i>&raquo;)
  передается информация о переходном процессе только из объекта, индекс которого в массиве
  входных наблюдателей равен текущему значению входа управления (т. е. только из одного объекта
  &laquo;X<i>i</i>[<i>N</i>]&raquo;, где <i>N</i> равно числу на входе управления).</li>
</ul>

<p class="noindent">Таким образом, переходный процесс на входе управления будет наблюдаться на
выходе всегда. Переходный процесс на входе данных с номером <i>N</i> будет наблюдаться на выходе
либо если на входе управления есть переходный процесс, либо если этот вход сейчас активен (на
входе управления &ndash; значение <i>N</i>).</p>

<p>Здесь, как и в выключателе, список выходных наблюдателей нужен потому,
что за выходами блока могут наблюдать несколько объектов с разными параметрами.</p>



<h2 id="light_p6_3">6.3. Демультиплексоры (один вход, много выходов)</h2>

<p>Демультиплексор имеет один вход данных, с которого он передает данные на единственный выход
(элемент выходного массива), номер которого подается на вход управления (см. пример в
п.&nbsp;<a href="#light_p4_6">4.6</a>).</p>

<p>Чтобы переходный процесс на входе демультиплексора наблюдался только на активном
в данный момент выходе, его модель должна вести независимые списки объектов-наблюдателей для
каждого отдельного выхода. Проще всего организовать их в виде массива списков,
где номер элемента массива будет определять номер выхода, для которого данный список
(элемент массива) построен. Каждый элемент любого из этих списков должен содержать:</p>

<ul>
  <li>идентификатор выходного наблюдателя;</li>
  <li>идентификатор наблюдателя за входом управления для данного выходного;</li>
  <li>идентификатор наблюдателя за входом данных для данного выходного.</li>
</ul>

<p class="noindent">Модель блока должна быть построена следующим образом.</p>

<p>В реакции на
<a href="#light_p5_5_1"><span class="cpp">RDS_BFM_CONNCHGCTRLSTART</span></a>
массив списков наблюдателей полностью очищается, все наблюдатели за входами,
созданные самим блоком, уничтожаются при помощи вызовов
<span class="cpp">rdsDeleteObject</span> (см. приложение А.5.22.4).</p>

<p>В реакции на
<a href="#light_p5_5_2"><span class="cpp">RDS_BFM_CONNCHGCTRLASK</span></a>
блок выполняет следующие действия:</p>

<ul>
  <li>по полям <span class="cpp">VarName</span> и <span class="cpp">VarNum</span> структуры
  <a href="#RDS_BFM_CONNCHGASKDATA"><span class="cpp">RDS_BFM_CONNCHGASKDATA</span></a>
  определяется номер выхода <i>n</i>, для которого запрашивается наблюдение за переходным
  процессом, и для дальнейшей работы из массива списков наблюдателей берется список-элемент
  с этим номером (если такого элемента нет, он создается);</li>

  <li>объект-наблюдатель, вызвавший реакцию, добавляется в рабочий, т. е. определенный на прошлом шаге,
  список (назовем этот объект &laquo;Y<i>n</i>[<i>i</i>]&raquo;, где <i>n</i> &ndash; номер выхода,
  <i>i</i> &ndash; номер добавленного элемента списка для этого выхода);</li>

  <li>в этом же (<i>i</i>-м) элементе рабочего (<i>n</i>-го) списка при помощи вызова
  <a href="#light_p5_3_3"><span class="cpp">rdsCWCreateCopy</span></a>
  создается и запоминается объект-наблюдатель за входом управления (назовем его
  &laquo;A<i>n</i>[<i>i</i>]&raquo;), в него копируются параметры объекта, вызвавшего
  реакцию (выходного наблюдателя &laquo;Y<i>n</i>[<i>i</i>]&raquo;);</li>

  <li>в этом же элементе рабочего списка таким же образом создается объект-наблюдатель за входом
  данных (объект &laquo;X<i>n</i>[<i>i</i>]&raquo;).</li>
</ul>

<p class="noindent">В реакции на
<a href="#light_p5_5_4"><span class="cpp">RDS_BFM_CONNCHGCTRLPROCESS</span></a>
<span class="emph">для каждого элемента списка наблюдателей в каждом элементе созданного массива</span>
(т. е., фактически, для каждого выходного наблюдателя, перебор по всем <i>n</i> и <i>i</i>)
выполняются следующие действия:</p>

<ul>
  <li>изменения на входе управления (объект &laquo;A<i>n</i>[<i>i</i>]&raquo;, где
  <i>n</i> &ndash; индекс в массиве списков для отдельных выходов, <i>i</i> &ndash;
  индекс в массиве наблюдателей <i>n</i>-го списка) при помощи
  <a href="#light_p5_3_7"><span class="cpp">rdsCWTranslateChanges</span></a>
  передаются выходному наблюдателю (объекту &laquo;Y<i>n</i>[<i>i</i>]&raquo;);</li>

  <li>если на входе управления идет переходный процесс (<span class="cpp">rdsCWTranslateChanges</span>
  вернула <span class="cpp">TRUE</span>), данные о переходном процессе на входе данных
  (объект &laquo;X<i>n</i>[<i>i</i>]&raquo;) передаются выходному наблюдателю (объекту
  &laquo;Y<i>n</i>[<i>i</i>]&raquo;);</li>

  <li>если на входе управления нет переходного процесса, данные о переходном процессе на
  входе данных (объект &laquo;X<i>n</i>[<i>i</i>]&raquo;) передаются выходному наблюдателю (объекту
  &laquo;Y<i>n</i>[<i>i</i>]&raquo;) <span class="emph">только в том случае</span>,
  если номер списка в массиве (<i>n</i>)
  равен текущему значению входа управления.</li>
</ul>

<p class="noindent">Таким образом, на выходе данных с номером <i>N</i> переходный процесс будет
наблюдаться либо если есть переходный процесс на входе управления, либо если на вход управления
подано значение <i>N</i>, и при этом есть переходный процесс на входе данных.</p>

<p>Для каждого выхода ведется список наблюдателей из-за того, что за этим выходом может наблюдать
одновременно несколько объектов с разными параметрами.</p>



<h2 id="light_p6_4">6.4. Блок, вычисляющий динамические переменные по значениям входов</h2>

<p>Блок, который вычисляет значения динамических переменных по данным, поступающим на его
входы, должен предпринять специальные меры, чтобы переходные процессы в подграфах его входов
обнаруживались на выходах других блоков, подписанных на эти же динамические переменные.
Для этого достаточно в любой реакции блока
<span class="emph">до перехода в режим моделирования</span> установить в поле
<span class="cpp">Flags</span> структуры данных блока <span class="cpp">RDS_BLOCKDATA</span>
(см. приложение А.2.3) битовый
<a href="#light_p5_1">флаг</a> <span class="cpp">RDS_DYNVARBYINPUT</span>.
Проще всего сделать это в реакции блока на событие инициализации
<span class="cpp">RDS_BFM_INIT</span> (см. приложение А.2.4.7).</p>

<p>В функцию модели блока указатель на структуру данных блока передается во
втором параметре. Таким образом, установка этого флага будет выглядеть примерно так:</p>

<pre class="cpp">  <span class="kw">extern</span> <span class="str">"C"</span> <span class="kw">__declspec</span>(<span class="kw">dllexport</span>)
    <span class="kw">int</span> RDSCALL имя_модели(
      <span class="kw">int</span> CallMode,
      RDS_PBLOCKDATA BlockData,
      LPVOID ExtParam)
  {
    <span class="kw">switch</span>(CallMode)
      { <span class="kw">case</span> RDS_BFM_INIT:
          BlockData->Flags|=RDS_DYNVARBYINPUT;
    &hellip;</pre>

<p>В автокомпилируемых блоках структура данных доступна через переменную
<span class="cpp">rdsbcppBlockData</span>, т. е. установка флага будет выглядеть так:</p>

<pre class="cpp">  rdsbcppBlockData->Flags|=RDS_DYNVARBYINPUT;</pre>

<p>На данный момент блок не может указывать, переходные процессы на каких
входах на какие динамические переменные влияют.
Считается, что любое изменение на любом входе влияет на все переменные сразу.</p>




<h2 id="light_p6_5">6.5. Блок, перезапускающийся при длительном расчете</h2>

<p>Если блок разбивает какой-либо длительный внутренний расчет на несколько тактов,
возвращая в промежутках управление в RDS для того, чтобы интерфейс пользователя не
&laquo;зависал&raquo;, этот блок должен сообщить о таком перезапуске и
продолжающемся расчете, чтобы отсутствие изменений на его выходах не было принято за
окончание переходного процесса. Для этого блок должен сделать две вещи:</p>

<ul>
  <li>заранее, <span class="emph">до перехода в режим моделирования</span>
  (например, при инициализации блока), установить в поле <span class="cpp">Flags</span> структуры данных
  блока <span class="cpp">RDS_BLOCKDATA</span> (см. приложение А.2.3) битовый
  <a href="#light_p5_1">флаг</a> <span class="cpp">RDS_MULTICALC</span>;</li>

  <li>при каждом перезапуске в реакции на такт расчета (<span class="cpp">RDS_BFM_MODEL</span>,
  см. приложение А.2.4.9) устанавливать в этом же поле битовый флаг <span class="cpp">RDS_MULTICALCON</span>.</li>
</ul>

<p class="noindent">Установка флага <span class="cpp">RDS_MULTICALC</span> нужна для сообщения
RDS о том, что данный блок способен перезапускаться. Блоки без этого флага не будут
проверяться на перезапуск для ускорения расчета.</p>

<p>Установка флага <span class="cpp">RDS_MULTICALCON</span> сообщает о том, что блок перезапустился
в данном такте и продолжает что-то вычислять, а, значит, переходные процессы в подграфах
связей, присоединенных к его выходам, нельзя считать завершившимися. Флаг автоматически
очищается перед каждым запуском модели, поэтому блоку не нужно его сбрасывать.</p>

<p>В функцию модели блока указатель на структуру данных блока передается во втором параметре.
Для флага <span class="cpp">RDS_MULTICALC</span> установка будет выглядеть примерно так:</p>

<pre class="cpp">  <span class="kw">extern</span> <span class="str">"C"</span> <span class="kw">__declspec</span>(<span class="kw">dllexport</span>)
    <span class="kw">int</span> RDSCALL имя_модели(
      <span class="kw">int</span> CallMode,
      RDS_PBLOCKDATA BlockData,
      LPVOID ExtParam)
  {
    &hellip;
          BlockData->Flags|=RDS_MULTICALC;
    &hellip;</pre>

<p>В автокомпилируемых блоках структура данных доступна через переменную
<span class="cpp">rdsbcppBlockData</span>, т. е. установка флага будет выглядеть так:</p>

<pre class="cpp">  rdsbcppBlockData->Flags|=RDS_MULTICALC;</pre>


<hr />
</div>

<p class="bottom"><a href="index.html#light_connwatch">Назад</a></p>

</body>
</html>
