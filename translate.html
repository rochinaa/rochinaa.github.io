<!DOCTYPE html>
<html lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="css/main.css" />
  <link rel="stylesheet" type="text/css" href="css/cpp.css" />
  <script type="text/javascript" src="script.js"></script>
  <link rel="icon" type="image/png" href="/favicon.png" />
  <title>Перевод текстов в схеме</title>
</head>
<body onload="DocLoad()">
<p class="top"><a href="index.html#light_translate">Назад</a></p>

<div class="text">

<h1>Перевод текстов в схеме</h1>

<p>Начиная с версии 1.0.489, в RDS добавлены функции для выгрузки всех текстов в схеме в
отдельный файл формата
<a href="http://www.rfc-editor.org/rfc/rfc4180.txt" title="Спецификация формата (английский)">
CSV</a>. В этот файл можно добавить переводы текстов на другой язык, а затем загрузить его
обратно, выбрав язык в момент загрузки. Таким образом можно быстро менять язык всех надписей в схеме.
Интерфейс пользователя RDS (окна настроек и параметров, пункты главного меню и т.п.) этим
способом <span class="emph">не переводится</span>, он остается русским.</p>

<div class="toc">
<div class="level">
  <p>Содержание:</p>
  <div class="level">
  <p><a href="#light_p1">1. Для пользователя</a></p>
    <div class="level">
    <p><a href="#light_p1_1">1.1. Интерфейс пользователя и порядок работы</a></p>
    <p><a href="#light_p1_2">1.2. Формат файла перевода</a></p>
      <div class="level">
      <p><a href="#light_p1_2_1">1.2.1. Общее описание формата</a></p>
      <p><a href="#light_p1_2_2">1.2.2. Пример файла перевода для простой схемы</a></p>
      </div>
    <p><a href="#light_p1_3">1.3. Переводимые и не переводимые тексты</a></p>
    <p><a href="#light_p1_4">1.4. Проблемы с &laquo;бесхозными&raquo; текстами</a></p>
    <p><a href="#light_p1_5">1.5. Обратная совместимость</a></p>
    </div>
  </div>

  <div class="level">
  <p><a href="#light_p2">2. Для программиста</a></p>
    <div class="level">
    <p><a href="#light_p2_1">2.1. Событие <span class="cpp">RDS_BFM_TRANSLATE</span></a></p>
    <p><a href="#light_p2_2">2.2. Функции поддержки перевода</a></p>
      <div class="level">
      <p><a href="#light_p2_2_1">2.2.1. Функция <span class="cpp">rdsTranslateParameter</span></a></p>
      <p><a href="#light_p2_2_2">2.2.2. Функция <span class="cpp">rdsTranslateText</span></a></p>
      </div>
    <p><a href="#light_p2_3">2.3. Пример реакции на событие перевода</a></p>
    <p><a href="#light_p2_4">2.4. Программный запрет перевода текста на блоке</a></p>
    <p><a href="#light_p2_5">2.5. Программный запрет перевода пояснительного текста связи</a></p>
    <p><a href="#light_p2_6">2.6. Программный запрет перевода значения строкового параметра связи</a></p>
    </div>
  </div>

</div>
</div>

<h1 id="light_p1">1. Для пользователя</h1>

<h2 id="light_p1_1">1.1. Интерфейс пользователя и порядок работы</h2>

<p>В меню &laquo;Система&raquo; добавилось подменю &laquo;перевод&raquo;, в котором собраны все пункты,
относящиеся к переводу.</p>

<div class="pic"><div class="container">
<img src="img/Transl_Pic1.png" width="604" height="403" alt="Главное меню" />
</div></div>

<p>Пункт &laquo;языки схемы&raquo; позволяет задать список языков, которые схема будет поддерживать (без
этого перевод невозможен), а также текущий язык, на котором все тексты схемы считаются написанными в данный момент.
В файле перевода каждый текст из схемы (названия блоков, заголовки графиков и т.п.) будет записан в вариантах для
каждого языка из этого списка. Фактически, &laquo;язык&raquo; &ndash; это просто имя набора всех текстов схемы,
и в файле перевода таких наборов может быть произвольное количество.</p>

<p>Допустим, схема уже существует, все тексты в ней написаны по-русски, и ее нужно подготовить к переводу на
английский. Первое, что должен будет сделать пользователь, это выбрать пункт меню
&laquo;перевод | языки схемы&raquo;, в открывшемся окне добавить два языка с названиями, например
&laquo;русский&raquo; и &laquo;english&raquo;, и установить в качестве текущего языка
&laquo;русский&raquo;. Названия языков могут быть любыми, они используются только в столбцах файла перевода
(см. <a href="#light_p1_2">1.2</a>) и в интерфейсе пользователя при выборе языка, который загружается из файла
при переводе. Список языков записывается в файл схемы (&laquo;.rds&raquo;) при ее сохранении, поэтому в
старую версию RDS может не получиться загрузить схему, сохраненную новой версией, если в этой схеме будет
список языков &ndash; старая версия просто не поймет, что это такое, и выдаст ошибку загрузки
(см. <a href="#light_p1_5">1.5</a>).</p>

<div class="pic"><div class="container">
<img src="img/Transl_Pic2.png" width="391" height="324" alt="Задание языков схемы" />
</div></div>

<p>После того, как список языков создан и схема сохранена, пользователь должен выбрать пункт меню
&laquo;перевод | сохранить файл перевода&raquo;. При этом откроется окно сохранения.</p>

<div class="pic"><div class="container">
<img src="img/Transl_Pic3.png" width="638" height="317" alt="Сохранение файла перевода" />
</div></div>

<p>Это окно позволяет как записать новый файл перевода (вариант &laquo;создать&hellip;&raquo;), так и дописать
в уже существующий файл все изменения в схеме, которые были сделаны с момента его записи (вариант
&laquo;синхронизировать&hellip;&raquo;). По умолчанию в качестве имени файла перевода предлагается имя
файла схемы с расширением &laquo;csv&raquo;, причем если такой файл уже существует, по умолчанию будет предложен
вариант &laquo;синхронизировать&raquo;. Лучше всего держать файл перевода в одной папке со схемой и
синхронизировать его по мере редактирования этой схемы, тогда можно не менять значения по умолчанию в этом окне.
При этом всю папку схемы можно будет переносить с места на место без необходимости запоминать или корректировать
пути к файлам, как и в случае размещения автокомпилируемых моделей в одной папке с файлом схемы.</p>

<p>В этом же окне задается формат файла. Во-первых, можно задать символ разделителя, который будет
использоваться в файле. Файл перевода имеет формат CSV, поэтому по умолчанию, согласно
<a href="http://www.rfc-editor.org/rfc/rfc4180.txt" title="Спецификация формата (английский)">спецификации формата</a>,
для разделения значений в нем используется запятая. Однако, некоторые программы (в частности, MS Excel),
которые могут читать и писать файлы CSV, используют в качестве разделителя точку с запятой или другие символы.
Чтобы не было конфликтов с такими программами, можно явно указать любой символ разделителя, и этот введенный
пользователем символ будет сохраняться вместе со всеми данными схемы (повторно вводить его будет не нужно).
В качестве символа-ограничителя строк всегда используется двойная кавычка.</p>

<p>Во-вторых, можно приказать сохранять служебную информацию, необходимую для загрузки переводов, не в
основной файл, а в связанный с ним, с тем же именем, но другим расширением (по умолчанию &ndash;
&laquo;csvd&raquo;). Дело в том, что в больших схемах эта служебная информация может оказаться довольно объемной,
и будет путать переводчика, которому отдадут файл перевода для заполнения. Если служебная информация
сохраняется в отдельный файл, то в файле, который увидит переводчик, будут указаны только числа-метки,
связывающие его с файлом служебной информации (формат файла перевода описан в <a href="#light_p1_2">1.2</a>).</p>

<p>Если при открытии окна выбран вариант &laquo;синхронизировать&raquo;, т.е. файл перевода уже существует,
символ разделителя и расширение служебного файла, если он используется, будут установлены так же, как в
существующем файле перевода. Перед сохранением файла их можно будет, при желании, изменить.</p>

<p>Кнопка &laquo;сохранить&raquo; записывает файл перевода. В нем в столбце текущего языка схемы будут
находиться тексты, существующие в схеме в данный момент. При этом, если был выбран вариант
&laquo;синхронизировать&raquo;, уже сделанные переводы в основном не теряются
(см. <a href="#light_p1_4">1.4</a> про &laquo;бесхозные&raquo; тексты), они останутся в столбцах соответствующих
языков. Для новых текстов, появившихся после последней синхронизации, ячейки в столбцах всех языков,
кроме текущего, будут пустыми &ndash; их должен будет заполнить переводчик.</p>

<p>После того, как переводчик введет в файл перевода все недостающие тексты на другом языке, отредактированный
им файл можно будет загрузить в схему при помощи пункта меню
&laquo;перевод | загрузить перевод&raquo;. При этом сначала откроется стандартный диалог выбора файла,
а после указания в нем конкретного файла перевода откроется окно выбора загружаемого языка.</p>

<div class="pic"><div class="container">
<img src="img/Transl_Pic4.png" width="448" height="347" alt="Выбор языка для загрузки" />
</div></div>

<p>В этом окне будут перечислены все языки, имеющиеся в выбранном файле перевода. Из них можно выбрать
любой, кроме языка, название которого совпадает с текущим языком схемы (нельзя перевести схему на тот
же язык, на котором она уже считается сделанной). Флажок &laquo;показать ошибки&raquo; позволяет просмотреть и
сохранить в отдельный файл предупреждения об отсутствующих переводах, если они будут обнаружены. Отключение флажка
&laquo;считать пустой перевод ошибкой&raquo; уберет из списка ошибок сообщения о не заполненных переводчиком
текстах на загружаемом языке (переводчик при этом может не заполнять тексты, которые он не считает нужным переводить).</p>

<p>После нажатия кнопки &laquo;загрузить&raquo; в схему будут загружены переводы для выбранного языка. Строки,
для которых нет перевода, останутся неизменными.</p>

<h2 id="light_p1_2">1.2. Формат файла перевода</h2>

<h3 id="light_p1_2_1">1.2.1. Общее описание формата</h3>

<p>Файл перевода представляет собой текстовый файл в формате CSV с заданным пользователем разделителем полей и
<span class="emph">в кодировке CP1251</span>. С файлом может быть связан дополнительный файл,
хранящий только служебную информацию. Переводчику этот служебный файл, если он используется,
передавать не нужно.</p>

<p>Данные в файле перевода записываются следующим образом:</p>

<div class="tablecenter"><div class="tcont">
<table>

<tr>
  <td class="center">RDSTRANSLATESERV</td>
  <td class="center"><i>Служебная_A</i></td>
  <td class="center"><i>Язык 1</i></td>
  <td class="center"><i>Язык 2</i></td>
  <td class="center">&hellip;</td>
</tr>

<tr>
  <td class="center"><i>Признак_строк</i></td>
  <td class="center"><i>Служебная_B</i></td>
  <td class="center">Текст на языке 1</td>
  <td class="center">Текст на языке 2</td>
  <td class="center">&hellip;</td>
</tr>

<tr>
  <td class="center"><i>Признак_строк</i></td>
  <td class="center"><i>Служебная_B</i></td>
  <td class="center">Текст на языке 1</td>
  <td class="center">Текст на языке 2</td>
  <td class="center">&hellip;</td>
</tr>

<tr>
  <td colspan="5" class="center">&hellip;</td>
</tr>

</table>
</div></div>

<p>Первая строка файла &ndash; заголовок. В первом столбце первой строки всегда находится текст
&laquo;RDSTRANSLATESERV&raquo;, по нему RDS при загрузке файла опознает его формат. Он же
служит для выяснения, какой символ разделителя использовала программа, сохранившая файл:
символом разделителя обязательно будет первый символ, следующий за этим текстом или за его закрывающей кавычкой,
если кавычки в файле используются.</p>

<p>Во втором столбце первой строки записана служебная информация, относящаяся ко всему файлу. Там
во внутреннем формате указывается расширение связанного служебного файла, если он используется, а также
записывается специальная строка для проверки правильности кодировки файла.</p>

<p>Начиная с третьего столбца первой строки перечисляются названия всех языков в файле.</p>

<p>Вторая и последующие строки файла описывают тексты на разных языках: каждая строка соответствует одному тексту
из схемы на всех языках, перечисленных в заголовке (полностью одинаковые тексты в разных объектах объединяются,
и им будет соответствовать одна и та же строка файла). Два первых столбца в этих строках &ndash; служебные.
В первом столбце содержится &laquo;0&raquo;, если в тексте не может быть разрывов строк (например, у заголовка
поля ввода их быть не может), и &laquo;1&raquo;, если такие разрывы могут быть (например, в тексте
на прямоугольнике блока). Эта информация может быть полезна переводчику. Если он ее проигнорирует, ничего
страшного не случится: если при чтении файла разрывы строк будут обнаружены там, где они запрещены, они
будут удалены автоматически.</p>

<p>Во втором столбце содержится служебная информация о том, к какому именно параметру схемы относится
данный текст. Эта информация не нужна переводчику, и он не должен ее изменять. Если файл перевода &ndash; один,
без дополнительного служебного файла, в этом столбце записываются длинные кодированные строки описания
параметров. Если с файлом перевода связан служебный файл, в этом столбце записываются только целые
числа-идентификаторы, а описания параметров выносятся в служебный файл и привязываются
к этим идентификаторам (примеры файлов приведены в <a href="#light_p1_2_2">1.2.2</a>).</p>

<p>При сохранении файла перевода <span class="emph">все</span> тексты берутся в двойные кавычки. По
спецификации формата это не обязательно, но так надежнее. При загрузке файла RDS следует спецификациям
RFC 4180: в кавычках должны быть тексты, содержащие двойные кавычки, символы разделителя и разрывы строк.
В качестве разрыва строки используется комбинация CRLF (<span class="cpp">0x0D</span>, <span class="cpp">0x0A</span>).</p>

<p>Формат связанного служебного файла здесь не описывается, ни переводчик, ни пользователь с ним не работают.</p>

<h3 id="light_p1_2_2">1.2.2. Пример файла перевода для простой схемы</h3>

<p>Рассмотрим простую схему из трех блоков и двух связей (одна из которых &ndash; с пояснительным текстом
&laquo;метки&raquo;):</p>

<div class="pic" id="pic5"><div class="container" id="light_pic5">
<img src="img/Transl_Pic5.png" width="524" height="315" alt="Пример схемы" />
</div></div>

<p class="noindent">В этой схеме, на первый взгляд, перевода требуют следующие тексты:</p>

<ul>
  <li>заголовок графика;</li>
  <li>подписи обеих осей графика;</li>
  <li>пояснительный текст &laquo;метки&raquo; на верхней связи;</li>
  <li>текст на блоке вычисления функции.</li>
</ul>

<p class="noindent">Почему текст &laquo;dbl&raquo; на блоке ввода матрицы не будет переведен,
объясняется в <a href="#light_p1_3">1.3</a>.</p>

<p>Пример файла перевода без связанного служебного файла для языков
&laquo;Русский&raquo; и &laquo;English&raquo; (переводы уже добавлены):</p>

<pre class="cpp">"RDSTRANSLATESERV","CODING\АБВГД","Русский","English"
"0","0101qj4q1w","Слой 1","Layer 1"
"0","0101qj5q2w","Основная","Main"
"0","0102q3e8qw0104q3e8qw","График","Plot"
"0","0102q3e9qw0104q3e9qw","Ось X","X axis"
"0","0102q3eaqw0104q3eaqw","Ось Y","Y axis"
"1","0106qj2qw","Вычисление
табличной
функции","Table
computation"
"0","0104qjaqw","Открыть","Open"
"1","0105qj7qw","Метки","Marks"
"0","4C696E655374796C6573q1qw","Стандартная связь","Default connection"
"0","4C696E655374796C6573q2qw","Стандартная шина","Default bus"</pre>

<p>Этот же файл в виде таблицы для большей ясности:</p>

<div class="tablecenter"><div class="tcont">
<table>

<tr>
  <td class="center"><b>№</b></td>
  <td class="center"><b>1</b></td>
  <td class="center"><b>2</b></td>
  <td class="center"><b>3</b></td>
  <td class="center"><b>4</b></td>
</tr>

<tr>
  <td class="center"><b>1</b></td>
  <td>RDSTRANSLATESERV</td>
  <td>CODING\АБВГД</td>
  <td>Русский</td>
  <td>English</td>
</tr>

<tr>
  <td class="center"><b>2</b></td>
  <td>0</td>
  <td>0101qj4q1w</td>
  <td>Слой 1</td>
  <td>Layer 1</td>
</tr>

<tr>
  <td class="center"><b>3</b></td>
  <td>0</td>
  <td>0101qj5q2w</td>
  <td>Основная</td>
  <td>Main</td>
</tr>

<tr>
  <td class="center"><b>4</b></td>
  <td>0</td>
  <td>0102q3e8qw0104q3e8qw</td>
  <td>График</td>
  <td>Plot</td>
</tr>

<tr>
  <td class="center"><b>5</b></td>
  <td>0</td>
  <td>0102q3e9qw0104q3e9qw</td>
  <td>Ось X</td>
  <td>X axis</td>
</tr>

<tr>
  <td class="center"><b>6</b></td>
  <td>0</td>
  <td>0102q3eaqw0104q3eaqw</td>
  <td>Ось Y</td>
  <td>Y axis</td>
</tr>

<tr>
  <td class="center"><b>7</b></td>
  <td>1</td>
  <td>0106qj2qw</td>
  <td>Вычисление<br />табличной<br />функции</td>
  <td>Table<br />computation</td>
</tr>

<tr>
  <td class="center"><b>8</b></td>
  <td>0</td>
  <td>0104qjaqw</td>
  <td>Открыть</td>
  <td>Open</td>
</tr>

<tr>
  <td class="center"><b>9</b></td>
  <td>1</td>
  <td>0105qj7qw</td>
  <td>Метки</td>
  <td>Marks</td>
</tr>

<tr>
  <td class="center"><b>10</b></td>
  <td>0</td>
  <td>4C696E655374796C6573q1qw</td>
  <td>Стандартная связь</td>
  <td>Default connection</td>
</tr>

<tr>
  <td class="center"><b>11</b></td>
  <td>0</td>
  <td>4C696E655374796C6573q2qw</td>
  <td>Стандартная шина</td>
  <td>Default bus</td>
</tr>

</table>
</div></div>

<p>Можно заметить, что в файл, кроме указанных выше текстов, попали также имя слоя и конфигурации подсистемы
(строки 1 и 2), имя пункта меню открытия редактора матрицы (строка 8), а также имена стандартных стилей
связи и шины (строки 10 и 11). Это тоже тексты, хранящиеся в схеме, и, поэтому, они тоже были выгружены
в файл перевода. В первом столбце для всех текстов записан ноль, кроме текста на блоке (строка 7) и
пояснительного текста связи (строка 9), для которых записана единица &ndash; только эти два текста могут
иметь внутри разрывы строк. Второй столбец файла содержит кодированную служебную информацию.</p>

<p>Результат загрузки этого файла в схему для языка &laquo;English&raquo; выглядит так:</p>

<div class="pic"><div class="container">
<img src="img/Transl_Pic6.png" width="524" height="315" alt="Пример переведенной схемы" />
</div></div>

<p>Этот же файл перевода при сохранении служебной информации в отдельный файл будет выглядеть так:</p>

<pre class="cpp">"RDSTRANSLATESERV","CODING\АБВГД\EXT\csvd","Русский","English"
"0","1","Слой 1","Layer 1"
"0","2","Основная","Main"
"0","3","График","Plot"
"0","4","Ось X","X axis"
"0","5","Ось Y","Y axis"
"1","6","Вычисление
табличной
функции","Table
computation"
"0","7","Открыть","Open"
"1","8","Метки","Marks"
"0","9","Стандартная связь","Default connection"
"0","10","Стандартная шина","Default bus"</pre>

<p>В табличной форме:</p>

<div class="tablecenter"><div class="tcont">
<table>

<tr>
  <td class="center"><b>№</b></td>
  <td class="center"><b>1</b></td>
  <td class="center"><b>2</b></td>
  <td class="center"><b>3</b></td>
  <td class="center"><b>4</b></td>
</tr>

<tr>
  <td class="center"><b>1</b></td>
  <td>RDSTRANSLATESERV</td>
  <td>CODING\АБВГД\EXT\csvd</td>
  <td>Русский</td>
  <td>English</td>
</tr>

<tr>
  <td class="center"><b>2</b></td>
  <td>0</td>
  <td>1</td>
  <td>Слой 1</td>
  <td>Layer 1</td>
</tr>

<tr>
  <td class="center"><b>3</b></td>
  <td>0</td>
  <td>2</td>
  <td>Основная</td>
  <td>Main</td>
</tr>

<tr>
  <td class="center"><b>4</b></td>
  <td>0</td>
  <td>3</td>
  <td>График</td>
  <td>Plot</td>
</tr>

<tr>
  <td class="center"><b>5</b></td>
  <td>0</td>
  <td>4</td>
  <td>Ось X</td>
  <td>X axis</td>
</tr>

<tr>
  <td class="center"><b>6</b></td>
  <td>0</td>
  <td>5</td>
  <td>Ось Y</td>
  <td>Y axis</td>
</tr>

<tr>
  <td class="center"><b>7</b></td>
  <td>1</td>
  <td>6</td>
  <td>Вычисление<br />табличной<br />функции</td>
  <td>Table<br />computation</td>
</tr>

<tr>
  <td class="center"><b>8</b></td>
  <td>0</td>
  <td>7</td>
  <td>Открыть</td>
  <td>Open</td>
</tr>

<tr>
  <td class="center"><b>9</b></td>
  <td>1</td>
  <td>8</td>
  <td>Метки</td>
  <td>Marks</td>
</tr>

<tr>
  <td class="center"><b>10</b></td>
  <td>0</td>
  <td>9</td>
  <td>Стандартная связь</td>
  <td>Default connection</td>
</tr>

<tr>
  <td class="center"><b>11</b></td>
  <td>0</td>
  <td>10</td>
  <td>Стандартная шина</td>
  <td>Default bus</td>
</tr>

</table>
</div></div>

<p>Здесь вместо кодированной служебной информации записаны целые числа. При такой записи файл сложнее
случайно испортить.</p>

<h2 id="light_p1_3">1.3. Переводимые и не переводимые тексты</h2>

<p>В файл перевода включаются следующие тексты:</p>

<ul>
  <li>имена слоев и конфигураций всех подсистем схемы;</li>
  <li>те имена блоков, для которых пользователь явно указал, что их нужно переводить (см. ниже);</li>
  <li>тексты на прямоугольниках блоков, кроме тех, для которых пользователь явно запретил перевод (см. ниже);</li>
  <li>комментарии блоков;</li>
  <li>текстовые элементы векторных картинок, кроме тех, для которых пользователь явно запретил перевод (см. ниже);</li>
  <li>введенные вручную заголовки окон подсистем;</li>
  <li>имена стилей связей и шин;</li>
  <li>имена классов объектов;</li>
  <li>пояснительные тексты на связях, кроме тех, для которых пользователь явно запретил перевод (см. ниже);</li>
  <li>имена шин;</li>
  <li>имена пунктов меню настройки блоков;</li>
  <li>значения строковых параметров связей, кроме тех, для которых пользователь явно запретил перевод (см. ниже);</li>
  <li>комментарии к переменным блоков и каналов шин;</li>
  <li>значения по умолчанию для строковых переменных;</li>
  <li>внутренние параметры блоков по требованию их моделей (заголовки полей ввода и графиков,
  названия пунктов в блоке выбора варианта, надписи на кнопках и т.п.);</li>
  <li>значения настроечных параметров автокомпилируемых блоков, кроме тех, для которых пользователь явно
  запретил перевод (см. ниже).</li>
</ul>

<p class="noindent">Тексты никогда не попадают в файл перевода, если они пустые, или если
в них нет ни одной буквы. Например, текстовая запись какого-нибудь числа вида &laquo;2.34&raquo; в файл перевода
не попадет. Строки из одних спецсимволов, например &laquo;(&hellip;)&raquo; (текст на стандартном блоке
проверки попадания числа в диапазон) тоже не переводятся.</p>

<p>Для некоторых текстов в интерфейс пользователя добавлены флажки разрешения или запрещения перевода. Это
связано с тем, что не все тексты, даже состоящие из букв, нужно переводить. Например, надпись
&laquo;dbl&raquo; на блоке ввода матрицы (см. <a href="#pic5">рисунок</a>) переводить не нужно, как и надпись
&laquo;K&raquo; на блоке умножения на константу. Другой пример &ndash; имена блоков. В подавляющем большинстве
случаев их не нужно переводить &ndash; их очень много, и файл перевода с ними разрастется до огромного
размера, а пользователи обычно на них и не смотрят. Но из-за того, в именах блоков исходно не было запрещено
использование русские букв, теперь пользователи иногда используют имя блока в качестве какой-то
информативной подписи к нему, и тогда их переводить нужно.</p>

<p>На данный момент введены следующие флажки:</p>

<ul>
  <li>Флажок разрешения перевода имени блока &ndash; в окне параметров блока рядом с именем. По умолчанию
  выключен. Имена блоков, за редкими исключениями, не интересны пользователям, поэтому обычно
  не требуют перевода.</li>
</ul>

<div class="pic"><div class="container">
<img src="img/Transl_Pic7.png" width="534" height="112" alt="Флажок перевода имени" />
</div></div>

<ul>
  <li>Флажок разрешения перевода текстового элемента векторной картинки блока (таких два: строка текста и
  абзац текста) &ndash; в окне параметров элемента рядом с текстом. По умолчанию включен. Следует выключать для
  элементов формул или общих математических надписей и стандартных обозначений (&laquo;K&raquo;, символ интеграла,
  абстрактные &laquo;x&raquo; и &laquo;y&raquo; и т.п.).</li>
</ul>

<div class="pic"><div class="container">
<img src="img/Transl_Pic8.png" width="428" height="195" alt="Флажок перевода текста в картинке" />
</div></div>

<ul>
  <li><span id="light_textrecttr">Флажок разрешения перевода текста на прямоугольнике блока</span> &ndash;
  в окне параметров блока на вкладке
  &laquo;внешний вид&raquo; рядом с текстом. По умолчанию включен. Следует выключать для стандартных условных
  обозначений (например &laquo;MS&raquo; для мультиплексора или &laquo;DC&raquo; для дешифратора переводить не надо).</li>
</ul>

<div class="pic"><div class="container">
<img src="img/Transl_Pic9.png" width="384" height="131" alt="Флажок перевода текста на блоке" />
</div></div>

<ul>
  <li><span id="light_conntexttr">Флажок разрешения перевода пояснительного текста связи</span> &ndash;
  в окне параметров связи на вкладке
&laquo;текст&raquo; рядом с самим текстом. По умолчанию включен. Может также отключаться программно моделями
блоков (сам пользователь, вероятнее всего, вообще не будет заходить на эту вкладку). Его выключение сделано
по единственной причине &ndash; в разрабатываемых сейчас моделях когнитивных карт этот текст используется
для показа пользователю функции на связи, а ее переводить не нужно, даже если там будут какие-нибудь буквы.</li>
</ul>

<div class="pic"><div class="container">
<img src="img/Transl_Pic10.png" width="398" height="205" alt="Флажок перевода текста связи" />
</div></div>

<ul>
  <li><span id="light_connpartr">Флажок разрешения перевода значения строкового дополнительного
  параметра связи</span> &ndash; в окне ввода
  этого параметра рядом со значением. По умолчанию включен. Может также отключаться программно моделями
  блоков. Отключение перевода введено по той же причине &ndash; в моделях когнитивных карт эти параметры
  используются для хранения текстов функций. Пользователь обычно напрямую с ними не взаимодействует,
  и переводы будут отключаться программно.</li>
</ul>

<div class="pic"><div class="container">
<img src="img/Transl_Pic11.png" width="389" height="170" alt="Флажок перевода параметра связи" />
</div></div>

<ul>
  <li>Флажок разрешения перевода значения настроечного параметра типа &laquo;строка&raquo; (
  &laquo;<span class="cpp">rdsbcppString</span>&raquo;) в редакторе модели автокомпилируемого блока &ndash;
  в окне ввода этого параметра рядом со значением. По умолчанию включен. Строковые настроечные параметры
  создателями автокомпилируемых блоков используются редко. Если создатель модели решит хранить в таком
  параметре какую-нибудь служебную информацию, флажок необходимо выключить, чтобы эта служебная информация
  не попала в файл перевода. Если же это обычный текст &ndash; например, заголовок какого-нибудь рисуемого
  автокомпилируемым блоком индикатора &ndash; флажок следует оставлять включенным.</li>
</ul>

<div class="pic"><div class="container">
<img src="img/Transl_Pic12.png" width="623" height="135" alt="Флажок перевода параметра автокомпилируемого блока" />
</div></div>

<p>Строковые настроечные параметры автокомпилируемых блоков можно использовать и для того, чтобы можно было
переводить какие-то важные для работы модели тексты, которые сам пользователь не вводит. Пусть, например,
блок-индикатор выводит на своем изображении какой-то фиксированный текст при выполнении какого-нибудь условия.
Если жестко &laquo;зашить&raquo; этот текст в модель, он не будет переводиться (задача перевода интерфейса
RDS пока не рассматривалась). Но если создать в блоке настроечный параметр (не предусматривая для него поля
ввода в окне настроек), ввести этот текст в качестве значения параметра по умолчанию, а на изображении
блока выводить не фиксированный текст, а значение этого параметра, то он попадет в файл перевода и будет
переведен на другой язык.</p>

<p>Код вызова <a href="#light_p2_2">функций перевода</a> для настроечных параметров, добавленных
через редактор модели (см. &sect;3.6.6 описания пользователя), модуль автокомпиляции
вставляет в модель автоматически.</p>

<h2 id="light_p1_4">1.4. Проблемы с &laquo;бесхозными&raquo; текстами</h2>

<p>В схемах иногда встречаются тексты общего назначения, не привязанные к каким-либо конкретным параметрам блоков.
Типичный пример таких текстов &ndash; строки в матрицах строк, которые пользователь может изменять, менять местами,
удалять и т.п. К таким текстам не получается привязать идентификатор, по которому можно было бы отслеживать их
изменение пользователем и сохранять для них тексты на других языках при таком изменении.</p>

<p>Если пользователь, например, изменит заголовок какого-либо графика на английском, RDS будет знать, что
этот новый текст &ndash; именно заголовок графика в блоке таком-то, и при синхронизации схемы с файлом
перевода будет понятно, с каким русским текстом его нужно соотносить. Как бы пользователь не
менял текст заголовка, этот набор букв будет оставаться заголовком конкретного графика.</p>

<p>Теперь рассмотрим матрицу строк в блоке ввода матриц. Сейчас, допустим, эта матрица используется для
задания названий каких-либо агентов, и ней записаны строки &laquo;первый агент&raquo;,
&laquo;второй агент&raquo; и &laquo;третий агент&raquo;. А потом пользователь решит использовать этот же
блок ввода матриц для задания названий параметров, удалит там третью строку, а в первые две запишет тексты
&laquo;себестоимость&raquo; и &laquo;прибыль&raquo;. Даже если бы удалось привязать к каждой абстрактной строке
постоянный, хранящийся вечно идентификатор для отслеживания ее судьбы в схеме (а это практически невозможно),
получилось бы, что старая строка &laquo;первый агент&raquo; и новая строка
&laquo;себестоимость&raquo; &ndash; это один и тот же объект схемы, и при переводе на английский
&laquo;себестоимость&raquo; заменилась бы на уже сделанный ранее перевод для этого объекта &ndash;
&laquo;first agent&raquo;. Получается, что запоминание истории переводов таких текстов порождает больше
проблем, чем решает.</p>

<p>То есть в схеме есть конкретные параметры с неизменной ролью, привязанные к определенным блокам и
связям (заголовки, подписи и т.п.), а есть &laquo;тексты общего назначения&raquo;, то есть просто тексты,
не имеющие фиксированной привязки к чему-нибудь. Здесь они для краткости будут называтьтся &laquo;бесхозными&raquo;
текстами, и для них переводы ищутся просто по строке текста на текущем языке. То есть при загрузке перевода
для текста &laquo;себестоимость&raquo; будет найдена первая попавшаяся строка в файле, в которой в столбце
&laquo;русский&raquo; записано слово &laquo;себестоимость&raquo;, и перевод будет взят из столбца
&laquo;english&raquo; этой же строки.</p>

<p>Это приводит к некоторым проблемам: при редактировании таких текстов у них теряется перевод. Допустим, например,
что пользователь загрузил из файла английский язык, и русский текст &laquo;первый агент&raquo; заменился на
английский текст &laquo;first agent&raquo;. Но пользователю, по какой-то причине, этот текст не понравился,
и он прямо в схеме заменил его на &laquo;1st agent&raquo; и синхронизировал файл перевода. RDS при этом не сможет
найти в старом файле перевода нужную строку: там находилась пара &laquo;первый агент&raquo;&ndash;&laquo;first agent&raquo;,
а поиск теперь будет выполняться по новому тексту &laquo;1st agent&raquo;, который в файле отсутствует. В
результате последующая загрузка русского языка приведет к тому, что &laquo;1st agent&raquo; не будет заменен на
русскую версию, которая для этого нового текста не будет найдена в файле.</p>

<p>К счастью, такие &laquo;бесхозные&raquo; тексты встречаются в схемах только в упомянутом блоке ввода матриц
строк (включая содержимое запомненных матриц). Все остальные текстовые параметры блоков, вероятнее всего,
будут иметь жесткую смысловую привязку, и проблем с ними не возникнет.</p>

<h2 id="light_p1_5">1.5. Обратная совместимость</h2>

<p>Для поддержки функций перевода в файлы схем, блоков и автокомпилируемых моделей добавлены новые
параметры. Теперь в файле схемы дополнительно хранятся:</p>

<ul>
  <li>список языков схемы;</li>
  <li>специальные идентификаторы объектов для файла перевода, которые гарантированно не будут использованы
  повторно при стирании старых и добавлении новых объектов;</li>
  <li>флажки разрешения/запрещения перевода параметров из <a href="#light_p1_3">1.3</a>.</li>
</ul>

<p class="noindent">Гарантируется прямая совместимость, т.е. любая схема или модель,
сохраненная в старой версии RDS, будет нормально загружаться в новой версии.</p>

<p>Обратная совместимость возможна только для схем, в которых не введен список языков, ни
разу не сохранялся файл перевода, и пользователь не трогал флажки разрешения/запрещения перевода.
Такие схемы можно сохранить в новой версии RDS, а потом загрузить в старой, потому что в них не будет этих
дополнительных данных, на которых &laquo;споткнется&raquo; старая версия при разборе файла схемы.</p>

<p>Разумеется, если не пытаться работать с новыми схемами в старой версии RDS, а установить
обновление, проблем не будет.</p>

<h1 id="light_p2">2. Для программиста</h1>

<h2 id="light_p2_1">2.1. Событие <span class="cpp">RDS_BFM_TRANSLATE</span></h2>

<p>Для поддержки перевода схемы в RDS добавлено новое событие <span class="cpp">RDS_BFM_TRANSLATE</span>,
реакция на которое вызывается у блоков в двух случаях:</p>

<ul>
  <li>при записи нового файла перевода или синхронизации схемы с существующим файлом;</li>
  <li>при загрузке перевода из файла.</li>
</ul>

<p class="noindent">В обоих случаях действия модели блока должны быть следующими: она должна для каждого из имеющихся у нее
текстовых параметров, которым требуется перевод, вызвать одну из двух <a href="#light_p2_2">функций перевода</a>,
передав в параметрах этих функций сам текст и, при необходимости, внутренний идентификатор параметра в блоке.
Если реакция на событие
вызвана из-за загрузки другого языка, то функция перевода вернет новый (переведенный) текст,
который модель блока должна принять и сохранить в соответствующем параметре. Если реакция вызвана из-за сохранения
файла перевода, или если для данного параметра перевода нет, функция перевода возвращает <span class="cpp">NULL</span>.</p>

<p>В большинстве случаев разработчику не нужно определять конкретную причину события &ndash; достаточно
вызвать функцию перевода для каждого параметра и, если она вернула не <span class="cpp">NULL</span>,
записать в параметр новое значение (простой пример приведен в <a href="#light_p2_3">2.3</a>). Возвращать функция
модели при этом должна константу <span class="cpp">RDS_BFR_DONE</span> (ноль).</p>

<p>Однако, в сложных блоках
с разветвленными настройками может потребоваться создание для переводимых параметров уникальных
идентификаторов, которые должны запоминаться в схеме. Например, в блоке-графике, рисующем произвольное
число функций по данным из поступающей на вход матрицы, необходимо создать для каждой добавленной пользователем
в настройках линии уникальный идентификатор, чтобы можно было перевести легенду этой линии, и чтобы линия не теряла связь
со своим переведенными текстами, что бы с ней не происходило. Порядковый
номер линии для этого использовать нельзя, поскольку пользователь может поменять линии местами, из-за чего
из номера изменятся и будет загружаться неверный перевод. Можно создавать
такие идентификаторы при добавлении пользователем этих линий в настройках блока, но, поскольку на момент
включения в RDS функций перевода большое количество моделей блоков уже существует без каких-либо
внутренних идентификаторов параметров, есть возможность создавать идентификаторы в момент вызова реакции
на событие <span class="cpp">RDS_BFM_TRANSLATE</span>. Для этого функция модели должна распознавать
конкретную причину вызова реакции на это событие: идентификаторы нужно создавать <span class="emph">только</span>
при вызове из-за создания/синхронизации файла перевода.</p>

<p>При вызове модели блока для реакции на событие <span class="cpp">RDS_BFM_TRANSLATE</span> в параметре <span class="cpp">ExtParam</span> (см.
&sect;2.3 руководства программиста и приложение А.2.1) передается указатель на структуру
<span class="cpp">RDS_TRANSLATEDATA</span>:</p>

<pre class="cpp">  <span class="kw">typedef</span> <span class="kw">struct</span>
  { BOOL Save;  <span class="rem">// TRUE  - идет запись файла перевода</span>
                <span class="rem">// FALSE - идет загрузка перевода</span>
  } RDS_TRANSLATEDATA;
  <span class="kw">typedef</span> RDS_TRANSLATEDATA *RDS_PTRANSLATEDATA;</pre>

<p>Идентификаторы для внутренних переводимых параметров блока нужно формировать, только если в поле
<span class="cpp">Save</span> этой структуры находится значение <span class="cpp">TRUE</span>. При этом,
если хотя бы один новый идентификатор сформирован, функция модели блока должна вернуть
значение <span class="cpp">RDS_BFR_MODIFIED</span> (или любое ненулевое значение).</p>

<h2 id="light_p2_2">2.2. Функции поддержки перевода</h2>

<p>Для передачи в RDS текстов переводимых параметров и получения их переводов предусмотрено две функции.
Чаще всего используется функция перевода текста с идентификатором <span class="cpp">rdsTranslateParameter</span>.</p>

<h3 id="light_p2_2_1">2.2.1. Функция <span class="cpp">rdsTranslateParameter</span></h3>

<p>Функция <span class="cpp">rdsTranslateParameter</span> предназначена для перевода текста параметра, у которого
в блоке есть определенное фиксированное назначение (в отличие от &laquo;бесхозных&raquo;
текстов, упоминавшихся в <a href="#light_p1_4">1.4</a>). Функция может вызываться только в реакции на событие
<span class="cpp"><a href="#light_p2_1">RDS_BFM_TRANSLATE</a></span>, в остальных случаях ее вызов игнорируется.</p>

<pre class="cpp">  LPSTR RDSCALL rdsTranslateParameter(
    LPSTR Text,     <span class="rem">// Текст параметра</span>
    <span class="kw">int</span> Multiline,  <span class="rem">// Наличие в тексте переводов строк (RDS_TRANSLML_*)</span>
    <span class="kw">int</span> ParamId,    <span class="rem">// Целый идентификатор параметра</span>
    LPSTR ParamEx,  <span class="rem">// Строковый идентификатор параметра (если нужен) или NULL</span>
    <span class="kw">int</span> *pLength    <span class="rem">// Возвращаемая длина нового текста или NULL</span>
  );</pre>

<p class="apphdr">Параметры</p>

<dl>
  <dt><span class="cpp">Text</span>&emsp;(<span class="cpp"><i>LPSTR</i></span>)</dt>
  <dd>Переводимый текст (значение какого-то строкового параметра блока).</dd>

  <dt><span class="cpp">Multiline</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Одна из трех констант, указывающих на возможное наличие и вид переводов строк в тексте:
    <div class="tableleft"><div class="tcont">
      <table class="list">
        <tr>
          <td class="term"><span class="cpp">RDS_TRANSLML_SINGLE</span></td>
          <td>В тексте запрещены любые переводы строк (однострочный текст).</td>
        </tr>
        <tr>
          <td class="term"><span class="cpp">RDS_TRANSLML_LF</span></td>
          <td>Текст разбивается на строки при помощи символа &laquo;\n&raquo; (код <span class="cpp">0x0A</span>).</td>
        </tr>
        <tr>
          <td class="term"><span class="cpp">RDS_TRANSLML_CRLF</span></td>
          <td>Текст разбивается на строки при помощи пары символов &laquo;\r&raquo; и &laquo;\n&raquo;
		  (коды <span class="cpp">0x0D</span> и <span class="cpp">0x0A</span>).</td>
        </tr>
		</table>
    </div></div>
  </dd>

  <dt><span class="cpp">ParamId</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Уникальный в данном блоке идентификатор этого текста (используется только при переводе, должен быть положительным).</dd>

  <dt><span class="cpp">ParamEx</span>&emsp;(<span class="cpp"><i>LPSTR</i></span>)</dt>
  <dd>Дополнительный строковый идентификатор этого текста, если он нужен. Если не нужен, можно передать
  <span class="cpp">NULL</span>. Нужен от бывает в тех случаях, когда разработчик хочет &laquo;повесить&raquo;
  на один и тот же <span class="cpp">ParamId</span> несколько разных текстов. В приведенном выше примере с линиями
  графика число этих линий заранее не известно, поэтому, чтобы гарантированно не пересечься с идентификаторами
  других параметров графика (заголовков осей, всего графика и т.п.) логично для легенд всех линий передавать
  один и тот же общий уникальный <span class="cpp">ParamId</span>, а идентификатор конкретной линии передавать в
  текстовом виде в <span class="cpp">ParamEx</span>.</dd>

  <dt><span class="cpp">pLength</span>&emsp;(<span class="cpp"><i>int*</i></span>)</dt>
  <dd>Указатель на целую переменную, в которую функция запишет длину возвращаемого переведенного текста
  (или <span class="cpp">NULL</span>, если эта длина не нужна).</dd>
</dl>

<p class="apphdr">Возвращаемое значение</p>
<p>Если событие <span class="cpp"><a class="hidden" href="#light_p2_1">RDS_BFM_TRANSLATE</a></span>,
в реакции на которое вызвана функция,
произошло из-за загрузки другого языка из файла перевода, функция возвращает указатель на новый текст для
данного параметра во внутреннем буфере RDS (текст в буфере хранится только до следующего вызова
<span class="cpp">rdsTranslateParameter</span> или
<span class="cpp"><a href="#light_p2_2_2">rdsTranslateText</a></span>). Модель должна переписать этот текст туда,
где она хранит значение параметра. Если текст, переданный в параметре <span class="cpp">Text</span>, не требует
перевода (например, он пустой), или если событие <span class="cpp">RDS_BFM_TRANSLATE</span> произошло
из-за записи файла перевода, функция возвращает <span class="cpp">NULL</span>, и от модели не требуется никаких
дальнейших действий.</p>

<p>Пример использования функции приведен в <a href="#light_p2_3">2.3</a>.</p>

<h3 id="light_p2_2_2">2.2.2. Функция <span class="cpp">rdsTranslateText</span></h3>

<p>Функция <span class="cpp">rdsTranslateText</span> предназначена для перевода
&laquo;<a href="#light_p1_4">бесхозного</a>&raquo; текста. Она может вызываться только в реакции на событие
<span class="cpp"><a class="hidden" href="#light_p2_1">RDS_BFM_TRANSLATE</a></span>, в
остальных случаях ее вызов игнорируется. </p>

<pre class="cpp">  LPSTR RDSCALL rdsTranslateText(
    LPSTR Text,     <span class="rem">// Текст параметра</span>
    <span class="kw">int</span> Multiline,  <span class="rem">// Наличие в тексте переводов строк (RDS_TRANSLML_*)</span>
    <span class="kw">int</span> *pLength    <span class="rem">// Возвращаемая длина нового текста или NULL</span>
  );</pre>

<p class="apphdr">Параметры</p>

<dl>
  <dt><span class="cpp">Text</span>&emsp;(<span class="cpp"><i>LPSTR</i></span>)</dt>
  <dd>Переводимый текст (значение какого-то строкового параметра блока).</dd>

  <dt><span class="cpp">Multiline</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Одна из трех констант, указывающих на возможное наличие и вид переводов строк в тексте:
    <div class="tableleft"><div class="tcont">
      <table class="list">
        <tr>
          <td class="term"><span class="cpp">RDS_TRANSLML_SINGLE</span></td>
          <td>В тексте запрещены любые переводы строк (однострочный текст).</td>
        </tr>
        <tr>
          <td class="term"><span class="cpp">RDS_TRANSLML_LF</span></td>
          <td>Текст разбивается на строки при помощи символа &laquo;\n&raquo; (код <span class="cpp">0x0A</span>).</td>
        </tr>
        <tr>
          <td class="term"><span class="cpp">RDS_TRANSLML_CRLF</span></td>
          <td>Текст разбивается на строки при помощи пары символов &laquo;\r&raquo; и &laquo;\n&raquo;
		  (коды <span class="cpp">0x0D</span> и <span class="cpp">0x0A</span>).</td>
        </tr>
		</table>
    </div></div>
  </dd>

  <dt><span class="cpp">pLength</span>&emsp;(<span class="cpp"><i>int*</i></span>)</dt>
  <dd>Указатель на целую переменную, в которую функция запишет длину возвращаемого переведенного текста
  (или <span class="cpp">NULL</span>, если эта длина не нужна).</dd>
</dl>

<p class="apphdr">Возвращаемое значение</p>
<p>Если событие <span class="cpp"><a class="hidden" href="#light_p2_1">RDS_BFM_TRANSLATE</a></span>,
в реакции на которое вызвана функция,
произошло из-за загрузки другого языка из файла перевода, функция возвращает указатель на новый текст для
данного параметра во внутреннем буфере RDS (текст в буфере хранится только до следующего вызова
<span class="cpp"><a href="#light_p2_2_1">rdsTranslateParameter</a></span> или
<span class="cpp">rdsTranslateText</span>). Модель должна переписать этот текст туда,
где она хранит значение параметра. Если текст, переданный в параметре <span class="cpp">Text</span>, не требует
перевода (например, он пустой), или если событие <span class="cpp">RDS_BFM_TRANSLATE</span> произошло
из-за записи файла перевода, функция возвращает <span class="cpp">NULL</span>, и от модели не требуется никаких
дальнейших действий.</p>

<h2 id="light_p2_3">2.3. Пример реакции на событие перевода</h2>

<p>Пусть личная область данных блока (см. &sect;2.4 руководства программиста) представляет собой объект
следующего класса:</p>

<pre class="cpp">  <span class="kw">class</span> TTransData
  { <span class="kw">public</span>:
      <span class="preproc">#define TRANSDATATEXTLEN 100</span>
      <span class="kw">char</span> Line[TRANSDATATEXTLEN+<span class="const">1</span>];
      <span class="kw">char</span> Text[TRANSDATATEXTLEN+<span class="const">1</span>];
      TTransData(<span class="kw">void</span>)
        { Line[<span class="const">0</span>]=Text[<span class="const">0</span>]=<span class="const">0</span>; };
  };</pre>

<p>Здесь в личной области данных находятся два символьных массива: <span class="cpp">Line</span> и
<span class="cpp">Text</span>. Будем считать, что хранящиеся в них тексты должны переводиться, причем текст в
массиве <span class="cpp">Line</span> не может содержать переводов строк, а текст в массиве <span class="cpp">Text</span>
&ndash; может, и в качестве перевода строки в нем используется символ &laquo;\n&raquo;. Рассмотрим модель блока с такой
личной областью данных, опустив реакции на события загрузки, сохранения и настройки параметров (они подробно
рассматриваются в руководстве программиста).</p>

<pre class="cpp">  <span class="rem">//============= Модель блока ==============</span>
  <span class="kw">extern</span> <span class="str">"C"</span> <span class="kw">__declspec</span>(<span class="kw">dllexport</span>)
    <span class="kw">int</span> RDSCALL TransTest(<span class="kw">int</span> CallMode,
                          RDS_PBLOCKDATA BlockData,
                          LPVOID ExtParam)
  { TTransData *data=(TTest1Data*)(BlockData-&gt;BlockData);
    <span class="kw">char</span> *transl;

    <span class="kw">switch</span>(CallMode)
      { <span class="kw">case</span> RDS_BFM_INIT:      <span class="rem">// Инициализация</span>
          BlockData-&gt;BlockData=<span class="kw">new</span> TTransData();
          <span class="kw">break</span>;

        <span class="kw">case</span> RDS_BFM_CLEANUP:   <span class="rem">// Очистка</span>
          <span class="kw">delete</span> data;
          <span class="kw">break</span>;

        <span class="kw">case</span> RDS_BFM_SAVETXT:   <span class="rem">// Сохранение параметров</span>
          &hellip;
          <span class="kw">break</span>;

        <span class="kw">case</span> RDS_BFM_LOADTXT:   <span class="rem">// Загрузка параметров</span>
          &hellip;
          <span class="kw">break</span>;

        <span class="kw">case</span> RDS_BFM_SETUP:     <span class="rem">// Настройка параметров пользователем</span>
          &hellip;
          <span class="kw">break</span>;

        <span class="kw">case</span> RDS_BFM_TRANSLATE: <span class="rem">// Перевод</span>
          <span class="rem">// Параметр Line</span>
          transl=rdsTranslateParameter(
              Line,                <span class="rem">// Text</span>
              RDS_TRANSLML_SINGLE, <span class="rem">// Multiline</span>
              <span class="const">1</span>,                   <span class="rem">// ParamId</span>
              NULL,                <span class="rem">// ParamEx</span>
              NULL);               <span class="rem">// pLength</span>
          <span class="kw">if</span>(transl)
            { strncpy(Line,transl,TRANSDATATEXTLEN);
              Line[TRANSDATATEXTLEN]=<span class="const">0</span>;
            }
          <span class="rem">// Параметр Text</span>
          transl=rdsTranslateParameter(Text,RDS_TRANSLML_LF,
                                       <span class="const">2</span> <span class="rem">/*ParamId*/</span>,NULL,NULL);
          <span class="kw">if</span>(transl)
            { strncpy(Text,transl,TRANSDATATEXTLEN);
              Text[TRANSDATATEXTLEN]=<span class="const">0</span>;
            }
          <span class="kw">break</span>;
      }
    <span class="kw">return</span> RDS_BFR_DONE;
  }
  <span class="rem">//=========================================</span></pre>

<p>В реакции на событие <span class="cpp"><a class="hidden" href="#light_p2_1">RDS_BFM_TRANSLATE</a></span> для
каждого из двух параметров блока вызывется функция
<span class="cpp"><a class="hidden" href="#light_p2_2_1">rdsTranslateParameter</a></span>.
Для <span class="cpp">Line</span> она вызывается с идентификатором <span class="cpp">ParamId=1</span> и константой
<span class="cpp">RDS_TRANSLML_SINGLE</span>, указывающей на то, что в тексте не может быть переводов строк.
Результат возврата функции, если она вернула не <span class="cpp">NULL</span>, переписывается обратно в <span class="cpp">Line</span>
&ndash; так блок получает переведенный текст параметра. Для <span class="cpp">Text</span> выполняется точно такой же
вызов, но с идентификатором <span class="cpp">2</span> и константой <span class="cpp">RDS_TRANSLML_LF</span>,
поскольку в тексте могут быть переводы строк &laquo;\n&raquo;.</p>

<h2 id="light_p2_4">2.4. Программный запрет перевода текста на блоке</h2>

<p>Если модель блока программно формирует текст на прямоугольнике блока по каким-то свои внутренним
данным при помощи функции <span class="cpp">rdsSetBlockTextRectParams</span>, ей, в большинстве случаев, следует
запретить добавление текста на блоке в файл перевода &ndash; раз он все равно формируется программно,
нет никакой необходимости переводить его отдельно. Разумеется, при этом модель должна отдать для перевода
внутренние параметры, по которым формируется этот текст, а после загрузки перевода этих параметров ей
нужно будет сформировать текст на блоке заново.</p>

<p>Если модель заблокировала ручное редактирование текста на блоке при помощи установки
флага <span class="cpp">RDS_LOCKTEXTRECT</span> в поле <span class="cpp">Flags</span> структуры данных
блока (см. приложение А.2.3), то никаких специальных действий предпринимать не нужно: такой
текст в файл перевода не попадет. Если же редактирование не заблокировано, нужно при установке текста
присвоить значение <span class="cpp">FALSE</span>
новому полю <span class="cpp">Translate</span> структуры <span class="cpp">RDS_BLOCKTEXTRECTDATA</span>:</p>

<pre class="cpp">  <span class="kw">typedef</span> <span class="kw">struct</span>
  { DWORD servSize;   <span class="rem">// Размер этой структуры в байтах (необходимо присвоить перед вызовом)</span>
    BOOL Exists;      <span class="rem">// Блок имеет внешний вид в виде прямоугольника с текстом</span>
    LPSTR Text;       <span class="rem">// Текст</span>
    <span class="kw">int</span> HAlign;       <span class="rem">// Выравнивание текста (-1 - влево, 0 - по центру, 1 - вправо)</span>
    <span class="kw">int</span> VAlign;       <span class="rem">// Выравнивание текста (-1 - вверх, 0 - по центру, 1 - вниз)</span>
    BOOL BorderFlag;  <span class="rem">// Наличие рамки</span>
    <span class="kw">int</span> BorderWidth;  <span class="rem">// Толщина линии рамки</span>
    BOOL ScaleBorder; <span class="rem">// Масштабирование рамки</span>
    COLORREF Border;  <span class="rem">// Цвет рамки</span>
    BOOL FillFlag;    <span class="rem">// Наличие заполнения</span>
    COLORREF Fill;    <span class="rem">// Цвет заполнения</span>
    <span class="changes">BOOL Translate;</span>   <span class="rem">// Требуется перевод</span>
    <span class="rem">// Шрифт передается/получается в отдельной структуре RDS_SERVFONTPARAMS</span>
  } RDS_BLOCKTEXTRECTDATA;
  <span class="kw">typedef</span> RDS_BLOCKTEXTRECTDATA *RDS_PBLOCKTEXTRECTDATA;</pre>

<p>Это поле управляет состоянием <a href="#light_textrecttr">флажка перевода текста</a>,
который пользователь может переключать на вкладке &laquo;внешний вид&raquo; окна параметров блока.</p>

<h2 id="light_p2_5">2.5. Программный запрет перевода пояснительного текста связи</h2>

<p>Если модели блока необходимо запретить перевод пояснительного текста на связи (например, если блок
когнитивной карты записывает туда текст функции этой связи), для установки этого текста следует использовать
новую функцию <span class="cpp">rdsSetConnTextEx</span>:</p>

<pre class="cpp">  BOOL RDSCALL rdsSetConnTextEx(
    RDS_CHANDLE conn, <span class="rem">// Идентификатор связи</span>
    DWORD flags,      <span class="rem">// Флаги устанавливаемых параметров (RDS_SCTF_*) или 0 для всех</span>
    LPSTR text,       <span class="rem">// Устанавливаеиый текст или NULL для очистки</span>
    <span class="kw">int</span> alignment,    <span class="rem">// Выравнивание текста (-1 - влево,0 - по центру ,1 - вправо)</span>
    BOOL show,        <span class="rem">// Включить (TRUE) или выключить (FALSE) показ текста</span>
    <span class="kw">int</span> x,<span class="kw">int</span> y,      <span class="rem">// Координаты центра текста на рабочем поле</span>
    <span class="changes">BOOL translate</span>    <span class="rem">// Переводить (TRUE) или не переводить (FALSE) текст</span>
  );</pre>

<p>По сравнению со старой функцией <span class="cpp">rdsSetConnText</span>, в этой функции добавлен
логический параметр <span class="cpp">translate</span>, он управляет <a href="#light_conntexttr">флажком
разрешения перевода</a> на вкладке &laquo;текст&raquo; окна параметров связи.
Для того, чтобы функция использовала этот параметр,
в ее параметре <span class="cpp">flags</span> должен быть установлен
новый флаг <span class="cpp">RDS_SCTF_TRANSLATE</span>. То есть если раньше для установки текста
использовался вызов</p>

<pre class="cpp">  rdsSetConnText(conn,flags,text,alignment,show,x,y);</pre>

<p class="noindent">то для того, чтобы перевод устанавливаемого текста был запрещен,
вызов с такими же параметрами нужно делать так:</p>

<pre class="cpp">  rdsSetConnText<span class="changes">Ex</span>(conn,flags<span class="changes">|RDS_SCTF_TRANSLATE</span>,text,alignment,show,x,y<span class="changes">,FALSE</span>);</pre>

<h2 id="light_p2_6">2.6. Программный запрет перевода значения строкового параметра связи</h2>

<p>Если модели блока необходимо запретить перевод устанавливаемого ей дополнительного параметра
связи (например, если туда записывается текстовая служебная информация, которую пользователь видеть
не будет), то в параметре <span class="cpp">Flags</span> функции <span class="cpp">rdsSetConnExtParamByIdEx</span>
следует устанавливать новый флаг <span class="cpp">RDS_ACP_NOTRANSLATE</span>. Этот флаг
выключает <a href="#light_connpartr">флажок разрешения перевода параметра</a> (если флаг не установлен,
перевод будет разрешен).</p>

<p>То есть если раньше для установки значения параметра использовался вызов</p>

<pre class="cpp">  rdsSetConnExtParamByIdEx(сonn,id,RDS_VARTYPE_STRING,<span class="const">0</span>,<span class="const">0</span>,string,flags);</pre>

<p class="noindent">то для того, чтобы перевод значения параметра был запрещен,
этот же вызов нужно делать так:</p>

<pre class="cpp">  rdsSetConnExtParamByIdEx(сonn,id,RDS_VARTYPE_STRING,<span class="const">0</span>,<span class="const">0</span>,string,flags<span class="changes">|RDS_ACP_NOTRANSLATE</span>);</pre>

<p>Флаг <span class="cpp">RDS_ACP_NOTRANSLATE</span> влияет только на строковые параметры, т.е. параметры типа
<span class="cpp">RDS_VARTYPE_STRING</span>. Целые и вещественные параметры связей, разумеется,
никогда не переводятся.</p>

<hr />

</div>

<p class="bottom"><a href="index.html#light_translate">Назад</a></p>

</body>
</html>
