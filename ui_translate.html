<!DOCTYPE html>
<html lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="css/main.css" />
  <link rel="stylesheet" type="text/css" href="css/cpp.css" />
  <script type="text/javascript" src="script.js"></script>
  <link rel="icon" type="image/png" href="/favicon.png" />
  <title>Перевод интерфейса пользователя</title>
</head>

<body onload="DocLoad()">
<p class="top"><a href="index.html#light_uitranslate">Назад</a></p>
<div class="text">

<h1>Перевод интерфейса пользователя</h1>

<p>К интерфейсу пользователя RDS относятся все тексты, встроенные в основную программу
(&laquo;rds.exe&raquo;) и в модели блоков: названия пунктов меню, заголовки окон и полей ввода,
тексты сообщений, выводимых пользователю в отдельных окнах и т.п. К интерфейсу пользователя
<span class="emph">не относятся</span> любые тексты в схемах: надписи на блоках, комментарии
переменных и т.п. (такие тексты переводятся при помощи уже сделанных
<a href="translate.html">функций перевода схем</a>). Важно уметь отличать одно от другого.
Например, надпись &laquo;Шрифт&hellip;&raquo; на кнопке в окне настроек какого-либо блока
относится к интерфейсу пользователя, а любая надпись на блоке-кнопке, расположенном в схеме &ndash;
к этой схеме. Текущий язык в схеме и в интерфейсе пользователя устанавливаются независимо: можно,
например, работать в RDS с русским интерфейсом со схемой, переведенной на английский, и наоборот.</p>

<p>Тексты элементов интерфейса пользователя главной программы RDS
(&laquo;rds.exe&raquo;) и DLL с моделями блоков хранятся в
<a href="#light_p1">служебных файлах</a>, входящих в состав
RDS. Каждый набор таких файлов соответствует одному языку интерфейса.
Перевод окон настроек в автокомпилируемых моделях сделан по-другому: для каждого элемента интерфейса
окна настройки тексты на разных языках хранятся в самом файле модели (&laquo;.mdl&raquo;), они
автоматически подставляются в нужные места программы при ее формировании в момент компиляции.
Разработчику модели достаточно для каждого поля ввода указать названия на всех необходимых языках.
Если в модели выводятся какие-либо окна с сообщениями пользователю, тексты этих сообщений нужно сделать
текстовыми константами, для которых тоже можно задавать разные значения для разных языков. Таким
образом, изменения в автокомпилируемых моделях сводятся к минимуму (подробнее см. в п.
<a href="#light_p5">5</a>).</p>

<p>В целом процедура перевода интерфейса пользователя будет похожа на процедуру перевода схемы:
создается новый язык, экспортируются файлы с текстами, тексты в файлах переводятся на этот новый язык,
после чего файлы загружаются обратно. Но есть и принципиальные отличия.</p>

<ol>
  <li><b>При переводе схем</b> в каждой схеме может быть свой набор равноправных языков,
  которые пользователь сам добавляет и удаляет по желанию. <b>При переводе интерфейса</b> языки создаются и
  выбираются централизованно для всей программы (RDS), причем один из них (русский) всегда существует как
  &laquo;язык по умолчанию&raquo;, и его тексты не могут быть изменены.</li>
  <li><b>При переводе схем</b> файл перевода должен постоянно храниться вместе со схемой,
  тексты на разных языках загружаются из него в схему по команде пользователя. Если в схему
  добавлены новые блоки с новыми надписями, содержимое схемы синхронизируется (снова по команде
  пользователя) с файлом перевода, где появляются новые тексты, которые нужно перевести.
  <b>При переводе интерфейса</b> экспортированный файл с текстами нужен только до момента его
  импорта (обратной загрузки) после перевода. Переведенные тексты встраиваются в служебные файлы
  RDS или в файлы автокомпилируемых моделей, после чего экспортированный файл можно стирать.</li>
  <li><b>При переводе схем</b> файл перевода содержит данные всех языков схемы в отдельных столбцах
  формата CSV. <b>При переводе интерфейса</b> файл содержит тексты только для одного языка &ndash; того,
  для которого он был экспортирован.</li>
  <li><b>При переводе схем</b> файл перевода всегда выгружается в формате CSV (возможно, с
  дополнительным служебным файлом). <b>При переводе интерфейса</b> можно выбрать между
  форматом <a href="#light_p4_3">CSV</a> и форматом,
  <a href="#light_p4_2">аналогичным INI-файлам</a> Windows (этот формат удобнее и
  понятнее для программиста).</li>
  <li><b>При переводе схем</b> служебная информация в файле перевода закодирована и никак
  не связана с назначением переводимого текста &ndash; например, &laquo;0101qj4q2w&raquo;.
  <b>При переводе интерфейса</b> по формату служебной информации можно, в принципе, понять,
  к чему относится данный текст &ndash; например, &laquo;General._HelpButton.Caption&raquo;
  (надпись на кнопке вызова справки).</li>
</ol>

<p class="noindent">Ниже рассмотрен общий принцип работы, устройство служебных файлов и порядок
работы с функциями перевода интерфейса пользователя. В данном тексте
п.п. <a href="#light_p1">1</a>&ndash;<a href="#light_p6">6</a> предназначены для пользователей и переводчиков,
п. <a href="#light_p7">7</a> &ndash; для программистов, создающих модели блоков.</p>

<p><span class="emph">Следует учитывать</span>, что некоторые элементы интерфейса стандартных диалогов
и окон сообщений создаются операционной системой, и на них невозможно повлиять. Например,
заголовки различных полей в окне выбора шрифта или окне открытия файла всегда будут написаны на
текущем языке Windows.</p>

<p>Этот текст также доступен <a href="pdf/RDS_UI_Translate.pdf">в формате PDF</a>
  (900.18 кб).</p>

<div class="toc">
<div class="level">
  <p>Содержание:</p>
  <div class="level">
    <p><a href="#light_p1">1. Принцип действия и хранение данных для разных языков</a></p>
    <p><a href="#light_p2">2. Формат файлов описания интерфейса пользователя</a></p>
    <p><a href="#light_p3">3. Создание нового языка</a></p>
    <p><a href="#light_p4">4. Экспорт и импорт файла перевода программы и стандартных моделей</a></p>
    <div class="level">
      <p><a href="#light_p4_1">4.1. Экспорт файла перевода</a></p>
      <p><a href="#light_p4_2">4.2. Формат INI-файла перевода</a></p>
      <p><a href="#light_p4_3">4.3. Формат CSV-файла перевода</a></p>
      <p><a href="#light_p4_4">4.4. Импорт файла перевода</a></p>
    </div>
    <p><a href="#light_p5">5. Особенности перевода автокомпилируемых моделей</a></p>
    <div class="level">
      <p><a href="#light_p5_1">5.1. Перевод текстов окна настройки блока в редакторе модели</a></p>
      <p><a href="#light_p5_2">5.2. Перевод прочих текстовых сообщений</a></p>
      <p><a href="#light_p5_3">5.3. Экспорт/импорт файла перевода для всех автокомпилируемых моделей схемы</a></p>
    </div>
    <p><a href="#light_p6">6. Выбор языка интерфейса пользователя</a></p>
    <p><a href="#light_p7">7. Включение функций загрузки перевода в модели блоков</a> (для программистов)</p>
    <div class="level">
      <p><a href="#light_p7_1">7.1. Константы для стандартных папок</a></p>
      <p><a href="#light_p7_2">7.2. Новые сервисные функции и константы RDS</a></p>
        <div class="level">
          <p><a href="#light_p7_2_1">7.2.1. Получение имени текущего языка</a></p>
          <p><a href="#light_p7_2_2">7.2.2. <span class="cpp">rdsGetUICurrentMod</span> &ndash; параметры текущей модификации интерфейса пользователя</a></p>
          <p><a href="#light_p7_2_3">7.2.3. <span class="cpp">rdsGetUIModsList</span> &ndash; список модификаций интерфейса пользователя</a></p>
          <p><a href="#light_p7_2_4">7.2.4. <span class="cpp">rdsUIMODCreate</span> &ndash; создание объекта для работы с модификациями интерфейса</a></p>
          <p><a href="#light_p7_2_5">7.2.5. <span class="cpp">rdsUIMODLoadGroup</span> &ndash; загрузка группы</a></p>
          <p><a href="#light_p7_2_6">7.2.6. <span class="cpp">rdsUIMODLoadSingleObject</span> &ndash; загрузка одного объекта</a></p>
          <p><a href="#light_p7_2_7">7.2.7. <span class="cpp">rdsUIMODGetParamString</span> &ndash; получение текста значения параметра из считанных данных</a></p>
          <p><a href="#light_p7_2_8">7.2.8. <span class="cpp">rdsUIMODGetParamListString</span> &ndash; получение текста содержимого выпадающего списка из считанных данных</a></p>
          <p><a href="#light_p7_2_9">7.2.9. Команда <span class="cpp">RDS_UIMOD_CLEAR</span> &ndash; очистка загруженных данных</a></p>
          <p><a href="#light_p7_2_10">7.2.10. Команда <span class="cpp">RDS_UIMOD_SETCRLFCORR</span> &ndash; установка способа обработки переводов строк</a></p>
        </div>
      <p><a href="#light_p7_3">7.3. Использование вспомогательного класса для загрузки перевода</a></p>
        <div class="level">
          <p><a href="#light_p7_3_1">7.3.1. Конструкторы класса</a></p>
          <p><a href="#light_p7_3_2">7.3.2. Функция-член <span class="cpp">SetBinaryFile</span> &ndash; установка имени двоичного файла</a></p>
          <p><a href="#light_p7_3_3">7.3.3. Функция-член <span class="cpp">Clear</span> &ndash; очистка объекта</a></p>
          <p><a href="#light_p7_3_4">7.3.4. Функции-члены <span class="cpp">IsLoaded</span> и <span class="cpp">IsNotLoaded</span> &ndash; проверка наличия в объекте загруженных данных</a></p>
          <p><a href="#light_p7_3_5">7.3.5. Функция-член <span class="cpp">SetCRLFCorrection</span> &ndash; установка способа обработки переводов строк</a></p>
          <p><a href="#light_p7_3_6">7.3.6. Функция-член <span class="cpp">LoadGroup</span> &ndash; загрузка всех данных одной группы</a></p>
          <p><a href="#light_p7_3_7">7.3.7. Функция-член <span class="cpp">LoadObject</span> &ndash; загрузка одного объекта</a></p>
          <p><a href="#light_p7_3_8">7.3.8. Функция-член <span class="cpp">SetObject</span> &ndash; установка имени объекта для дальнейшего обращения к нему без имени</a></p>
          <p><a href="#light_p7_3_9">7.3.9. Функция-член <span class="cpp">GetString</span> &ndash; получение текста значения параметра из считанных данных</a></p>
          <p><a href="#light_p7_3_10">7.3.10. Функция-член <span class="cpp">GetListString</span> &ndash; получение текста содержимого выпадающего списка из считанных данных</a></p>
          <p><a href="#light_p7_3_11">7.3.11. Статическая функция <span class="cpp">MessageBox</span> &ndash; вывод сообщения с переведенным текстом</a></p>
        </div>
      <p><a href="#light_p7_4">7.4. Пример модели с переводом интерфейса пользователя</a></p>
        <div class="level">
          <p><a href="#light_p7_4_1">7.4.1. Исходная модель без перевода</a></p>
          <p><a href="#light_p7_4_2">7.4.2. Создание файла описания интерфейса и файла перевода</a></p>
          <p><a href="#light_p7_4_3">7.4.3. Загрузка перевода сервисными функциями RDS</a></p>
          <p><a href="#light_p7_4_4">7.4.4. Загрузка перевода объектом вспомогательного класса</a></p>
        </div>
    </div>
  </div>

</div>
</div>

<h1 id="light_p1">1. Принцип действия и хранение данных для разных языков</h1>

<p>Технически перевод интерфейса пользователя выполнен как часть потенциально более универсального
механизма загрузки модификаций интерфейса. Сейчас этот механизм будет использоваться только
для перевода, в дальнейшем на его основе можно будет также сделать переключение на упрощенный
интерфейс со скрытием части возможностей для пугливых пользователей.</p>

<p><span id="datfile">Устроен</span>
механизм следующим образом. В RDS есть &laquo;интерфейс пользователя по умолчанию&raquo;
&ndash; это текущий интерфейс главной программы и всех DLL с моделями блоков. Без
загрузки модификаций интерфейса все меню, окна и т.п. будут выглядеть так, как они выглядят сейчас.
Все &laquo;управляемые&raquo; объекты интерфейса пользователя и параметры этих объектов записываются
разработчиками (как разработчиком &laquo;rds.exe&raquo;, так и разработчиками DLL стандартных, не
автокомпилируемых, моделей) в специальных текстовых <span id="light_datfile" class="emph">файлах
описания интерфейса
пользователя</span>, формат которых приведен в п. <a href="#light_p2">2</a>. Эти файлы должны
иметь расширение &laquo;.dat&raquo; и размещаться в папке &laquo;Description\&raquo; или
вложенных в нее папках внутри папки установки RDS. Каких-либо строгих требований к именам
этих файлов нет, но на данный момент принята следующая, достаточно простая, схема: файл
описания интерфейса называется так же, как исполняемый файл, к которому он относится,
и располагается в папке, совпадающей по имени с папкой исполняемого файла. Например, исполняемый
файл &laquo;rds.exe&raquo; находится непосредственно в папке установки RDS, поэтому его
файлом описания будет &laquo;Description\rds.dat&raquo;. Библиотека с моделями стандартных блоков
&laquo;Common.dll&raquo; находится в подпапке &laquo;Dll\&raquo; внутри папки RDS, поэтому
ее файлом описания будет &laquo;Description\Dll\Common.dat&raquo;. Размещение файлов
описаний внутри папки &laquo;Description\&raquo; будет определять размещение созданных на их
основе двоичных файлов модификации интерфейса (о них &ndash;
<a href="#binary">ниже</a>), поэтому лучше делать так, чтобы исполняемому файлу было просто
найти свои файлы модификаций. В описанной схеме это соблюдается &ndash; файлы описания, например,
располагаются в папке &laquo;Description\&raquo; точно так же, как сам исполняемый файл
внутри папки RDS.</p>

<p>В главную программу жестко закладываются <span class="emph">типы модификаций интерфейса</span>,
причем каждому типу будет соответствовать конкретное, тоже жестко заданное, имя подпапки внутри
папки &laquo;Interface\&raquo; в папке установки и в папке настроек RDS (на данный
момент эти две папки всегда совпадают), в которой хранятся данные разных модификаций
этого типа. Сейчас есть единственный тип модификации &ndash; &laquo;язык&raquo;, и ему
соответствует папка &laquo;Language&raquo;. Таким образом, все данные интерфейса пользователя для
разных языков будут находиться в папке &laquo;Interface\Language\&raquo;.</p>

<p>Внутри папки типа модификации (для языка &minus; внутри &laquo;Interface\Language\&raquo;)
находятся папки конкретных модификаций для данного типа. Каждой модификации (языку)
соответствует одна папка, именем модификации считается имя этой папки. Например, если
в RDS будет добавлен язык интерфейса с названием &laquo;English&raquo;, все данные и
тексты для этого языка будут находиться в папке &laquo;Interface\Language\English\&raquo;
внутри папки установки RDS. Имя &laquo;Default&raquo; зарезервировано для папки хранения данных
по умолчанию, никакая модификация интерфейса пользователя (язык) не может так называться.</p>

<p>Поскольку сейчас единственным существующим типом модификации интерфейса является язык, везде
далее по тексту вместо словосочетания &laquo;модификация интерфейса пользователя&raquo; будет
употребляться слово &laquo;язык&raquo;, но нужно иметь в виду, что все
написанное будет относиться и к другим типам модификаций, если они со временем появятся.</p>

<p><span id="binary">В</a> папке языка должны располагаться
<span id="light_binary">двоичные файлы</span> с текстами, соответствующими файлам
описания интерфейса из папки &laquo;Description\&raquo;, упомянутой выше. Эти файлы
можно создавать средствами RDS при помощи
<a href="#light_p4">экспорта/импорта</a> текстовых файлов специального формата.
Каждому файлу описания интерфейса с расширением &laquo;.dat&raquo; из папки
&laquo;Description\&raquo; будет соответствовать один двоичный файл перевода с
расширением &laquo;.bin&raquo; в подпапке каждого языка. Двоичными эти файлы
сделаны для повышения скорости поиска данных в них: хотя загрузка переводов объектов одного
окна и занимает очень небольшое время как в текстовом, так и в двоичном формате, поиск
данных в гигантском текстовом файле (только в &laquo;rds.exe&raquo; на данный момент
около ста окон, в каждом из которых не меньше десятка текстов, требующих перевода) последовательным
чтением может занимать существенное время. В формате двоичных файлов предусмотрено содержание,
располагающееся в начале файла, поэтому поиск данных нужного окна будет выполняться быстрее
(загрузка содержания &ndash; поиск в нем имени окна &ndash; быстрый переход в нужную позицию файла
для загрузки данных).</p>

<p><span id="paramsini">В</span> папке языка должен также находиться настроечный файл с названием
&laquo;<span id="light_paramsini">params.ini</span>&raquo;,
в котором описываются действия, выполняемые RDS при переключении языка пользователем. Обычно
при таком переключении мало начать загружать файлы с текстами на другом языке при работе программы,
нужно еще поменять и некоторые настройки и служебные файлы. Например, при переключении на
английский язык нужно автоматически перенастроить RDS на другую панель блоков с английскими
названиями вкладок-папок и, возможно, другими иконками блоков (сейчас на некоторых
иконках нарисованы русские буквы). Кроме того, при наличии английской документации (сейчас
ее нет) нужно переключить RDS на другие файлы справки, и т.д. Предполагается, что документация,
отдельная панель блоков и т.п. для языка также будут находиться в папке этого языка.
Если новый язык <a href="#light_p3">создается средствами RDS</a>,
&laquo;params.ini&raquo; записывается автоматически по установленным пользователем флажкам, и,
при согласии пользователя, в папку языка копируются дополнительные файлы (список модулей
автокомпиляции, расширений и т.д.), которые нужно будет переводить.</p>

<p>При переключении пользователем с текущего языка A на язык B выполняются следующие действия:</p>

<ul>
  <li>во внутренних настройках RDS запоминается необходимость загружать файлы с текстами из папки
  &laquo;Interface\Language\B\&raquo; начиная со следующего запуска;</li>
  <li>все настройки RDS, как-то связанные с языком (например, в какой папке находится панель блоков
  текущего языка) запоминаются в &laquo;Interface\Language\A\params.ini&raquo;, чтобы все
  изменения, сделанные настройках для текущего языка A, не были потеряны;</li>
  <li>эти же настройки RDS копируются из &laquo;Interface\Language\B\params.ini&raquo;
  (т.е. из файла параметров нового языка) и становятся текущими настройками RDS.</li>
</ul>

<p class="noindent">На этом переключение языков завершается: настройки RDS приведены в соответствие с
новым языком, и при следующем запуске тексты объектов интерфейса начнут загружаться из
файлов в папке нового языка.</p>

<p>Для примера рассмотрим структуру папок RDS, образующуюся при добавлении языка с названием
&laquo;English&raquo;. В этом примере будем считать, что папка установки RDS совпадает с
папкой настроек (на данный момент RDS устанавливается именно в такой конфигурации), и из всех
библиотек с моделями блоков будем рассматривать только &laquo;Common.dll&raquo;, чтобы не
перегружать пример. Все пути будут указаны относительно папки установки RDS.</p>

<p>Структура папок с файлами будет следующей
(<span class="selblue">голубым</span>
выделены данные языка &laquo;English&raquo;,
<span class="selgreen">зеленым</span>
&ndash; общие для всех языков описания интерфейса):</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Папка или файл относительно папки установки RDS</th>
    <th>Назначение</th>
  </tr>
  <tr>
    <td>rds.exe</td>
    <td>Главная программа</td>
  </tr>
  <tr>
    <td>Dll\Common.dll</td>
    <td>Стандартные модели блоков</td>
  </tr>
  <tr>
    <td class="selgreen">Description\</td>
    <td>Папка с описаниями интерфейса пользователя главной программы и стандартных DLL</td>
  </tr>
  <tr>
    <td class="selgreen">Description\rds.dat</td>
    <td>Описание интерфейса пользователя главной программы</td>
  </tr>
  <tr>
    <td class="selgreen">Description\Dll\Common.dat</td>
    <td>Описание интерфейса пользователя стандартных моделей блоков</td>
  </tr>
  <tr>
    <td>Interface\Language\Default\</td>
    <td>Папка резервного копирования параметров &laquo;интерфейса по умолчанию&raquo; (русского)</td>
  </tr>
  <tr>
    <td class="selblue">Interface\Language\English\</td>
    <td>Папка с данными английского языка</td>
  </tr>
  <tr>
    <td class="selblue">Interface\Language\English\params.ini</td>
    <td>Настройки параметров переключения на английский язык</td>
  </tr>
  <tr>
    <td class="selblue">Interface\Language\English\rds.bin</td>
    <td>Перевод главной программы на английский язык</td>
  </tr>
  <tr>
    <td class="selblue">Interface\Language\English\Dll\Common.bin</td>
    <td>Перевод стандартных моделей блоков на английский язык</td>
  </tr>
  <tr>
    <td class="selblue">Interface\Language\English\Panel\</td>
    <td>Папка английской панели блоков</td>
  </tr>
  <tr>
    <td class="selblue">Interface\Language\English\Template\</td>
    <td>Папка с английскими шаблонами схем и автокомпилируемых моделей</td>
  </tr>
  <tr>
    <td class="selblue">Interface\Language\English\*.dat,<br />Interface\Language\English\*.lst</td>
    <td>Версии служебных файлов RDS для английского языка</td>
  </tr>
</table>
</div></div>

<p>На данный момент в RDS не предусмотрено (и, видимо, не будет) никаких средств перевода
панели блоков и шаблонов &ndash; это нужно выполнять вручную. Перевод названий модулей автокомпиляции,
расширений и т.п. тоже должен выполняться вручную, но для этого достаточно после переключения на
нужный язык просто отредактировать эти названия стандартными средствами RDS.</p>

<p>Автокомпилируемые модели не используют двоичные файлы перевода из папки языка,
поскольку модели пользователя обычно размещаются в одной папке со схемой, и хранить для них
данные централизованно не имеет смысла. Вместо этого тексты на разных языках хранятся в
самом файле модели с расширением &laquo;.mdl&raquo;. Эти тексты могут быть экспортированы,
переведены и импортированы обратно для загруженной схемы централизованно, через окно настроек
RDS (см. п. <a href="#light_p5_3">5.3</a>). Разработчик модели может и сам, не дожидаясь перевода,
указать для объектов тексты на разных языках. Следует помнить, что набор языков и их
названия все равно задаются в RDS централизованно &ndash; нельзя добавить текст для языка,
который не был создан заранее.</p>

<h1 id="light_p2">2. Формат файлов описания интерфейса пользователя</h1>

<p>Файлы описания интерфейса пользователя главной программы (&laquo;rds.exe&raquo;) и стандартных
моделей блоков (библиотек в папке &laquo;Dll\&raquo;) хранятся в папке
&laquo;Description\&raquo; внутри папки установки RDS. Эти файлы создаются разработчиками
соответствующих программ и должны поддерживаться ими в актуальном состоянии при изменении
этих программ &ndash; например, при добавлении новых окон, сообщений или пунктов меню. Работают с
этими файлами только разработчики программ, обычным пользователям внутренняя структура этих файлов
не важна, даже если эти пользователи сами переводят интерфейс на новый язык. Пользователь-переводчик
может, при желании, посмотреть комментарии в файле описания, если их предусмотрел разработчик.</p>

<p>Каждый текст интерфейса пользователя адресуется в файле описания тремя именами:
<span class="emph">именем группы</span>,
<span class="emph">именем объекта</span> и
<span class="emph">именем параметра</span>. Эти имена не должны содержать знака доллара, знака
равенства, точки, запятой, двоеточия, точки с запятой и квадратных скобок, в остальном они
выбираются разработчиком программы произвольно. В качестве имени группы обычно используется имя окна
или крупного раздела интерфейса пользователя &ndash; двоичные файлы перевода, формируемые на основе
файла описания, устроены так, что данные одной группы можно достаточно быстро найти по содержанию
файла. Имя объекта обычно описывает конкретный объект интерфейса (кнопку, пункт меню и т.п.), а
имя параметра &ndash; конкретный параметр этого объекта (текст, всплывающую подсказку, список
вариантов для выбора и т.п.). Все имена групп и параметров вместе с идентификаторами этих
параметров придумываются разработчиком. При этом желательно давать им более-менее осмысленные
имена, чтобы переводчик мог догадаться, к чему относится тот или иной текст.</p>

<p>Для всех имен параметров в начале файла должны быть указаны типы (на данный момент поддерживаются
только &laquo;строка&raquo; и &laquo;целое число&raquo;) и целые идентификаторы, по которым
к ним будет обращаться программа для загрузки текстов. Кроме того, в файле указывается, какие
имена параметров для какого типа модификации интерфейса используются. На данный момент это не
актуально, поскольку сейчас есть только один тип модификации &ndash; &laquo;язык&raquo;. Но позже,
когда появятся другие типы, можно будет указывать, что, например, для модификации
&laquo;видимость пунктов меню и полей ввода&raquo; текстовые названия этих пунктов и полей
не требуются, и их можно не включать в формируемый двоичный файл.</p>

<p>В целом, файл описания интерфейса имеет формат обычного INI-файла Windows. Начинается он
всегда со служебной секции &laquo;$Types&raquo; (в файле имена секций всегда заключаются в
квадратные скобки), в которой указываются типы модификаций интерфейса (на данный момент &ndash;
только &laquo;Language&raquo;) и список имен параметров, которые в этой модификации используются.
В строках секции имя модификации стоит слева от знака равенства, список имен параметров через запятую
&ndash; справа. Например, файл &laquo;rds.dat&raquo; начинается следующим образом:</p>

<pre class="cpp">[$Types]
Language=Caption,Text,Hint,Filter,Title,String,List</pre>

<p>Эта запись означает, что для языков (тип модификации интерфейса &laquo;Language&raquo;)
используются параметры &laquo;Caption&raquo;, &laquo;Text&raquo;,
&laquo;Hint&raquo;, &laquo;Filter&raquo;, &laquo;Title&raquo;,
&laquo;String&raquo; и &laquo;List&raquo;.</p>

<p>За секцией &laquo;$Types&raquo; должна следовать секция &laquo;$Params&raquo;, в которой
указываются типы и целые идентификаторы всех использованных в файле имен параметров. В строках
секции слева от знака равенства ставится имя параметра, справа &ndash; символ
&laquo;S&raquo; (строка) или &laquo;I&raquo; (целое число) и, после запятой,
целый идентификатор. В &laquo;rds.dat&raquo; эта секция выглядит так:</p>

<pre class="cpp">[$Params]
Caption=S,1
Text=S,2
Hint=S,3
Filter=S,4
Title=S,5
String=S,6
List=S,7</pre>

<p>Эта запись означает, что все параметры имеют тип &laquo;строка&raquo; (символ
&laquo;S&raquo;), параметр &laquo;Caption&raquo; имеет идентификатор 1, параметр
&laquo;Text&raquo; &ndash; идентификатор 2 и т.д.</p>

<p>Далее следует произвольное количество секций следующего формата:</p>

<pre class="cpp">[<i>имя_группы</i>]
<i>имя_объекта1</i>.<i>параметр1</i>=<i>значение</i>
<i>имя_объекта1</i>.<i>параметр2</i>=<i>значение</i>
&hellip;
<i>имя_объекта2</i>.<i>параметр1</i>=<i>значение</i>
&hellip;</pre>

<p>Каждая секция соответствует одной группе объектов (например, окну), имя группы является именем
секции. Далее в строках секции перечисляются все объекты с их параметрами (имя параметра отделено
от имени объекта точкой), и, после знака равенства, значение данного параметра данного объекта по
умолчанию. Это значение будет попадать в
<a href="#light_p4_1">экспортируемый файл перевода</a>, если для него еще нет перевода в
двоичном файле.</p>

<p><span id="rdsdatex">В</span> &laquo;rds.dat&raquo;
<span id="light_rdsdatex">начало секции описания
интерфейса пользователя главного окна RDS</span>
выглядит так:</p>

<pre class="cpp">[TMainForm]
M_File1.Caption=Файл
M_NewSystem.Caption=Новый
M_Templates.Caption=По шаблону
M_LoadSystem.Caption=Загрузить...
M_LoadInCopy.Caption=Загрузить, не закрывая...
M_SaveSystem.Caption=Сохранить
&hellip;</pre>

<p>Здесь &laquo;TMainForm&raquo; &ndash; имя группы, использующееся для описания главного окна.
Строка &laquo;M_File1.Caption=Файл&raquo; означает, что параметр &laquo;Caption&raquo; (заголовок)
объекта &laquo;M_File1&raquo; (в данном случае это пункт главного меню &laquo;Файл&raquo;) имеет
значение по умолчанию &laquo;Файл&raquo;.</p>

<p>В любом месте файла может находиться строка комментария, начинающаяся с символа &laquo;;&raquo;
(точка с запятой). При разборе файла описания интерфейса такие строки игнорируются, разработчик
может использовать их для того, чтобы оставить в файле какие-то пояснения для переводчика.</p>

<p>Следует учитывать, что для многострочных текстов коды перевода строк заменяются на принятые в
языке программирования C сочетания &laquo;\n&raquo; или &laquo;\r\n&raquo; (какое именно
из этих двух сочетаний использовать решает разработчик, составляющий файл описания). Многострочные
тексты чаще всего встречаются в сообщениях пользователю и в описании выпадающих списков. Если
с текстами сообщений пользователю все очевидно, то описания выпадающих списков имеют специальный
формат и их нужно рассмотреть отдельно.</p>

<p>Рассмотрим
<span id="light_combolist">выпадающий список выравнивания</span> в параметрах
строки текста для картинки блока,
описанных в &sect;2.10.5 описания пользователя.</p>

<div class="pic"><div class="container" id="pic1">
<img src="img/UITranslate_pic1.png" width="387" height="84" alt="Выпадающий список" />
<p id="light_pic1">Выпадающий список с тремя вариантами</p>
</div></div>

<p>Список содержит три варианта: &laquo;Влево&raquo;, &laquo;По центру&raquo; и &laquo;Вправо&raquo;.
Соответствующая этому списку запись в файле описания интерфейса пользователя будет выглядеть следующим
образом:</p>

<pre class="cpp">CB_Alignment.List=0=Влево\n1=По центру\n2=Вправо</pre>

<p>Здесь &laquo;CB_Alignment&raquo; &ndash; имя объекта, &laquo;List&raquo; &ndash; имя параметра,
а многострочный текст после самого левого знака равенства описывает три варианта списка.</p>

<p>Текст &laquo;0=Влево\n1=По центру\n2=Вправо&raquo; состоит из трех строк:
&laquo;0=Влево&raquo;, &laquo;1=По центру&raquo; и &laquo;2=Вправо&raquo; (в качестве
разделителя строк в общем тексте используется &laquo;\n&raquo;). Каждая строка имеет формат
&laquo;<i>индекс</i>=<i>значение</i>&raquo;, где <i>индекс</i> &ndash; начинающийся с нуля номер
варианта в списке, а <i>значение</i> &ndash; текст этого варианта, видимый пользователю. При
переводе этого текста формат строк должен быть сохранен: в качестве переведенного содержимого
выпадающего списка в импортируемом файле перевода должен быть записан текст из трех строк формата
&laquo;<i>индекс</i>=<i>значение</i>&raquo;, описывающий варианты с индексами 0, 1 и 2 в
любом порядке. RDS поддерживает два формата файлов экспорта/импорта перевода
(см. п. <a href="#light_p4_2">4.2</a> и <a href="#light_p4_3">4.3</a>), но, независимо от формата файла, сам
текст выпадающего списка должен содержать эти три строки с указанием индексов элементов списка.
Любые индексы, отличные от заложенных разработчиком в программу, будут игнорироваться: например,
если в переведенном тексте будет содержаться строка &laquo;3=Other&raquo;, в списке не
появится дополнительный четвертый пункт.</p>

<p><span id="linebreak">Если</a> в файле описания необходимо привести
очень длинный текст, его для удобства можно <span id="light_linebreak">разбить на
несколько записей</span>. Начало текста, как обычно, записывается после знака равенства в строку
&laquo;имя_объекта.параметр=&hellip;&raquo;, после которой добавляется новая строка
&laquo;имя_объекта.параметр.1=&hellip;&raquo; с продолжением текста, затем
&laquo;имя_объекта.параметр.2=&hellip;&raquo; и т.д пока текст не закончится. В
описаниях-продолжениях номера после имени параметра должны идти строго последовательно, их
перестановка или вставка между ними других записей не допускается.</p>

<p>Пусть, например, необходимо описать в файле сообщение пользователю со следующим текстом:</p>

<p class="narrow">&laquo;Для данного блока была создана картинка. Задание прямоугольника с текстом в качестве внешнего вида блока приведет к удалению этой картинки. Задать прямоугольник с текстом?&raquo;</p>

<p>Это текст настоящего сообщения RDS, выводимого пользователю при переключении внешнего вида
блока в окне его параметров. В файле описания &laquo;rds.dat&raquo; оно записано как параметр
&laquo;Text&raquo; объекта &laquo;PictureToTextBox&raquo; в секции
&laquo;Messages&raquo;. Если записать весь этот текст в одну строку, она будет очень длинной, и
с ней неудобно будет работать. Поэтому в &laquo;rds.dat&raquo; описание этого сообщения можно
записать следующим образом:</p>

<pre class="cpp">PictureToTextBox.Text=Для данного блока была создана картинка.\x20
PictureToTextBox.Text.1=Задание прямоугольника с текстом в качестве\x20
PictureToTextBox.Text.2=внешнего вида блока приведет к удалению этой\x20
PictureToTextBox.Text.3=картинки. Задать прямоугольник с текстом?</pre>

<p>Здесь длинный текст разбит на четыре отдельных описания: начальное и три продолжения с
дополнительными номерами &laquo;.1&raquo;, &laquo;.2&raquo; и &laquo;.3&raquo;. Следует
учитывать, что начальные и конечные пробелы в каждой строке выбрасываются, поэтому, чтобы сохранить
пробел в месте разбиения текста на отдельные строки, к концу каждой из строк добавлен код пробела
&laquo;\x20&raquo;. Если разбивать текст не по пробелу, то никаких кодов добавлять не нужно.
Например, это же описание с тем же самым текстом сообщения может выглядеть следующим образом:</p>

<pre class="cpp">PictureToTextBox.Text=Для данного блока была создана картинка
PictureToTextBox.Text.1=. Задание прямоугольника с текстом в качестве в
PictureToTextBox.Text.2=нешнего вида блока приведет к удалению эт
PictureToTextBox.Text.3=ой картинки. Задать прямоугольник с текстом?</pre>

<p>Однако, такое описание труднее читать человеку.</p>



<h1 id="light_p3">3. Создание нового языка</h1>

<p>Для создания нового языка и всех связанных с ним папок и служебных файлов (см.
п. <a href="#light_p1">1</a>) необходимо запустить RDS, открыть окно настроек пунктом главного меню
&laquo;Сервис | Настройки RDS&raquo; и выбрать в окне вкладку
&laquo;Инструменты интерфейса&raquo;.</p>

<div class="pic"><div class="container" id="pic2">
<img src="img/UITranslate_pic2.png" width="578" height="422" alt="Создание нового языка" />
<p id="light_pic2">Панель создания нового языка в окне настроек RDS</p>
</div></div>

<p>Эта вкладка предназначена для работы с любыми модификациями интерфейса пользователя. Пока
существует только один тип таких модификаций &ndash; &laquo;язык&raquo;, поэтому выпадающий список
выбора типа в верхней части вкладки заблокирован, и все действия на ней будут выполняться только
с языками интерфейса пользователя.</p>

<p>В нижней части вкладки находится панель &laquo;создать новое описание интерфейса пользователя&raquo;,
именно там можно добавить в RDS новый язык. В поле ввода &laquo;Имя модификации&raquo; следует
ввести имя создаваемого языка. Это имя будет использоваться и в
<a href="#light_p6">окне переключения языков</a>, и в качестве имени папки для хранения
данных языка, поэтому имя должно удовлетворять правилам для имен файлов и папок Windows. Имя
&laquo;Default&raquo; использовать нельзя, оно зарезервировано для папки хранения данных
интерфейса по умолчанию (в данном случае &ndash; русского языка).</p>

<p>Ниже располагается набор флажков, указывающий, какие данные помимо собственно текстов интерфейса
пользователя будут храниться независимо для создаваемого языка (эти флажки будут записаны в
<a href="#paramsini">файл &laquo;params.ini&raquo;</a> в папке языка).
Флажки управляют следующими данными:</p>

<p>&laquo;Своя панель и библиотека блоков&raquo; &ndash; включение этого флажка указывает на
то, что для данного языка будут созданы собственные папки панели и библиотеки блоков (библиотека
блоков в настоящее время не используется). Поскольку текущая панель блоков настроена на русский язык,
следует включить этот флажок. При создании языка будет предложено скопировать текущую панель блоков
внутрь папки данных языка &ndash; можно либо согласиться, а затем перевести скопированные блоки
вручную, либо отказаться и самостоятельно сформировать другую панель блоков на новом языке.</p>

<p>&laquo;Своя папка шаблонов&raquo; &ndash; включение этого флажка указывает на то, что
для данного языка будет использоваться собственная папка с шаблонами схем и автокомпилируемых
моделей. В шаблонах могут присутствовать какие-то тексты, поэтому для нового языка лучше иметь
свои шаблоны. При создании языка будет предложено скопировать в новую папку шаблонов содержимое
текущей папки для дальнейшего перевода.</p>

<p>&laquo;Своя папка документации&raquo; &ndash; включение этого флажка добавит в
переключаемые при смене языка данные путь к папке с файлами справки по RDS и по стандартным блокам.
Очевидно, что для интерфейса на другом языке требуется и документация на этом языке, однако,
пока такая документация отсутствует. Тем не менее, флажок лучше включить, чтобы при переключении
языка не выводилась справка на русском.</p>

<p>&laquo;Свои структуры&raquo; &ndash; добавляет в данные языка файл &laquo;types.dat&raquo;,
содержащий описания структур по умолчанию (см. &sect;2.14 описания пользователя). В большинстве
случаев этого не требуется, поскольку структуры по умолчанию сейчас нигде не используются, и
в описаниях этих структур нет комментариев к полям, т.е. переводить там нечего.</p>

<p>&laquo;Свои стили связей и шин&raquo; &ndash; добавляет в данные языка файл
&laquo;styles.dat&raquo;, содержащий описания стилей связей и шин по умолчанию
(см. &sect;2.13 описания пользователя). У этих стилей сейчас русские названия, поэтому флажок
лучше включить.</p>

<p>&laquo;Свой список модулей расширения&raquo; &ndash; добавляет в данные языка список модулей
расширения (см. &sect;2.19.3 описания пользователя), присутствующих в главном меню RDS как
дополнительные пункты подменю &laquo;Сервис&raquo;. Названия этих дополнительных пунктов,
очевидно, нужно переводить, поэтому флажок должен быть включен.</p>

<p>&laquo;Свой список автокомпиляции&raquo; &ndash; добавляет в данные языка список
модулей автоматической компиляции моделей (см. &sect;2.19.1 описания пользователя). Самим модулям
язык безразличен, поскольку их интерфейс пользователя будет переведен при переводе всех
объектов в библиотеке &laquo;Common.dll&raquo;, но названия модулей, видимые пользователю,
могут содержать русские слова, поэтому этот список тоже нужно перевести.</p>

<p>&laquo;Свой список модулей BMP&raquo; &ndash; добавляет в данные языка список модулей
преобразования растровых рисунков в другие форматы (см. &sect;2.19.2 описания пользователя).
Сейчас существует единственный такой модуль &ndash; модуль преобразования в формат PNG,
в описании которого есть только название формата &laquo;Portable Network Graphics&raquo;, которое
переводить не требуется. Но, для единообразия, этот флажок тоже лучше включить.</p>

<p>После того, как имя нового языка введено и все необходимые флажки установлены, следует нажать кнопку
&laquo;Создать&raquo;. В процессе создания нового языка может быть задано несколько вопросов о
копировании стандартных папок, упомянутых выше, после чего новый язык будет создан и для него можно будет
экспортировать и импортировать
<a href="#light_p4">файлы перевода</a>, а также
<a href="#light_p5">вводить для него тексты</a> в редакторе автокомпилируемой модели.</p>



<h1 id="light_p4">4. Экспорт и импорт файла перевода программы и стандартных моделей</h1>

<p>Экспорт и импорт файла для перевода элементов интерфейса пользователя на другой язык выполняется на
той же самой вкладке &laquo;Инструменты интерфейса&raquo; окна настройки RDS, на которой
создаются новые языки. Для этого на ней есть панель
&laquo;Экспорт/импорт файла описания&raquo;.</p>

<div class="pic"><div class="container" id="pic3">
<img src="img/UITranslate_pic3.png" width="578" height="422" alt="Работа с файлом перевода" />
<p id="light_pic3">Панель экспорта/импорта языка в окне настроек RDS</p>
</div></div>

<p>Экспорт и импорт файлов описания интерфейса (т.е., в данном случае, файлов перевода), делается
для одного
<a href="#datfile">файла описания</a> из папки &laquo;Description" html_quote} за один раз.
Здесь мы рассматриваем перевод &raquo; и стандартных моделей блоков (библиотек
&laquo;Common.dll&raquo;, &laquo;L57.dll&raquo; и др.) Особенности перевода автокомпилируемых
моделей рассмотрены в п. <a href="#light_p5">5</a>.</p>

<p>Перевод выполняется в следующей последовательности:</p>

<ul>
  <li>сначала выбирается DAT-файл описания интерфейса пользователя какой-либо программы или библиотеки,
  и для него экспортируется текстовый файл перевода на выбранный язык в одном из двух выбранных форматов;</li>

  <li>в текстовом файле перевода русские тексты заменяются на тексты на нужном языке;</li>

  <li>измененный файл перевода импортируется обратно <span class="emph">для того же самого</span>
  DAT-файла, для которого он был экспортирован ранее.</li>
</ul>

<p class="noindent">Рассмотрим эти действия подробнее.</p>



<h2 id="light_p4_1">4.1. Экспорт файла перевода</h2>

<p>Для экспорта файла перевода нужно выбрать в выпадающем списке
&laquo;Данные&raquo; (см. <a href="#pic3">рисунок</a>) вариант &laquo;файл описания&raquo;, а
справа от него, в другом выпадающем списке, имя файла описания интерфейса, который будет переводиться.
В конце концов придется перевести все файлы, но лучше работать с ними по одному.</p>

<p>В выпадающем списке &laquo;Модификация&raquo; следует выбрать язык, на который будет
переводиться интерфейс пользователя. Этот язык должен быть
<a href="#light_p3">создан</a> заранее.</p>

<p>Далее можно выбрать: экспортировать в файл перевода все тексты из выбранного файла описания
интерфейса, или только те, которых еще нет в соответствующем двоичном файле внутри папки выбранного
языка. Для этого служит флажок &laquo;Только новые описания&raquo;. Если новый язык только что
создан, очевидно, никаких переводов на него еще нет, и установка флажка ни на что не влияет. Однако,
если перевод уже был выполнен ранее, но разработчик программы или модели добавил в ее интерфейс
пользователя новые объекты, для которых перевода еще нет, разумно будет установить флажок, чтобы
уже переведенные тексты не попали в экспортируемый файл. Кроме того, можно установить флажок
&laquo;Объединять одинаковые&raquo;, чтобы одинаковые тексты (например, название кнопки
&laquo;Шрифт&hellip;&raquo;, встречающееся в большом числе самых разных окон RDS)
не записывались в экспортируемый файл по нескольку раз.</p>

<p>Затем следует нажать кнопку &laquo;Экспорт&raquo; и выбрать имя для сохраняемого файла,
а также один из двух возможных его форматов:
&laquo;<a href="#light_p4_2">файл INI</a>&raquo; или
&laquo;<a href="#light_p4_3">файл CSV</a>&raquo;.
Форматы взаимозаменяемы, переводчик может выбрать удобный ему. Единственное ограничение:
как и все текстовый файлы в RDS, файлы переводов должны иметь кодировку CP1251, что, на самом деле,
ограничивает доступные языки только английским. Но не думаю, что
нам когда-нибудь понадобятся другие.</p>

<p>Технически экспорт файла перевода производится следующим образом: в память загружается выбранный
файл описания интерфейса (с расширением &laquo;dat&raquo;), и из него выбрасываются все параметры,
имена которых не перечислены через запятую в правой части строки
&laquo;Language=&hellip;&raquo; секции &laquo;$Types&raquo;
(см. п. <a href="#light_p2">2</a>). В результате в памяти остаются только параметры, имеющие
отношение к переключению языка. Затем для выбранного языка из хранящегося в RDS двоичного файла с
переводами (с расширением &laquo;bin&raquo;) с тем же именем, что и у файла описания, загружаются
значения параметров, т.е. уже сделанные переводы. Разумеется, если двоичного файла еще нет,
ничего не загружается. Таким образом, значения по умолчанию, загруженные из DAT-файла, заменяются на
переводы, если они есть. После этого в текстовый файл перевода записываются либо все параметры с
их значениями, либо, если установлен флажок &laquo;Только новые описания&raquo;, те параметры,
которые отсутствовали в двоичном файле перевода.</p>

<p>Весь этот процесс скрыт от пользователя, но ему лучше представлять себе, как формируется файл,
с которым ему работать. Пользователь просто выбирает DAT-файл описания и нужный язык, нажимает
кнопку &laquo;Экспорт&raquo;, указывает имя и тип файла для сохранения, и получает текстовый файл,
в который ему нужно внести переводы.</p>


<h2 id="light_p4_2">4.2. Формат INI-файла перевода</h2>

<p>INI-файл перевода по своей структуре очень похож на
<a href="#datfile">DAT-файл описания интерфейса пользователя</a>. У них, фактически, одинаковый
формат, только в файле перевода нет секций &laquo;$Types&raquo; и
&laquo;$Params&raquo; &ndash; вместо них он начинается с секции
&laquo;$Descr&raquo;, которой не бывает в DAT-файлах.</p>

<p>Секция &laquo;$Descr&raquo;, с которой начинается файл перевода, содержит всего два
параметра: тип модификации интерфейса (&laquo;Type=&raquo;) и имя той модификации, для которой
файл создан (&laquo;Mod=&raquo;).
Кроме того, если файл перевода экспортируется для DAT-файла описания интерфейса, а не для
<a href="#light_p5_3">автокомпилируемых моделей</a>, то в этой секции также будет содержаться
имя исходного DAT-файла (&laquo;Dat=&raquo;), в котором обратная косая черта
&laquo;\&raquo; удвоена. Сохраненное имя DAT-файла
используется при импорте файла перевода только для того, чтобы предупредить пользователя,
если он позже попытается импортировать этот файл для какого-то другого описания.</p>

<p>При экспорте файла &laquo;Dll\Common.dat&raquo; для перевода на язык с именем
&laquo;English&raquo;, например, начальная секция файла будет выглядеть так:</p>

<pre class="cpp">[$Descr]
Type=Language
Mod=English
Dat=Dll\\Common.dat</pre>

<p>Здесь &laquo;Language&raquo; &ndash; жестко зашитый в программу и пока единственный тип
модификации интерфейса пользователя &laquo;язык&raquo;, а
&laquo;Dll\\Common.dat&raquo; &ndash; имя исходного DAT-файла с удвоенной обратной косой чертой.</p>

<p>Далее следуют такие же секции для групп объектов интерфейса, как и в DAT-файле:</p>

<pre class="cpp">[<i>имя_группы</i>]
<i>имя_объекта1</i>.<i>параметр1</i>=<i>значение</i>
<i>имя_объекта1</i>.<i>параметр2</i>=<i>значение</i>
&hellip;
<i>имя_объекта2</i>.<i>параметр1</i>=<i>значение</i>
&hellip;</pre>

<p>Каждая секция соответствует одной группе объектов (например, окну), имя группы является
именем секции. Далее в строках секции перечисляются все объекты с их параметрами (имя параметра
отделено от имени объекта точкой), и, после знака равенства, значение данного параметра данного
объекта. Сразу после экспорта это будет либо значение по умолчанию из DAT-файла, либо, если
перевод уже был сделан, предыдущий текст перевода. Задача пользователя &ndash; ввести после
знаков равенства нужные тексты переводов. Как и в DAT-файлах, для многострочных текстов коды
перевода строк необходимо заменять на принятые в языке программирования C сочетания
&laquo;\n&raquo; или &laquo;\r\n&raquo; (желательно сохранять такую же разбивку на
строки, какая была до перевода).</p>

<p>Для приведенного в п. <a href="#light_p2">2</a>
<a href="#rdsdatex">фрагмента</a> файла описания интерфейса &laquo;rds.dat&raquo;
начало секции описания интерфейса пользователя главного окна RDS после перевода может выглядеть
так (порядок строк в секции может быть другим):</p>

<pre class="cpp">[TMainForm]
M_File1.Caption=File
M_NewSystem.Caption=New
M_Templates.Caption=New by template
M_LoadSystem.Caption=Open...
M_LoadInCopy.Caption=Open separate...
M_SaveSystem.Caption=Save
&hellip;</pre>

<p>Здесь &laquo;TMainForm&raquo; &ndash; имя группы, использующееся для описания главного окна.
Строка &laquo;M_File1.Caption=File&raquo; означает, что параметр &laquo;Caption&raquo; (заголовок)
объекта &laquo;M_File1&raquo; (в данном случае это пункт главного меню &laquo;Файл&raquo;) в
английском варианте интерфейса имеет значение &laquo;File&raquo;.</p>

<p>Содержимое выпадающих списков в этом формате указывается точно так же, как и в DAT-файлах, т.е.
в виде многострочного текста &laquo;0=первый вариант\n1=второй вариант\n&hellip;&raquo;.
Перевод
<a href="#light_combolist">выпадающего списка выравнивания текста</a>
из п. <a href="#light_p2">2</a> будет выглядеть так:</p>

<pre class="cpp">CB_Alignment.List=0=Left\n1=Center\n2=Right</pre>

<p>Поскольку порядок перечисления пунктов списка не важен, можно написать и так:</p>

<pre class="cpp">CB_Alignment.List=1=Center\n2=Right\n0=Left</pre>

<p>Результат будет тем же.</p>

<p>Следует учитывать, что любые индексы, отличные от заложенных в программу разработчиком и указанных
в файле описания интерфейса, будут игнорироваться &ndash; в выпадающем списке всегда будет столько
пунктов, сколько предусмотрено разработчиком, и добавить в список новые пункты через импорт
файла перевода невозможно.</p>

<p>Слишком длинные тексты при экспорте могут быть разбиты на несколько описаний с добавлениями к именам
параметров дополнительных номеров
<a href="#linebreak"> точно так же</a>,
как это описано в п. <a href="#light_p2">2</a>.
В процессе перевода можно убрать это разбиение или разбить по-другому, на результат это не влияет.</p>

<p>Если при экспорте был установлен флажок &laquo;Объединять одинаковые&raquo;
(см. <a href="#pic3">рисунок</a>), то в экспортированном файле могут появиться описания следующего вида:</p>

<pre class="cpp"><i>имя_объекта2</i>.<i>параметр2</i>:=<i>имя_группы1</i>.<i>имя_объекта1</i>.<i>параметр1</i></pre>

<p>Здесь вместо знака равенства используется сочетание двоеточия со знаком равенства. Такая запись
означает, что значение параметра &laquo;параметр2&raquo; объекта &laquo;имя_объекта2&raquo;
из текущей описываемой группы в точности совпадает со значением параметра
&laquo;параметр1&raquo; объекта &laquo;имя_объекта1&raquo; группы
&laquo;имя_групы1&raquo; (при этом этот объект &laquo;имя_объекта1&raquo; со своими параметрами
<span class="emph">обязательно</span> должен быть описан в файле до этой записи, т.е. ссылка возможна
только на значение уже описанного объекта).</p>

<p>Если, например, экспортировать весь файл описания &laquo;rds.dat&raquo; в формате INI-файла
с включенным флажком &laquo;Объединять одинаковые&raquo;, пара записей в группе
&laquo;Messages&raquo; (сообщения пользователю) будет выглядеть следующим образом:</p>

<pre class="cpp">[Messages]
&hellip;
BMPModuleAbout.Text=О модуле
&hellip;
ToolModuleAbout.Text:=Messages.BMPModuleAbout.Text
…</pre>

<p>Здесь указано, что значение параметра &laquo;Text&raquo; объекта
&laquo;ToolModuleAbout&raquo; (в данном случае это заголовок окна &laquo;о модуле&raquo;
для модуля расширения) в точности совпадает со значением параметра &laquo;Text&raquo;
объекта &laquo;BMPModuleAbout&raquo; этой же группы &laquo;Messages&raquo; (заголовок
такого же окна для модуля преобразования BMP). В этом примере оба значения находятся в одной
группе, но это не обязательно. Главное, чтобы ссылка на значение другого параметра располагалась ниже
по тексту файла относительно реального описания этого значения.</p>

<p>Переводчик может либо оставить такую запись без изменения, переведя только текст первого объекта
(параметр второго автоматически получит то же значение), либо заменить
&laquo;<span class="cpp">:=</span>&raquo; на
&laquo;<span class="cpp">=</span>&raquo; и дать второму объекту другой текст перевода.</p>

<p>После редактирования файл перевода должен быть
<a href="#light_p4_4">импортирован обратно</a> для слияния с уже имеющимися переводами.</p>



<h2 id="light_p4_3">4.3. Формат CSV-файла перевода</h2>

<p>CSV-файл перевода похож на файлы <a href="translate.html">переводов схем</a>, но, в отличие от
них, он всегда имеет ровно два столбца: служебный столбец и столбец текста. Пользователь может менять
тексты только во втором столбце. Первая строка файла &ndash; служебная, пользователь не должен
менять тексты в обоих ее столбцах.</p>

<p>Данные в файле перевода записываются следующим образом:</p>

<div class="tablecenter"><div class="tcont">
<table>

<tr>
  <td class="center">RDSINTERFACEDESCRIPTION</td>
  <td class="center">CODING\АБВГД\TYPE\Language\MOD\<i>имя_языка</i>&hellip;</td>
</tr>

<tr>
  <td class="center"><i>группа.объект.параметр</i></td>
  <td class="center"><i>значение</i></td>
</tr>

<tr>
  <td class="center"><i>группа.объект.параметр</i></td>
  <td class="center"><i>значение</i></td>
</tr>

<tr>
  <td colspan="2" class="center">&hellip;</td>
</tr>

</table>
</div></div>

<p>В первом столбце первой строки записан текст &laquo;RDSINTERFACEDESCRIPTION&raquo; &ndash;
это служебная метка, по которой формат файла опознается при импорте. Во втором столбце
закодированы параметры, для которых был экспортирован файл: тип модификации
&laquo;язык&raquo; (после &laquo;TYPE\&raquo;) и имя языка (после
&laquo;MOD\&raquo;). После &laquo;CODING\&raquo; в этом столбце записаны русские буквы
&laquo;АБВГД&raquo; для проверки кодировки файла.
 Если файл перевода экспортируется для
<a href="#datfile">DAT-файла описания интерфейса</a> пользователя,
а не для <a href="#light_p5_3">автокомпилируемых моделей</a>, то во втором столбце после
&laquo;DAT\&raquo; будет содержаться имя исходного DAT-файла, в котором обратная косая черта
&laquo;\&raquo; заменена на звездочку &laquo;*&raquo;. Сохраненное имя DAT-файла
используется при импорте файла перевода только для того, чтобы предупредить пользователя,
если он позже попытается импортировать этот файл для какого-то другого описания.</p>

<p>Далее во всех строках в первом столбце записаны имена группы объектов (окна или раздела интерфейса),
конкретного объекта (поля ввода, пункта меню) и параметра этого объекта (заголовок, подсказка и т.п.),
разделенные точками. Во втором столбце записан текст значения параметра, который пользователь может
менять при переводе.</p>

<p>При экспорте файла все тексты берутся в двойные кавычки. По спецификации формата это не обязательно,
но так надежнее. При загрузке файла RDS следует спецификациям
<a href="http://www.rfc-editor.org/rfc/rfc4180.txt" title="Спецификация формата (английский)">RFC 4180</a>:
в кавычках должны быть тексты, содержащие двойные кавычки, символы разделителя и разрывы строк.
В качестве разрыва строки используется комбинация CRLF (0x0D, 0x0A).</p>

<p>Для приведенного в п. <a href="#light_p2">2</a>
<a href="#rdsdatex">фрагмента</a> файла описания интерфейса пользователя
&laquo;rds.dat&raquo; часть CSV-файла после перевода может выглядеть так
(порядок строк может быть другим):</p>

<pre class="cpp">"RDSINTERFACEDESCRIPTION","CODING\АБВГД\TYPE\Language\MOD\English\DAT\Rds.dat"
"TMainForm.M_File1.Caption","File"
"TMainForm.M_NewSystem.Caption","New"
"TMainForm.M_Templates.Caption","New by template"
"TMainForm.M_LoadSystem.Caption","Open..."
"TMainForm.M_LoadInCopy.Caption","Open separate..."
"TMainForm.M_SaveSystem.Caption","Save"
&hellip;</pre>

<p>В данном случае &laquo;&hellip;MOD\English&raquo; во втором столбце первой строки
указывает на то, что файл экспортирован для языка &laquo;English&raquo;,
а &laquo;&hellip;DAT\Rds.dat&raquo; &ndash; на то, что файл экспортирован для
описания интерфейса &laquo;rds.dat&raquo;.</p>

<p>Текст &laquo;TMainForm.M_File1.Caption&raquo; в первом столбце второй строки говорит о том,
что эта строка описывает параметр &laquo;Caption&raquo; (заголовок) объекта
&laquo;M_File1&raquo; (в данном случае это пункт главного меню &laquo;Файл&raquo;) главного окна
RDS (&laquo;TMainForm&raquo;). Во втором столбце этой строки записан заголовок этого
пункта меню в английском варианте &ndash; &laquo;File&raquo;.</p>

<p>Списки вариантов выпадающих списков в CSV-файлах описываются многострочными текстами, состоящими
из строк вида &laquo;<i>индекс</i>=<i>значение</i>&raquo;, где <i>индекс</i> &ndash; начинающийся с
нуля номер варианта в списке, а <i>значение</i> &ndash; текст этого варианта, видимый пользователю.
Точно так же эти списки описываются в
<a href="#light_p2">DAT-</a> и
<a href="#light_p4_2">INI-файлах</a>, но в CSV-файлах вместо символа перевода строки
&laquo;\n&raquo; используется <i>настоящий</i> перевод строки. Например, описание
<a href="#light_combolist">выпадающего списка</a> из DAT-файла вида</p>

<pre class="cpp">[TTextProperties]
&hellip;
CB_Alignment.List=0=Влево\n1=По центру\n2=Вправо</pre>

<p class="noindent">после экспорта в CSV-файл будет выглядеть следующим образом:</p>

<pre class="cpp">"TTextProperties_Frame.CB_Alignment.List","0=Влево
1=По центру
2=Вправо"</pre>

<p>Следует учитывать, что любые строки с индексами, отличными от заложенных в программу
разработчиком и указанных в файле описания интерфейса, будут игнорироваться &ndash;
в выпадающем списке всегда будет столько пунктов, сколько предусмотрено разработчиком, и
добавить в список новые пункты через импорт файла перевода невозможно.</p>

<p>Если при экспорте был установлен флажок &laquo;Объединять одинаковые&raquo;
(см. <a href="#pic3">рисунок</a>), то в первом столбце экспортированного файла может
быть указано несколько описаний объектов с одинаковым значением параметра &ndash;
по одному описанию на строке. Например, запись:</p>

<pre class="cpp">"Messages.BMPModuleAbout.Text
Messages.ToolModuleAbout.Text","О модуле"</pre>

<p class="noindent">указывает на то, что одно и то же значение &laquo;О модуле&raquo;
имеют параметры &laquo;Text&raquo; объектов &laquo;BMPModuleAbout&raquo; и
&laquo;ToolModuleAbout&raquo; секции &laquo;Messages&raquo;. Если в этом файле перевести текст
&laquo;О модуле&raquo;, при импорте файла он будет присвоен этим двум объектам одновременно.
Переводчик может, при желании, вручную разделить эту запись на две, соблюдая правила формата CSV,
и дать параметрам разные значения:</p>

<pre class="cpp">"Messages.BMPModuleAbout.Text","About BMP module"
"Messages.ToolModuleAbout.Text","About tool module"</pre>

<p>После редактирования CSV-файл должен быть
<a href="#light_p4_4">импортирован обратно</a>
для слияния с уже имеющимися переводами.</p>



<h2 id="light_p4_4">4.4. Импорт файла перевода</h2>

<p>После того, как в
<a href="#light_p4_1">экспортированный</a> файл внесены переводы всех необходимых текстов,
этот файл необходимо импортировать обратно. Для этого на вкладке
&laquo;Инструменты интерфейса&raquo; окна настройки RDS следует выбрать в выпадающем списке
&laquo;Данные&raquo; (см. <a href="#pic3">рисунок</a>) вариант
&laquo;файл описания&raquo;, а справа от него, в другом выпадающем списке, имя файла
описания интерфейса, для которого будет импортироваться перевод.
<span class="emph">Здесь важно не ошибиться</span>: импортировать нужно для того же файла
описания, для которого перевод экспортировался (если выбранный в списке файл описания не
совпадает с указанным в файле перевода, будет выведено предупреждение).
В выпадающем списке модификации язык выбирать не
нужно &ndash; имя языка записано в самом импортируемом файле.</p>

<p>Далее следует нажать кнопку &laquo;Импорт&raquo; и выбрать файл, который будет загружаться.
После импорта переводы из этого файла заменят уже имеющиеся в RDS или добавятся, если раньше
их не было. Сам импортированный файл можно стирать &ndash; он больше не нужен.</p>

<p>Технически импорт файла перевода производится следующим образом: сначала из выбранного
пользователем файла считывается заголовок и определяется, для какого именно языка этот файл был
создан. Затем в память загружается выбранный файл описания интерфейса (с расширением &laquo;.dat&raquo;),
из которого выбрасываются все параметры, имена которых не перечислены через запятую в правой части
строки &laquo;Language=&hellip;&raquo; секции
&laquo;$Types&raquo; (см. п. <a href="#light_p2">2</a>). Затем загружается имеющийся на данный
момент двоичный файл перевода для считанного языка, если он есть, и в него из пользовательского
файла добавляются значения тех параметров, которые есть в файле описания. Таким образом,
невозможно импортировать параметры или объекты, которых нет в DAT-файле описания интерфейса.
После слияния с пользовательской информацией обновленный двоичный файл перевода
автоматически сохраняется. Теперь при следующем запуске RDS для данного языка будут
использоваться новые переводы.</p>



<h1 id="light_p5">5. Особенности перевода автокомпилируемых моделей</h1>

<p>В автокомпилируемых моделях тексты на разных языках хранятся не в отдельных двоичных файлах,
а в самих файлах моделей. Эти тексты можно переводить через процедуру экспорта/импорта,
похожую на описанную в п. <a href="#light_p4">4</a> (формат файлов тот же), либо сразу вводить
через интерфейс редактора модели при ее создании. Ниже рассматриваются оба способа.</p>

<h2 id="light_p5_1">5.1. Перевод текстов окна настройки блока в редакторе модели</h2>

<p>В автокомпилируемой модели к интерфейсу пользователя можно отнести только окно настройки блока,
создаваемое средствами редактора модели (см. &sect;3.6.6 описания пользователя) и, возможно,
какие-то сообщения, выводимые пользователю в отдельных окнах. Перевод сообщений рассмотрен в
п. <a href="#light_p5_2">5.2</a>, а здесь рассмотрим перевод элементов окна настройки.</p>

<p>В окнах настройки блока может быть четыре текстовых элемента, требующих перевода:</p>

<ul>
  <li>заголовок самого окна;</li>
  <li>названия вкладок;</li>
  <li>заголовки полей ввода и надписи;</li>
  <li>варианты выбора для выпадающих списков.</li>
</ul>

<p class="noindent">В редакторе модели рядом с полями ввода для этих элементов располагаются
кнопки с многоточием, нажатие которых позволяет ввести тексты элементов на разных языках
(разумеется, языки уже должны быть <a href="#light_p3">добавлены в RDS</a>).</p>

<div class="pic"><div class="container" id="pic4_1">
<img src="img/UITranslate_pic4_1.png" width="341" height="410" alt="Для окна настроек" />
<p id="light_pic4_1">Кнопка для задания текстов на разных языках для заголовка окна настроек</p>
</div></div>

<div class="pic"><div class="container" id="pic4_2">
<img src="img/UITranslate_pic4_2.png" width="309" height="100" alt="Для вкладки" />
<p id="light_pic4_2">Кнопка для задания названия вкладки на разных языках</p>
</div></div>

<div class="pic"><div class="container" id="pic5">
<img src="img/UITranslate_pic5.png" width="622" height="381" alt="Для поля ввода" />
<p id="light_pic5">Кнопки для задания текстов на разных языках для заголовка поля ввода (левее)<br />и списка вариантов выпадающего списка (правее и ниже)</p>
</div></div>

<p>При нажатии на любую из этих кнопок открывается окно, в левой части которого располагается список
существующих языков (включая вариант &laquo;по умолчанию&raquo;), а справа &ndash; поле ввода текста
для выбранного в списке слева языка. В файле модели будут сохранены все введенные
тексты, при этом в &laquo;основном&raquo; интерфейсе редактора модели, изображенном на
рисунках выше, будет отображаться и редактироваться значение для текущего языка.</p>

<div class="pic"><div class="container" id="pic6">
<img src="img/UITranslate_pic6.png" width="488" height="222" alt="Окно ввода текстов" />
<p id="light_pic6">Окно ввода текстов на разных языках</p>
</div></div>

<p>При <a href="#light_p6">смене языка интерфейса пользователя</a> RDS в файле
модели ничего автоматически изменено не будет. Но при следующей загрузке схемы с этой
моделью модуль автокомпиляции обнаружит, что DLL для модели была скомпилирована раньше изменения языка.
Это приведет к тому, что DLL модели будет перекомпилирована, а при этом в момент формирования
текста программы для компиляции в этот текст будут записаны строки для текущего, т.е. нового,
языка. Именно таким образом меняется язык интерфейса пользователя в автокомпилируемых моделях &ndash;
через перекомпиляцию. Поскольку смена языка выполняется не так уж часто, считаю это
приемлемым вариантом.</p>


<h2 id="light_p5_2">5.2. Перевод прочих текстовых сообщений</h2>

<p>Допустим, где-то в программе автокомпилируемой модели при выполнении (или невыполнении)
какого-то условия пользователю выдается окно с сообщением при помощи вызова функции
Windows API <span class="cpp">MessageBox</span> или соответствующей ей функции RDS
<span class="cpp">rdsMessageBox</span> (см. приложение А.5.5.6 к руководству программиста):</p>

<pre class="cpp">  rdsMessageBox(<span class="str">"Выберите режим работы"</span>,<span class="str">"Ошибка"</span>,
                MB_OK|MB_ICONWARNING);</pre>

<p>Здесь строки &laquo;Выберите режим работы&raquo; и &laquo;Ошибка&raquo; встроены
непосредственно в программу модели и не будут зависеть от текущего языка. Для того, чтобы
такие строки тоже можно было переводить, в модель можно вводить именованные текстовые константы
с разными текстами для разных языков, которые в программе используются по именам. Для ввода
или редактирования этих текстовых констант в редакторе модели служит пункт меню
&laquo;Модель | Текстовые константы&raquo;. При его выборе открывается окно, изображенное на
рисунке ниже.</p>

<div class="pic"><div class="container" id="pic7">
<img src="img/UITranslate_pic7.png" width="438" height="211" alt="Окно работы с текстовыми константами" />
<p id="light_pic7">Окно работы с текстовыми константами</p>
</div></div>

<p>Большую часть окна занимает список констант формата &laquo;<i>имя</i> = <i>значение</i>&raquo;,
справа находятся кнопки для добавления, изменения и удаления констант. При добавлении константы
или редактировании уже существующей открывается окно, изображенное на рисунке ниже.</p>

<div class="pic"><div class="container" id="pic8">
<img src="img/UITranslate_pic8.png" width="488" height="222" alt="Редактирование текстов константы" />
<p id="light_pic8">Редактирование текстов константы</p>
</div></div>

<p>В верхней части окна располагается поле для ввода имени константы, которое будет использоваться в
программе модели. Это имя должно удовлетворять правилам языка программирования C, не должно совпадать
с именами других используемых в модели объектов (переменных блока, настроечных параметров и т.п.),
а также не должно начинаться с букв &laquo;rds&raquo;, чтобы не пересекаться со служебными
функциями и константами.</p>

<p>Ниже слева находится список существующих языков вместе с вариантом &laquo;по умолчанию&raquo;,
как в похожем <a href="#pic6">окне ввода текстов</a> редактора модели. Справа &ndash; многострочное
поле для ввода текста значения константы для выбранного в списке слева языка. В нижней левой
части окна находится выпадающий список &laquo;перевод строки&raquo;, в котором можно выбрать
разделитель строк для многострочных констант: либо LF (&laquo;\n&raquo;), либо CRLF
(&laquo;\r\n&raquo;). Какую именно комбинацию выбрать, зависит от того, для чего константа
будет применяться, и это должен решать программист-создатель модели.</p>

<p>На <a href="#pic7">рисунке выше</a> в список введены две константы с именами
<span class="cpp">USER_MESSAGE</span> и <span class="cpp">USER_MESSAGE_CAPTION</span>. Приведенный выше
вызов функции вывода сообщения с использованием этих констант будет выглядеть так:</p>

<pre class="cpp">  rdsMessageBox(USER_MESSAGE,USER_MESSAGE_CAPTION,
                MB_OK|MB_ICONWARNING);</pre>

<p>При формировании текста программы для компиляции модели для каждой из этих констант
будет автоматически вставлен оператор <span class="cpp">#define</span> со значением для
текущего языка, поэтому при смене языка и перекомпиляции модели текст сообщения
будет автоматически изменяться.</p>



<h2 id="light_p5_3">5.3. Экспорт/импорт файла перевода для всех автокомпилируемых моделей схемы</h2>

<p>Все тексты интерфейса пользователя всех автокомпилируемых моделей какой-либо схемы,
описанные в п. <a href="#light_p5_1">5.1</a> и <a href="#light_p5_2">5.2</a>, могут быть выгружены
в файл перевода, переведены все вместе, а потом загружены обратно &ndash; примерно так же,
как <a href="#light_p4">переводятся</a> тексты стандартных, не автокомпилируемых моделей.
Для этого нужно загрузить схему, а затем открыть окно настроек RDS и выбрать в нем вкладку
&laquo;Инструменты интерфейса&raquo;.</p>

<div class="pic"><div class="container" id="pic9">
<img src="img/UITranslate_pic9.png" width="578" height="422" alt="Экспорт/импорт текстов автокомпилируемых моделей" />
<p id="light_pic9">Экспорт/импорт текстов автокомпилируемых моделей</p>
</div></div>

<p>На этой вкладке на панели &laquo;Экспорт/импорт файла описания&raquo; в выпадающем списке
&laquo;Данные&raquo; нужно выбрать не &laquo;файл описания&raquo;, как при переводе программ и
стандартных моделей, а &laquo;модели схемы&raquo;. После этого в выпадающем списке справа можно
выбрать модуль автокомпиляции, модели которого будут переводиться. Лучше выбрать вариант
&laquo;все модули автокомпиляции&raquo;, поскольку все существующие на данный момент модули,
даже если в схеме их будет использовано несколько (что маловероятно и не рекомендуется), совместимы
по формату данных.</p>

<p>Затем в выпадающем списке &laquo;Модификация&raquo; нужно выбрать язык, для которого
экспортируется файл, по желанию включить флажок &laquo;только новые описания&raquo; (в этом
случае в файл будут записаны только тексты, для которых еще нет перевода), нажать кнопку
&laquo;Экспорт&raquo; и выбрать имя и формат записываемого файла. Форматы файлов перевода
описаны в п. <a href="#light_p4_2">4.2</a> и <a href="#light_p4_3">4.3</a>, для автокомпилируемых моделей
они ничем не отличаются. Имя группы объектов в этом файле формируется из имени модели,
имя объекта &ndash; это имя текстовой константы, настроечного параметра или автоматически
сгенерированный идентификатор для заголовков вкладок и надписей.</p>

<p>После перевода файла его загрузка и слияние с моделями схемы делается точно так же:
загружается схема, открывается окно настроек, в списке &laquo;Данные&raquo; выбирается вариант
&laquo;модели схемы&raquo;, в списке справа от него &ndash;
&laquo;все модули автокомпиляции&raquo;, нажимается кнопка &laquo;Импорт&raquo;
и выбирается импортируемый файл.</p>



<h1 id="light_p6">6. Выбор языка интерфейса пользователя</h1>

<p>Для установки текущего языка интерфейса пользователя RDS следует выбрать пункт главного меню
&laquo;Сервис | Язык интерфейса&raquo;. При этом откроется окно со списком доступных языков.</p>

<div class="pic"><div class="container" id="pic10">
<img src="img/UITranslate_pic10.png" width="277" height="171" alt="Окно выбора языка" />
<p id="light_pic10">Окно выбора языка интерфейса пользователя</p>
</div></div>

<p>В этом списке следует выбрать желаемый язык и нажать кнопку &laquo;OK&raquo;. При
этом окно закроется и будет выведено сообщение о том, что язык будет установлен
при следующем запуске RDS. Если никакая схема в данный момент не загружена,
RDS завершится автоматически.</p>

<p>Если в RDS не <a href="#light_p3">создано</a> ни одного языка, пункт меню будет отсутствовать.</p>




<h1 id="light_p7">7. Включение функций загрузки перевода в модели блоков</h1>

<p>Для того, чтобы надписи в окнах настроек блоков или сообщения пользователю, выводимые блоками,
всегда показывались на текущем выбранном в RDS языке, необходимо вместо жестких строковых констант
(строк в двойных кавычках) использовать в моделях этих блоков вызовы функций, которые
будут загружать тексты из двоичных файлов перевода для текущего языка. Ниже рассматриваются эти
новые, появившиеся в версии 1.0.520, <a href="#light_p7_2">функции</a>, а также
<a href="#light_p7_3">вспомогательный класс</a>, сделанный на их основе, который
можно использовать в моделях, написанных на C++.
В п. <a href="#light_p7_4">7.4</a> приведены примеры моделей с переводом интерфейса пользователя
при помощи этих функций и вспомогательного класса.</p>



<h3 id="light_p7_1">7.1. Константы для стандартных папок</h3>

<p>Для стандартных папок, в которых хранятся
<a href="#light_p1">файлы описания интерфейса</a>
(&laquo;Description&raquo;, &laquo;Interface&raquo; и т.д)
в файл &laquo;RdsDef.h&raquo; добавлены следующие
строковые константы:</p>

<dl>
  <dt><span class="cpp">#define RDS_UIMODD_DEFAULT "Default"</span></dt>
  <dd>Папка с параметрами для языка по умолчанию.</dd>

  <dt><span class="cpp">#define RDS_UIMODD_DESCR "Description"</span></dt>
  <dd>Папка описаний интерфейса пользователя внутри папки установки RDS.</dd>

  <dt><span class="cpp">#define RDS_UIMODD_MODS "Interface"</span></dt>
  <dd>Папка с данными разных типов модификаций интерфейса пользователя (включая язык)
  внутри папки установки RDS.</dd>

  <dt><span class="cpp">#define RDS_UIMODC_LANGUAGE "Language"</span></dt>
  <dd>Папка с данными разных языков интерфейса пользователя внутри папки модификаций
  (<span class="cpp">RDS_UIMODD_MODS</span>).</dd>

</dl>

<p class="noindent">Например, путь к папке с данными языка с названием &laquo;English&raquo; в вызовах
различных сервисных функций RDS можно записать так:</p>

<pre class="cpp">  <span class="str">"$RDS$&#92;&#92;"</span> RDS_UIMODD_MODS <span class="str">"&#92;&#92;"</span> RDS_UIMODC_LANGUAGE <span class="str">"&#92;&#92;English"</span></pre>

<p class="noindent">(здесь &laquo;$RDS$&raquo; &ndash; символическое имя для папки установки
RDS, которое понимают все сервисные функции).</p>

<p>Путь к папке с данными текущего языка интерфейса для передачи в сервисные функции можно указывать
с помощью нового символического имени &laquo;$CURLANG$&raquo;.</p>

<h2 id="light_p7_2">7.2. Новые сервисные функции и константы RDS</h2>

<p>Для поддержки перевода интерфейса пользователя в RDS был добавлен новый тип вспомогательного объекта
(<span class="cpp">RDS_HOBJECT</span>, см. приложение А.5.22.1) и функции для работы с ним. Кроме того,
добавлены новые функции общего назначения и новые возможности к уже имеющимся.</p>


<h3 id="light_p7_2_1">7.2.1. Получение имени текущего языка</h3>

<p>Имя текущего выбранного языка интерфейса пользователя RDS (это имя совпадает с именем папки, в
которой хранятся его данные) можно получить при помощи вызова функции
<span class="cpp">rdsGetSystemPath</span> (приложение А.5.2.25) с новой константой
<span class="cpp">RDS_GSPCURLANGUAGE</span>:</p>

<pre class="cpp">  <span class="kw">char</span> *lang=rdsGetSystemPath(RDS_GSPCURLANGUAGE);</pre>

<p>Если выбран не язык по умолчанию, функция возвращает указатель на строку с именем языка
во внутреннем буфере RDS (эту строку изменять нельзя). Если выбран язык по умолчанию,
функция возвращает указатель на пустую строку.</p>

<p>Название языка по умолчанию, пригодное для показа пользователю, можно получить при помощи вызова
той же функции с константой <span class="cpp">RDS_GSPDEFLANGTEXT</span>:</p>

<pre class="cpp">  <span class="kw">char</span> *deftext=rdsGetSystemPath(RDS_GSPDEFLANGTEXT);</pre>

<p>Для всех прочих языков название для пользователя совпадает с именем языка.</p>


<h3 id="light_p7_2_2">7.2.2. <span class="cpp">rdsGetUICurrentMod</span> &ndash; параметры текущей модификации интерфейса пользователя</h3>

<p>Функция <span class="cpp">rdsGetUICurrentMod</span> считывает параметры текущей модификации интерфейса
пользователя заданного типа. На данный момент существует единственный тип модификации интерфейса
&ndash; язык.</p>

<pre class="cpp">  LPSTR RDSCALL rdsGetUICurrentMod(
    LPCSTR category,      <span class="rem">// Тип модификации</span>
    FILETIME *changetime  <span class="rem">// Возвращаемое время изменения</span>
  );</pre>

<p class="apphdr">Тип указателя на эту функцию</p>
<p><span class="cpp">RDS_SSFt</span></p>

<p class="apphdr">Параметры</p>

<dl>
  <dt><span class="cpp">category</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка с именем папки для запрашиваемого типа модификации интерфейса. Сейчас поддерживается только
  <span class="cpp">Language</span> (константа <span class="cpp">RDS_UIMODC_LANGUAGE</span>, см.
  п. <a href="#light_p7_1">7.1</a>), т.е. язык интерфейса.</dd>

  <dt><span class="cpp">changetime</span>&emsp;(<span class="cpp"><i>FILETIME*</i></span>)</dt>
  <dd>Указатель на структуру <span class="cpp">FILETIME</span>, в которую функция записывает
  время последнего изменения интерфейса по данному типу модификации. Для языка это будет
  временем последнего переключения языка в главном меню RDS, эта информация может быть нужна
  модулям автокомпиляции для проверки необходимости изменения языка в обслуживаемых моделях
  (см. п. <a href="#light_p5">5</a>). Если время изменения языка не нужно, в этом параметре
  можно передать <span class="cpp">NULL</span>.</dd>
</dl>

<p class="apphdr">Возвращаемое значение</p>
<p>Указатель на строку с именем текущей модификации (языка) во внутреннем буфере RDS.
Если выбрана модификация по умолчанию, возвращается указатель на пустую строку.</p>


<h3 id="light_p7_2_3">7.2.3. <span class="cpp">rdsGetUIModsList</span> &ndash; список модификаций интерфейса пользователя</h3>

<p>Функция <span class="cpp">rdsGetUIModsList</span> возвращает список существующих в
RDS модификаций интерфейса пользователя заданного типа. На данный момент существует единственный тип
модификации интерфейса &ndash; язык.</p>

<pre class="cpp">  LPSTR RDSCALL rdsGetUIModsList(
    LPCSTR category    <span class="rem">// Тип модификации</span>
  );</pre>

<p class="apphdr">Тип указателя на эту функцию</p>
<p><span class="cpp">RDS_SS</span></p>

<p class="apphdr">Параметр</p>

<dl>
  <dt><span class="cpp">category</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка с именем папки для запрашиваемого типа модификации интерфейса. Сейчас поддерживается только
  &laquo;Language&raquo; (константа <span class="cpp">RDS_UIMODC_LANGUAGE</span>, см.
  п. <a href="#light_p7_1">7.1</a>), т.е. язык интерфейса.</dd>
</dl>

<p class="apphdr">Возвращаемое значение</p>
<p>Динамически сформированный текст со списком существующих модификаций, разделенных кодом перевода
строки &laquo;\n&raquo;.</p>

<p class="apphdr">Примечания</p>
<p>Эта функция может использоваться для предъявления пользователю списка доступных модификаций
для выбора одной из них. Например, в стандартном модуле автокомпиляции она используется для
формирования списка языков в левой части <a href="#pic6">окна</a> работы с
переводами текстов модели.</p>

<p>Модификация по умолчанию в этот список не входит, в нем будут только дополнительные модификации.
Таким образом, если, например, в RDS есть русский (по умолчанию) и английский (папка &laquo;English&raquo;)
языки, то функция вернет текст &laquo;English&raquo;.</p>

<p>Динамическая строка, созданная функцией <span class="cpp">rdsGetUIModsList</span>, должна быть
<span class="emph">обязательно</span> освобождена функцией
<span class="cpp">rdsFree</span> (приложение А.5.4.8).</p>



<h3 id="light_p7_2_4">7.2.4. <span class="cpp">rdsUIMODCreate</span> &ndash; создание объекта для работы с модификациями интерфейса</h3>

<p>Функция <span class="cpp">rdsUIMODCreate</span> создает вспомогательный объект RDS,
который может загружать данные из двоичных файлов модификаций интерфейса (файлов перевода) и
возвращать значения параметров из этих файлов.</p>

<pre class="cpp">  RDS_HOBJECT RDSCALL rdsUIMODCreate(<span class="kw">void</span>);</pre>

<p class="apphdr">Тип указателя на эту функцию</p>
<p><span class="cpp">RDS_HoV</span></p>

<p class="apphdr">Возвращаемое значение</p>
<p>Уникальный идентификатор созданного объекта (<span class="cpp">RDS_HOBJECT</span>).</p>

<p class="apphdr">Примечания</p>
<p>Эта функция создает вспомогательный объект, при помощи которого можно получать тексты на
текущем языке для разных элементов интерфейса пользователя. Тексты загружаются из двоичного файла,
созданного так, как описано в п. <a href="#light_p4">4</a>. Этот же объект может использоваться и
для экспорта/импорта файла перевода. Здесь будет описано только его использование для перевода
текстов в моделях блоков, поскольку программный экспорт/импорт файлов нужен только при создании пользовательских
модулей автокомпиляции.</p>

<p>Для уничтожения объекта используется стандартная функция
<span class="cpp">rdsDeleteObject</span> (см. приложение А.5.22.4). </p>




<h3 id="light_p7_2_5">7.2.5. <span class="cpp">rdsUIMODLoadGroup</span> &ndash; загрузка группы</h3>

<p>Функция <span class="cpp">rdsUIMODLoadGroup</span> загружает во вспомогательный объект
группу объектов интерфейса из указанного двоичного файла. После загрузки можно считывать
различные параметры объектов из этой группы.</p>

<pre class="cpp">  BOOL RDSCALL rdsUIMODLoadGroup(
    RDS_HOBJECT mod,   <span class="rem">// Объект</span>
    LPCSTR file,       <span class="rem">// Имя двоичного файла</span>
    LPCSTR group       <span class="rem">// Имя группы</span>
  );</pre>

<p class="apphdr">Тип указателя на эту функцию</p>
<p><span class="cpp">RDS_BHoSS</span></p>

<p class="apphdr">Параметры</p>

<dl>
  <dt><span class="cpp">mod</span>&emsp;(<span class="cpp"><i>RDS_HOBJECT</i></span>)</dt>
  <dd>Идентификатор объекта, ранее созданного вызовом
  <a href="#light_p7_2_4"><span class="cpp">rdsUIMODCreate</span></a>).</dd>

  <dt><span class="cpp">file</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка с именем двоичного файла, из которого нужно загрузить группу. В этой строке можно
  использовать символически обозначения папок RDS, включая &laquo;$CURLANG$&raquo;. Например,
  для загрузки данных из двоичного файла &laquo;MyDll.bin&raquo; в подпапке
  &laquo;Dll\&raquo; папки текущего языка интерфейса можно использовать строку
  &laquo;$CURLANG$\\Dll\\MyDll.bin&raquo;.</dd>

  <dt><span class="cpp">group</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка с именем загружаемой группы.</dd>
</dl>

<p class="apphdr">Возвращаемое значение</p>
<p>Успешность загрузки (<span class="cpp">TRUE</span>, если
существует указанный файл и в нем есть данные указанной группы).</p>

<p class="apphdr">Примечания</p>
<p>Эта функция обычно используется в тех случаях, когда предполагается работа с несколькими объектами.
Например, при открытии окна настройки блока имеет смысл загрузить группу, в которой находятся
тексты заголовков объектов, соответствующих полям ввода этого окна, а затем считывать из загруженных
данных тексты для каждого поля.</p>

<p>Все тексты, загруженные в объект <span class="cpp">mod</span> до вызова этой функции,
стираются из памяти и заменяются загруженными.</p>



<h3 id="light_p7_2_6">7.2.6. <span class="cpp">rdsUIMODLoadSingleObject</span> &ndash; загрузка одного объекта</h3>

<p>Функция <span class="cpp">rdsUIMODLoadSingleObject</span> загружает во вспомогательный объект
данные единственного указанного в параметрах объекта интерфейса из указанного двоичного файла.
После загрузки можно считывать различные параметры этого объекта.</p>

<pre class="cpp">  BOOL RDSCALL rdsUIMODLoadSingleObject(
    RDS_HOBJECT mod,   <span class="rem">// Объект</span>
    LPCSTR file,       <span class="rem">// Имя двоичного файла</span>
    LPCSTR group,      <span class="rem">// Имя группы</span>
    LPCSTR object      <span class="rem">// Имя объекта</span>
  );</pre>

<p class="apphdr">Тип указателя на эту функцию</p>
<p><span class="cpp">RDS_BHoSSS</span></p>

<p class="apphdr">Параметры</p>

<dl>
  <dt><span class="cpp">mod</span>&emsp;(<span class="cpp"><i>RDS_HOBJECT</i></span>)</dt>
  <dd>Идентификатор объекта, ранее созданного вызовом
  <a href="#light_p7_2_4"><span class="cpp">rdsUIMODCreate</span></a>).</dd>

  <dt><span class="cpp">file</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка с именем двоичного файла, из которого нужно загрузить группу. В этой строке можно
  использовать символически обозначения папок RDS, включая &laquo;$CURLANG$&raquo;. Например,
  для загрузки данных из двоичного файла &laquo;MyDll.bin&raquo; в подпапке
  &laquo;Dll\&raquo; папки текущего языка интерфейса можно использовать строку
  &laquo;$CURLANG$\\Dll\\MyDll.bin&raquo;.</dd>

  <dt><span class="cpp">group</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка с именем загружаемой группы.</dd>

  <dt><span class="cpp">object</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка с именем объекта.</dd>
</dl>

<p class="apphdr">Возвращаемое значение</p>
<p>Успешность загрузки (<span class="cpp">TRUE</span>, если существует указанный файл и в
нем есть данные указанного объекта в указанной группе).</p>

<p class="apphdr">Примечания</p>
<p>Эта функция обычно используется в тех случаях, когда предполагается работа с единственным
объектом. Например, при выводе сообщения пользователю обычно достаточно загрузить только текст
этого сообщения, не загружая остальные объекты в группе, в которой этот текст находится.
Если объект был загружен успешно, в последующих вызовах функций чтения значений его параметров имя
объекта можно не указывать (передается <span class="cpp">NULL</span>).</p>

<p>Все тексты, загруженные в объект <span class="cpp">mod</span> до вызова этой функции,
стираются из памяти и заменяются загруженными.</p>



<h3 id="light_p7_2_7">7.2.7. <span class="cpp">rdsUIMODGetParamString</span> &ndash; получение текста значения параметра из считанных данных</h3>

<p>Функция <span class="cpp">rdsUIMODGetParamString</span> возвращает строку значения указанного
параметра указанного объекта из уже загруженной группы (см.
<a href="#light_p7_2_5"><span class="cpp">rdsUIMODLoadGroup</span></a>)
или одиночного объекта (см.
<a href="#light_p7_2_6"><span class="cpp">rdsUIMODLoadSingleObject</span></a>).</p>

<pre class="cpp">  BOOL RDSCALL rdsUIMODGetParamString(
    RDS_HOBJECT mod,   <span class="rem">// Объект</span>
    LPCSTR object      <span class="rem">// Имя объекта</span>
    <span class="kw">int</span> paramid,       <span class="rem">// Идентификатор параметра</span>
    LPCSTR defval      <span class="rem">// Значение по умолчанию</span>
  );</pre>

<p class="apphdr">Тип указателя на эту функцию</p>
<p><span class="cpp">RDS_SHoSIS</span></p>

<p class="apphdr">Параметры</p>

<dl>
  <dt><span class="cpp">mod</span>&emsp;(<span class="cpp"><i>RDS_HOBJECT</i></span>)</dt>
  <dd>Идентификатор объекта, ранее созданного вызовом
  <a href="#light_p7_2_4"><span class="cpp">rdsUIMODCreate</span></a>).</dd>

  <dt><span class="cpp">object</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка с именем объекта или <span class="cpp">NULL</span> для последнего объекта, из которого читались данные.</dd>

  <dt><span class="cpp">paramid</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Целый идентификатор параметра или константа <span class="cpp">RDS_UIMOD_ANYPARAMID</span> для
  чтения значения первого попавшегося параметра (используется в тех случаях, когда у объекта
  есть только один параметр). Идентификаторы параметров указываются в секции
  &laquo;$Params&raquo; <a href="#light_p2">файла описания интерфейса</a>.</dd>

  <dt><span class="cpp">defval</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка, возвращаемая при отсутствии параметра, объекта или любых загруженных данных.</dd>
</dl>

<p class="apphdr">Возвращаемое значение</p>
<p>Если данные из двоичного файла перевода были ранее загружены успешно, в этих
данных есть указанный объект, и у этого объекта есть указанный параметр, возвращается указатель
на строку во внутренних данных объекта <span class="cpp">mod</span> с текстовым значением
этого параметра. Эта строка будет существовать до уничтожения объекта или до загрузки в
него новых данных. Если же указанного параметра нет, возвращается переданный в параметрах
функции указатель <span class="cpp">defval</span>.</p>

<p class="apphdr">Примечания</p>
<p>Это основная функция получения переведенных строк из загруженных данных. Строка на языке
по умолчанию (русском) передается в параметре <span class="cpp">defval</span>. Если перевод успешно
загружен, возвращается переведенная строка, если нет &ndash; строка по умолчанию.</p>



<h3 id="light_p7_2_8">7.2.8. <span class="cpp">rdsUIMODGetParamListString</span> &ndash; получение текста содержимого выпадающего списка из считанных данных</h3>

<p>Функция <span class="cpp">rdsUIMODGetParamListString</span> преобразует строку описания выпадающего
списка формата &laquo;0=вариант1\n1=вариант2\n&hellip;&raquo; из указанного параметра
указанного объекта уже загруженной группы <a href="#light_p7_2_5"><span class="cpp">rdsUIMODLoadGroup</span></a>)
или одиночного объекта (см.
<a href="#light_p7_2_6"><span class="cpp">rdsUIMODLoadSingleObject</span></a>)
в строку вида &laquo;вариант1\nвариант2\n&hellip;&raquo;, пригодную для передачи в
оконные объекты RDS (приложение А.5.28.18).</p>

<pre class="cpp">  BOOL RDSCALL rdsUIMODGetParamListString(
    RDS_HOBJECT mod,  <span class="rem">// Объект</span>
    LPCSTR object     <span class="rem">// Имя объекта</span>
    <span class="kw">int</span> paramid,      <span class="rem">// Идентификатор параметра</span>
    LPCSTR defval     <span class="rem">// Значение по умолчанию</span>
  );</pre>

<p class="apphdr">Тип указателя на эту функцию</p>
<p><span class="cpp">RDS_SHoSIS</span></p>

<p class="apphdr">Параметры</p>

<dl>
  <dt><span class="cpp">mod</span>&emsp;(<span class="cpp"><i>RDS_HOBJECT</i></span>)</dt>
  <dd>Идентификатор объекта, ранее созданного вызовом
  <a href="#light_p7_2_4"><span class="cpp">rdsUIMODCreate</span></a>).</dd>

  <dt><span class="cpp">object</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка с именем объекта или <span class="cpp">NULL</span> для последнего объекта, из которого читались данные.</dd>

  <dt><span class="cpp">paramid</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Целый идентификатор параметра или константа <span class="cpp">RDS_UIMOD_ANYPARAMID</span> для
  чтения значения первого попавшегося параметра (используется в тех случаях, когда у объекта
  есть только один параметр). Идентификаторы параметров указываются в секции
  &laquo;$Params&raquo; <a href="#light_p2">файла описания интерфейса</a>.</dd>

  <dt><span class="cpp">defval</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка, возвращаемая при отсутствии параметра, объекта или любых загруженных данных.</dd>
</dl>

<p class="apphdr">Возвращаемое значение</p>
<p>Если данные из двоичного файла перевода были ранее загружены успешно, в этих данных
есть указанный объект, и у этого объекта есть указанный параметр, из этого параметра считывается
текст <a href="#light_combolist">описания выпадающего списка</a> формата
&laquo;0=вариант1\n1=вариант2\n&hellip;&raquo;. Затем в переданном тексте
<span class="cpp">defval</span> формата &laquo;вариант1\nвариант2\n&hellip;&raquo;
отдельные строки заменяются на считанные согласно индексам перед знаком равенства,
получившаяся строка сохраняется во внутренних данных объекта <span class="cpp">mod</span>, и
возвращается указатель на нее. Эта строка будет существовать до уничтожения объекта или до
загрузки в него новых данных. Если же указанного параметра в загруженных данных нет,
возвращается переданный в параметрах функции указатель <span class="cpp">defval</span>.</p>

<p class="apphdr">Примечания</p>
<p>Эта функция используется для перевода вариантов выпадающих списков для полей ввода
RDS в окнах настройки блоков. Список вариантов для поля задается в виде текста, где
варианты разделены кодом перевода строки &laquo;\n&raquo;. В файлах перевода списки
вариантов задаются похожим образом, но перед текстом самого варианта указывается его номер
и знак равенства. Функция <span class="cpp">rdsUIMODGetParamListString</span>
переводит один формат в другой. В параметре <span class="cpp">defval</span> передается список
вариантов на языке по умолчанию. Если перевод успешно загружен, возвращается переведенный
список вариантов в том же формате, если нет &ndash; текст по умолчанию из <span class="cpp">defval</span>.</p>

<p>Пусть, например, список вариантов на русском языке выглядит как
&laquo;Ручной\nАвтоматический&raquo;. Этот текст задает список из двух вариантов:
&laquo;Ручной&raquo; с индексом 0 (самый первый в списке) и
&laquo;Автоматический&raquo; с индексом 1 (второй в списке). Пусть в файле перевода для
этого списка хранится строка
&laquo;1=Automatic\n0=Manual\n2=Other&raquo;. Вызов функции
<span class="cpp">rdsUIMODGetParamListString</span> в этом случае вернет указатель на текст
&laquo;Manual\nAutomatic&raquo;: в исходном списке строка с индексом 0 заменена на
&laquo;Manual&raquo;, строка с индексом 1 &ndash; на &laquo;Automatic&raquo;. Вариант с
индексом 2 (&laquo;Other&raquo;) из файла перевода будет проигнорирован, поскольку в исходном
списке вариантов строки с таким индексом нет.</p>



<h3 id="light_p7_2_9">7.2.9. Команда <span class="cpp">RDS_UIMOD_CLEAR</span> &ndash; очистка загруженных данных</h3>

<p>Команда <span class="cpp">RDS_UIMOD_CLEAR</span> очищает все загруженные из файла перевода в объект данные.</p>

<p class="apphdr">Вызов команды</p>
<pre class="cpp">  rdsCommandObject(mod,RDS_UIMOD_CLEAR);</pre>


<p class="apphdr">Параметр</p>

<dl>
  <dt><span class="cpp">mod</span>&emsp;(<span class="cpp"><i>RDS_HOBJECT</i></span>)</dt>
  <dd>Идентификатор объекта, ранее созданного вызовом
  <a href="#light_p7_2_4"><span class="cpp">rdsUIMODCreate</span></a>).</dd>
</dl>

<p class="apphdr">Примечания</p>
<p>После очистки данных вызовы функций
<a href="#light_p7_2_7"><span class="cpp">rdsUIMODGetParamString</span></a> и
<a href="#light_p7_2_8"><span class="cpp">rdsUIMODGetParamListString</span></a>
будут возвращать переданные в них значения по умолчанию до тех пор, пока в объект не
будут загружены новые данные.</p>



<h3 id="light_p7_2_10">7.2.10. Команда <span class="cpp">RDS_UIMOD_SETCRLFCORR</span> &ndash; установка способа обработки переводов строк</h3>

<p>Команда <span class="cpp">RDS_UIMOD_SETCRLFCORR</span> устанавливает способ обработки
переводов строк в загружаемых текстах. Команду нужно отдавать до загрузки данных, т.е.
перед вызовом функции
<a href="#light_p7_2_5"><span class="cpp">rdsUIMODLoadGroup</span></a>
или
<a href="#light_p7_2_6"><span class="cpp">rdsUIMODLoadSingleObject</span></a>.</p>

<p class="apphdr">Вызов команды</p>

<pre class="cpp">  <span class="kw">int</span> iMode=&hellip;  <span class="rem">// Константа RDS_UIMOD_CRLF_*</span>
  rdsSetObjectInt(mod,RDS_UIMOD_SETCRLFCORR,<span class="const">0</span>,iMode);</pre>

<p class="apphdr">Параметры</p>

<dl>
  <dt><span class="cpp">mod</span>&emsp;(<span class="cpp"><i>RDS_HOBJECT</i></span>)</dt>
  <dd>Идентификатор объекта, ранее созданного вызовом
  <a href="#light_p7_2_4"><span class="cpp">rdsUIMODCreate</span></a>).</dd>

  <dt><span class="cpp">iMode</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Одна из констант <span class="cpp">RDS_UIMOD_CRLF_*</span>, указывающая способ обработки переводов строк:
    <div class="tableleft"><div class="tcont">
      <table class="list">
        <tr>
          <td class="term"><span class="cpp">RDS_UIMOD_CRLF_ANY</span></td>
          <td>Переводы строк в текстах никак не обрабатываются и остаются в точности такими, какими
          их записал создатель двоичного файла (переводчик).</td>
        </tr>
        <tr>
          <td class="term"><span class="cpp">RDS_UIMOD_CRLF_LF</span></td>
          <td>Переводы строк вида &laquo;\r\n&raquo; заменяются на одиночный код &laquo;\n&raquo;.</td>
        </tr>
        <tr>
          <td class="term"><span class="cpp">RDS_UIMOD_CRLF_BOTH</span></td>
          <td>Переводы строк вида &laquo;\n&raquo; заменяются на сочетание &laquo;\r\n&raquo;.</td>
        </tr>
        <tr>
          <td class="term"><span class="cpp">RDS_UIMOD_CRLF_NONE</span></td>
          <td>Любые переводы строк заменяются на пробелы.</td>
        </tr>
      </table>
    </div></div>
  </dd>
</dl>

<p class="apphdr">Примечания</p>
<p>Эта команда используется для того, чтобы загрузить тексты с переводами строк из двоичного файла
в формате, требуемом программой модели блока. Требуемый формат определяется разработчиком модели.</p>



<h2 id="light_p7_3">7.3. Использование вспомогательного класса для загрузки перевода</h2>

<p>Если программа модели блока написана на C++, для загрузки текстов из двоичных файлов переводов
можно использовать вспомогательный класс <span class="cpp">TRdsHelperLanguage</span>, описанный в файле
&laquo;RdsClasses.hpp&raquo;. Класс берет на себя создание вспомогательного объекта RDS,
поэтому обычно программы с ним получаются короче. Все функции класса описаны непосредственно внутри
&laquo;RdsClasses.hpp&raquo;, поэтому для работы достаточно включить этот файл в исходный текст
модели командой <span class="cpp">#include</span>.</p>



<h3 id="light_p7_3_1">7.3.1. Конструкторы класса</h3>

<p>Класс имеет три конструктора:</p>

<pre class="cpp">  TRdsHelperLanguage(<span class="kw">void</span>);
  TRdsHelperLanguage(LPCSTR filepath);
  TRdsHelperLanguage(LPCSTR filepath,LPCSTR groupname);</pre>

<p>Конструктор без параметров просто создает объект, для дальнейшей работы нужно будет передать
ему имя двоичного файла функцией
<a href="#light_p7_3_2"><span class="cpp">SetBinaryFile</span></a>. Конструктор с
одним строковым параметром сразу запоминает переданную строку в качестве имени двоичного файла.
Конструктор с двумя строковыми параметрами запоминает первый параметр как имя двоичного файла
и загружает из этого файла в объект группу с именем, переданным во втором параметре.</p>

<p>Проще всего использовать конструкторы с параметрами: например, чтобы создать объект
<span class="cpp">Lang</span>, который будет считывать тексты из файла
&laquo;MyDll.bin&raquo; в подпапке &laquo;Dll&raquo; папки текущего языка, можно описать его так:</p>

<pre class="cpp">  TRdsHelperLanguage Lang(<span class="str">"$CURLANG$&#92;&#92;Dll&#92;&#92;MyDll.bin"</span>);</pre>

<p>Если в этот объект нужно сразу загрузить все данные группы &laquo;MyGroup&raquo;,
можно описать объект так:</p>

<pre class="cpp">  TRdsHelperLanguage Lang(<span class="str">"$CURLANG$&#92;&#92;Dll&#92;&#92;MyDll.bin"</span>,<span class="str">"MyGroup"</span>);</pre>

<p>В передаваемом в параметре имени файла можно использовать любые символические имена папок RDS, включая
&laquo;$CURLANG$&raquo; для пути к папке с данными текущего языка интерфейса.</p>



<h3 id="light_p7_3_2">7.3.2. Функция-член <span class="cpp">SetBinaryFile</span> &ndash; установка имени двоичного файла</h3>

<p>Функция <span class="cpp">SetBinaryFile</span> передает в объект имя двоичного файла,
из которого будут загружаться переведенные тексты.</p>

<pre class="cpp">  <span class="kw">void</span> SetBinaryFile(
    LPCSTR filepath   <span class="rem">// Имя двоичного файла</span>
  );</pre>

<p class="apphdr">Параметр</p>

<dl>
  <dt><span class="cpp">filepath</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Имя двоичного файла для загрузки текстов перевода. В имени можно использовать любые
  символические имена папок RDS, включая &laquo;$CURLANG$&raquo; для пути к
  папке с данными текущего языка интерфейса.</dd>
</dl>

<p class="apphdr">Примечания</p>
<p>Если в объект уже были загружены какие-либо тексты, после вызова этой функции они очищаются.
Если объект создан конструктором с параметром, в который уже передано имя файла, вызывать
<span class="cpp">SetBinaryFile</span> нет необходимости.</p>


<h3 id="light_p7_3_3">7.3.3. Функция-член <span class="cpp">Clear</span> &ndash; очистка объекта</h3>

<p>Функция <span class="cpp">Clear</span> стирает в объекте все загруженные на данный момент переведенные тексты.</p>

<pre class="cpp">  <span class="kw">void</span> Clear(<span class="kw">void</span>);</pre>

<p class="apphdr">Примечания</p>
<p>Имя двоичного файла, переданное в объект, этой функцией не очищается.</p>



<h3 id="light_p7_3_4">7.3.4. Функции-члены <span class="cpp">IsLoaded</span> и <span class="cpp">IsNotLoaded</span> &ndash; проверка наличия в объекте загруженных данных</h3>

<p>Функции <span class="cpp">IsLoaded</span> и <span class="cpp">IsNotLoaded</span> возвращают
результат последней операции загрузки текстов из двоичного файла, т.е. признак
наличия в файле запрошенных объектов.</p>

<pre class="cpp">  BOOL IsLoaded(<span class="kw">void</span>);
  BOOL IsNotLoaded(<span class="kw">void</span>);</pre>

<p class="apphdr">Возвращаемое значение</p>
<p>Функция <span class="cpp">IsLoaded</span> возвращает <span class="cpp">TRUE</span>, если
последний вызов
<a href="#light_p7_3_6"><span class="cpp">LoadGroup</span></a> или
<a href="#light_p7_3_7"><span class="cpp">LoadObject</span></a> успешно загрузил
данные из файла, и <span class="cpp">FALSE</span> в противном случае. Функция
<span class="cpp">IsNotLoaded</span> возвращает противоположное значение (<span class="cpp">TRUE</span>
&ndash; данные не загружены, <span class="cpp">FALSE</span> &ndash; загружены).</p>



<h3 id="light_p7_3_5">7.3.5. Функция-член <span class="cpp">SetCRLFCorrection</span> &ndash; установка способа обработки переводов строк</h3>

<p>Функция <span class="cpp">SetCRLFCorrection</span> устанавливает способ обработки переводов
строк в загружаемых текстах. Ее нужно вызывать до загрузки данных, т.е. перед вызовом функции
<a href="#light_p7_3_6"><span class="cpp">LoadGroup</span></a> или
<a href="#light_p7_3_7"><span class="cpp">LoadObject</span></a>.</p>

<pre class="cpp">  <span class="kw">void</span> SetCRLFCorrection(
    <span class="kw">int</span> mode     <span class="rem">// Способ обработки</span>
  );</pre>

<p class="apphdr">Параметр</p>

<dl>
  <dt><span class="cpp">mode</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Одна из констант <span class="cpp">RDS_UIMOD_CRLF_*</span>, указывающая способ
  обработки переводов строк:
    <div class="tableleft"><div class="tcont">
      <table class="list">
        <tr>
          <td class="term"><span class="cpp">RDS_UIMOD_CRLF_ANY</span></td>
          <td>Переводы строк в текстах никак не обрабатываются и остаются в точности такими, какими
          их записал создатель двоичного файла (переводчик).</td>
        </tr>
        <tr>
          <td class="term"><span class="cpp">RDS_UIMOD_CRLF_LF</span></td>
          <td>Переводы строк вида &laquo;\r\n&raquo; заменяются на одиночный код &laquo;\n&raquo;.</td>
        </tr>
        <tr>
          <td class="term"><span class="cpp">RDS_UIMOD_CRLF_BOTH</span></td>
          <td>Переводы строк вида &laquo;\n&raquo; заменяются на сочетание &laquo;\r\n&raquo;.</td>
        </tr>
        <tr>
          <td class="term"><span class="cpp">RDS_UIMOD_CRLF_NONE</span></td>
          <td>Любые переводы строк заменяются на пробелы.</td>
        </tr>
      </table>
    </div></div>
  </dd>
</dl>

<p class="apphdr">Примечания</p>
<p>Функция используется для того, чтобы загрузить тексты с переводами строк из двоичного файла
в формате, требуемом программой модели блока. Требуемый формат определяется разработчиком модели.</p>


<h3 id="light_p7_3_6">7.3.6. Функция-член <span class="cpp">LoadGroup</span> &ndash; загрузка всех данных одной группы</h3>

<p>Функция <span class="cpp">LoadGroup</span> загружает в объект группу объектов интерфейса
из заранее установленного двоичного файла. После загрузки можно считывать различные параметры
объектов из этой группы.</p>

<pre class="cpp">  <span class="kw">void</span> LoadGroup(
    LPCSTR group     <span class="rem">// Имя группы</span>
  );</pre>

<p class="apphdr">Параметр</p>

<dl>
  <dt><span class="cpp">group</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка с именем загружаемой группы.</dd>
</dl>

<p class="apphdr">Примечания</p>
<p>Эта функция обычно используется в тех случаях, когда предполагается работа с несколькими объектами.
Например, при открытии окна настройки блока имеет смысл загрузить группу, в которой находятся тексты
заголовков объектов, соответствующих полям ввода этого окна, а затем считывать из загруженных
данных тексты для каждого поля.</p>

<p>Имя файла передается объекту заранее либо в
<a href="#light_p7_3_1">конструкторе</a> с параметром, либо вызовом
<a href="#light_p7_3_2"><span class="cpp">SetBinaryFile</span></a>. Успешность загрузки можно
узнать при помощи функций
<a href="#light_p7_3_4"><span class="cpp">IsLoaded</span> и
<span class="cpp">IsNotLoaded</span></a>.</p>


<h3 id="light_p7_3_7">7.3.7. Функция-член <span class="cpp">LoadObject</span> &ndash; загрузка одного объекта</h3>

<p>Функция <span class="cpp">LoadObject</span> загружает в объект данные единственного указанного
в параметрах объекта интерфейса из заранее установленного двоичного файла. После загрузки
можно считывать различные параметры этого объекта.</p>

<pre class="cpp">  <span class="kw">void</span> LoadObject(
    LPCSTR group,    <span class="rem">// Имя группы</span>
    LPCSTR object    <span class="rem">// Имя объекта</span>
  );</pre>

<p class="apphdr">Параметры</p>

<dl>
  <dt><span class="cpp">group</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка с именем загружаемой группы.</dd>

  <dt><span class="cpp">object</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка с именем объекта.</dd>
</dl>

<p class="apphdr">Примечания</p>
<p>Эта функция обычно используется в тех случаях, когда предполагается работа с единственным объектом.
Например, при выводе сообщения пользователю обычно достаточно загрузить только текст этого сообщения,
не загружая остальные объекты в группе, в которой этот текст находится.</p>

<p>Имя файла передается объекту заранее либо в
<a href="#light_p7_3_1">конструкторе</a> с параметром, либо вызовом
<a href="#light_p7_3_2"><span class="cpp">SetBinaryFile</span></a>. Успешность загрузки можно
узнать при помощи функций
<a href="#light_p7_3_4"><span class="cpp">IsLoaded</span> и
<span class="cpp">IsNotLoaded</span></a>. Если объект был загружен успешно, в
дальнейшем можно использовать функции чтения значений его параметров без указания имени.</p>

<p>Все тексты, загруженные в объект до вызова этой функции, стираются из памяти
и заменяются загруженными.</p>




<h3 id="light_p7_3_8">7.3.8. Функция-член <span class="cpp">SetObject</span> &ndash; установка имени объекта для дальнейшего обращения к нему без имени</h3>

<p>Функция <span class="cpp">SetObject</span> запоминает имя текущего объекта для дальнейшего
обращения к нему без имени. Ее можно вызывать только после
<a href="#light_p7_3_6"><span class="cpp">LoadGroup</span></a>, поскольку любые функции
загрузки сбрасывают имя текущего объекта.</p>

<pre class="cpp">  <span class="kw">void</span> SetObject(
    LPCSTR object    <span class="rem">// Имя объекта</span>
  );</pre>

<p class="apphdr">Параметр</p>

<dl>
  <dt><span class="cpp">object</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка с именем объекта.</dd>
</dl>

<p class="apphdr">Примечания</p>
<p>Эта функция обычно используется в тех случаях, когда требуется считать несколько параметров
одного и того же объекта, чтобы не передавать имя объекта при каждом обращении.</p>


<h3 id="light_p7_3_9">7.3.9. Функция-член <span class="cpp">GetString</span> &ndash; получение текста значения параметра из считанных данных</h3>

<p>Функция <span class="cpp">GetString</span> возвращает строку значения указанного параметра
указанного объекта из уже загруженной группы
(см. <a href="#light_p7_3_6"><span class="cpp">LoadGroup</span></a>) или одиночного объекта
(см. <a href="#light_p7_3_7"><span class="cpp">LoadObject</span></a>). Она
существует в двух вариантах &ndash; с указанием имени объекта и без указания (в этом
случае возвращается значение параметра текущего объекта).</p>

<pre class="cpp">  <span class="kw">char</span> *GetString(
    LPCSTR object,   <span class="rem">// Имя объекта</span>
    <span class="kw">int</span> paramid,     <span class="rem">// Идентификатор параметра</span>
    LPCSTR defval    <span class="rem">// Значение по умолчанию</span>
  );</pre>

<pre class="cpp">  <span class="kw">char</span> *GetString(
    <span class="kw">int</span> paramid,     <span class="rem">// Идентификатор параметра</span>
    LPCSTR defval    <span class="rem">// Значение по умолчанию</span>
  );</pre>


<p class="apphdr">Параметры</p>

<dl>
  <dt><span class="cpp">object</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка с именем объекта (в первом варианте функции).</dd>

  <dt><span id="RDSHELPERLANG"><span class="cpp">paramid</span>&emsp;(<span class="cpp"><i>int</i></span>)</span></dt>
  <dd>Целый идентификатор параметра или константа <span class="cpp">RDS_UIMOD_ANYPARAMID</span>
  для чтения значения первого попавшегося параметра (используется в тех случаях, когда у объекта
  есть только один параметр). Идентификаторы параметров указываются в секции
  &laquo;$Params&raquo; <a href="#light_p2">файла описания интерфейса</a>. В файле
  &laquo;RdsClasses.hpp&raquo; описаны константы <span class="cpp" id="light_RDSHELPERLANG">RDSHELPERLANG_*</span>
  для идентификаторов, используемых в стандартных файлах описаний RDS. Для единообразия можно
  использовать их:
  <div class="tableleft"><div class="tcont">
  <table>
    <tr>
      <th>Константа</th>
      <th>Значение</th>
      <th>Обычное использование</th>
    </tr>
    <tr>
      <td><span class="cpp">RDSHELPERLANG_CAPTION</span></td>
      <td class="center">1</td>
      <td>Заголовки окон и полей ввода</td>
    </tr>
    <tr>
      <td><span class="cpp">RDSHELPERLANG_TEXT</span></td>
      <td class="center">2</td>
      <td>Тексты сообщений пользователю и прочие</td>
    </tr>
    <tr>
      <td><span class="cpp">RDSHELPERLANG_HINT</span></td>
      <td class="center">3</td>
      <td>Всплывающие подсказки</td>
    </tr>
    <tr>
      <td><span class="cpp">RDSHELPERLANG_FILTER</span></td>
      <td class="center">4</td>
      <td>Фильтры (списки файлов) для диалогов</td>
    </tr>
    <tr>
      <td><span class="cpp">RDSHELPERLANG_TITLE</span></td>
      <td class="center">5</td>
      <td>Прочие заголовки</td>
    </tr>
    <tr>
      <td><span class="cpp">RDSHELPERLANG_STRING</span></td>
      <td class="center">6</td>
      <td>Строки общего назначения</td>
    </tr>
    <tr>
      <td><span class="cpp">RDSHELPERLANG_LIST</span></td>
      <td class="center">7</td>
      <td>Выпадающие списки</td>
    </tr>
  </table>
  </div></div>
  </dd>

  <dt><span class="cpp">defval</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка, возвращаемая при отсутствии параметра, объекта или любых загруженных данных.</dd>
</dl>

<p class="apphdr">Возвращаемое значение</p>
<p>Если данные из двоичного файла перевода были ранее загружены успешно, в этих данных есть указанный
объект (при использовании первого варианта функции) или был установлен текущий (при использовании
второго варианта функции), и у этого объекта есть указанный параметр, возвращается указатель на
строку во внутренних данных объекта с текстовым значением этого параметра. Эта строка будет
существовать до уничтожения объекта или до загрузки в него новых данных. Если же указанного
параметра нет, возвращается переданный в параметрах функции указатель <span class="cpp">defval</span>.</p>

<p class="apphdr">Примечания</p>
<p>Это основная функция получения переведенных строк из загруженных данных. Строка на языке
по умолчанию (русском) передается в параметре <span class="cpp">defval</span>. Если перевод
успешно загружен, возвращается переведенная строка, если нет &ndash; строка по умолчанию.</p>


<h3 id="light_p7_3_10">7.3.10. Функция-член <span class="cpp">GetListString</span> &ndash; получение текста содержимого выпадающего списка из считанных данных</h3>

<p>Функция <span class="cpp">GetListString</span> преобразует строку описания выпадающего списка формата
&laquo;0=вариант1\n1=вариант2\n&hellip;&raquo; из указанного параметра указанного
объекта уже загруженной группы (см. <a href="#light_p7_3_6"><span class="cpp">LoadGroup</span></a>) или одиночного объекта
(см. <a href="#light_p7_3_7"><span class="cpp">LoadObject</span></a>) в строку вида
&laquo;вариант1\nвариант2\n&hellip;&raquo;, пригодную для передачи в оконные объекты RDS
(см. приложение А.5.28.18). Функция существует в двух вариантах &ndash;
с указанием имени объекта и без указания (в этом случае возвращается значение параметра текущего объекта).</p>

<pre class="cpp">  <span class="kw">char</span> *GetListString(
    LPCSTR object    <span class="rem">// Имя объекта</span>
    <span class="kw">int</span> paramid,     <span class="rem">// Идентификатор параметра</span>
    LPCSTR defval    <span class="rem">// Значение по умолчанию</span>
  );</pre>

<pre class="cpp">  <span class="kw">char</span> *GetListString(
    <span class="kw">int</span> paramid,     <span class="rem">// Идентификатор параметра</span>
    LPCSTR defval    <span class="rem">// Значение по умолчанию</span>
  );</pre>

<dl>
  <dt><span class="cpp">object</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка с именем объекта (в первом варианте функции).</dd>

  <dt><span class="cpp">paramid</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Целый идентификатор параметра или константа <span class="cpp">RDS_UIMOD_ANYPARAMID</span>
  для чтения значения первого попавшегося параметра (используется в тех случаях, когда у объекта
  есть только один параметр). Идентификаторы параметров указываются в секции
  &laquo;$Params&raquo; <a href="#light_p2">файла описания интерфейса</a>. В файле
  &laquo;RdsClasses.hpp&raquo; описаны <a href="#RDSHELPERLANG">константы</a>
  <span class="cpp">RDSHELPERLANG_*</span>
  для идентификаторов, используемых в стандартных файлах описаний RDS.</dd>

  <dt><span class="cpp">defval</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка, возвращаемая при отсутствии параметра, объекта или любых загруженных данных.</dd>
</dl>

<p class="apphdr">Возвращаемое значение</p>
<p>Если данные из двоичного файла перевода были ранее загружены успешно,
в этих данных есть указанный объект, и у этого объекта есть указанный параметр, из этого
параметра считывается текст <a href="#light_combolist">описания выпадающего списка</a> формата
&laquo;0=вариант1\n1=вариант2\n&hellip;&raquo;. Затем в переданном тексте
<span class="cpp">defval</span> формата &laquo;вариант1\nвариант2\n&hellip;&raquo;
отдельные строки заменяются на считанные согласно индексам перед знаком равенства, получившаяся
строка сохраняется во внутренних данных объекта, и возвращается указатель на нее. Эта строка
будет существовать до уничтожения объекта или до загрузки в него новых данных. Если
же указанного параметра в загруженных данных нет, возвращается переданный в параметрах
функции указатель <span class="cpp">defval</span>.</p>

<p class="apphdr">Примечания</p>
<p>Эта функция используется для перевода вариантов выпадающих списков для полей ввода RDS в
окнах настройки блоков. Ее действие аналогично действию сервисной функции RDS
<a href="#light_p7_2_8"><span class="cpp">rdsUIMODGetParamListString</span></a>.</p>


<h3 id="light_p7_3_11">7.3.11. Статическая функция <span class="cpp">MessageBox</span> &ndash; вывод сообщения с переведенным текстом</h3>

<p>Статическая функция <span class="cpp">MessageBox</span> выводит пользователю сообщение,
текст которого, при наличии перевода, берется из первого попавшегося параметра заданного объекта
заданного файла перевода.</p>

<pre class="cpp">  <span class="kw">static</span> <span class="kw">int</span> MessageBox(
    LPCSTR filepath     <span class="rem">// Имя двоичного файла</span>
    LPCSTR message,     <span class="rem">// Текст сообщения по умолчанию</span>
    LPCSTR caption,     <span class="rem">// Заголовок окна сообщения</span>
    <span class="kw">int</span> flags,          <span class="rem">// Флаги Windows API (MB_*)</span>
    LPCSTR object       <span class="rem">// Имя объекта</span>
    LPCSTR group=NULL   <span class="rem">// Имя группы</span>
  );</pre>

<p class="apphdr">Параметры</p>

<dl>
  <dt><span class="cpp">filepath</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Имя двоичного файла для загрузки текстов перевода. В имени можно использовать любые
  символические имена папок RDS, включая &laquo;$CURLANG$&raquo; для пути к
  папке с данными текущего языка интерфейса.</dd>

  <dt><span class="cpp">message</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка с текстом сообщения на языке по умолчанию.</dd>

  <dt><span class="cpp">caption</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка с заголовком окна сообщения или <span class="cpp">NULL</span> для стандартного (&laquo;RDS&raquo;).</dd>

  <dt><span class="cpp">flags</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Битовые флаги сообщения, определяющие набор кнопок в окне, иконку сообщения и т.п.
  (приложение А.5.5.6).</dd>

  <dt><span class="cpp">object</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Строка с именем объекта.</dd>

  <dt><span class="cpp">group</span>&emsp;(<span class="cpp"><i>LPCSTR</i></span>)</dt>
  <dd>Необязательный параметр &ndash; строка с именем группы. Если параметр опущен, будет
  загружаться объект из группы &laquo;Messages&raquo;.</dd>
</dl>

<p class="apphdr">Возвращаемое значение</p>
<p>Стандартная константа Windows API <span class="cpp">ID*</span>,
указывающая на нажатую пользователем кнопку окна сообщения.</p>

<p class="apphdr">Примечания</p>
<p>Эта статическая функция позволяет упростить вывод переведенных сообщений пользователю, если
у объекта с текстом сообщения в двоичном файле есть только один параметр (собственно текст)
и если заголовок сообщения переводить не нужно. Ее параметры, за исключением
<span class="cpp">filepath</span>, <span class="cpp">object</span> и <span class="cpp">group</span>,
совпадают с параметрами сервисной функции RDS <span class="cpp">rdsMessageBox</span> (приложение А.5.5.6).</p>

<p>Поскольку функция статическая, для ее вызова не требуется создавать объект типа
<span class="cpp">TRdsHelperLanguage</span>. Ее можно вызвать с указанием префикса класса, т.е.
&laquo;<span class="cpp">TRdsHelperLanguage::MessageBox(&hellip;);</span>&raquo;.</p>

<p>Пусть в <a href="#light_p2">файле описания интерфейса</a> текст сообщения
пользователю задан следующим образом:</p>

<pre class="cpp">  [UserMessages]
  &hellip;
  TestMessage.Text=Сообщение пользователю
  &hellip;</pre>

<p>Пусть по этому файлу создан
<a href="#light_p4">двоичный файл перевода</a> &laquo;MyDll.bin&raquo;, находящийся в
подпапке &laquo;Dll&raquo; папки текущего языка. Тогда функцию вывода этого сообщения
со стандартным заголовком окна можно записать так:</p>

<pre class="cpp">  TRdsHelperLanguage::MessageBox(
    <span class="str">"$CURLANG$&#92;&#92;Dll&#92;&#92;MyDll.bin"</span>,  <span class="rem">// файл</span>
    <span class="str">"Сообщение пользователю"</span>,     <span class="rem">// текст по умолчанию</span>
    NULL,                         <span class="rem">// заголовок (стандартный)</span>
    MB_OK|MB_ICONINFORMATION,     <span class="rem">// флаги сообщения</span>
    <span class="str">"TestMessage"</span>,                <span class="rem">// объект</span>
    <span class="str">"UserMessages"</span>);              <span class="rem">// группа</span></pre>

<p>Если бы объект &laquo;TestMessage&raquo; с текстом сообщения находился в группе
&laquo;Messages&raquo;, а не в &laquo;UserMessages&raquo;, последний параметр функции
можно было бы не указывать.</p>

<p>Если у объекта с текстом сообщения несколько параметров, или если у окна сообщения должен
быть заголовок, который тоже нужно переводить, эту функцию использовать не следует. Вместо этого
нужно создать объект класса <span class="cpp">TRdsHelperLanguage</span>, загрузить в него объект
вызовом <a href="#light_p7_3_7"><span class="cpp">LoadObject</span></a>, а затем считать
переведенные тексты сообщения и заголовка вызовами
<a href="#light_p7_3_9"><span class="cpp">GetString</span></a>.</p>



<h2 id="light_p7_4">7.4. Пример модели с переводом интерфейса пользователя</h2>

<p>Рассмотрим пример модели блока с окном настроек, интерфейс пользователя которой нужно перевести.
Сначала будет приведен пример модели без перевода, а затем в нее будут добавлены пеерводы при помощи
сервисных функций RDS и при помощи вспомогательного класса.</p>


<h3 id="light_p7_4_1">7.4.1. Исходная модель без перевода</h3>

<p>Рассмотрим простую модель блока следующего вида (главная функция DLL в примере не приводится).</p>

<pre class="cpp"><span class="rem">//====== Класс личной области данных ======</span>
<span class="kw">class</span> TTestLData
{ <span class="kw">public</span>:
    <span class="kw">int</span> IOption;          <span class="rem">// Номер варианта</span>
    <span class="kw">double</span> DParam;        <span class="rem">// Вещественный параметр</span>
    <span class="kw">int</span> Setup(<span class="kw">void</span>);      <span class="rem">// Функция настройки параметров</span>
    <span class="kw">void</span> MouseDown(<span class="kw">void</span>); <span class="rem">// Реакция на мышь</span>
    TTestLData(<span class="kw">void</span>)      <span class="rem">// Конструктор класса</span>
      { IOption=<span class="const">0</span>; DParam=<span class="const">0</span>.<span class="const">0</span>; };
};
<span class="rem">//=========================================</span>

<span class="rem">//============= Модель блока ==============</span>
<span class="kw">extern</span> <span class="str">"C"</span> <span class="kw">__declspec</span>(<span class="kw">dllexport</span>)
  <span class="kw">int</span> RDSCALL TestL(<span class="kw">int</span> CallMode, <span class="rem">// Режим вызова (событие в RDS)</span>
                    RDS_PBLOCKDATA BlockData, <span class="rem">// Структура данных</span>
                    LPVOID <span class="rem">/*ExtParam*/</span>) <span class="rem">// Доп.параметр</span>
{ TTestLData *data=(TTestLData*)(BlockData->BlockData);
  <span class="kw">switch</span>(CallMode)
    { <span class="kw">case</span> RDS_BFM_INIT:      <span class="rem">// Инициализация</span>
        BlockData->BlockData=<span class="kw">new</span> TTestLData();
        <span class="kw">break</span>;
      <span class="kw">case</span> RDS_BFM_CLEANUP:   <span class="rem">// Очистка</span>
        <span class="kw">delete</span> data;
        <span class="kw">break</span>;
      <span class="kw">case</span> RDS_BFM_SETUP:     <span class="rem">// Функция настройки</span>
        <span class="kw">return</span> data->Setup();
      <span class="kw">case</span> RDS_BFM_MOUSEDOWN: <span class="rem">// Кнопка мыши</span>
        data->MouseDown();
        <span class="kw">break</span>;
    }
  <span class="kw">return</span> RDS_BFR_DONE;
}
<span class="rem">//=========================================</span>

<span class="rem">// Функция настройки параметров</span>
<span class="kw">int</span> TTestLData::Setup(<span class="kw">void</span>)
{ RDS_HOBJECT window; <span class="rem">// Идентификатор объекта-окна</span>
  BOOL ok;            <span class="rem">// Пользователь нажал "OK"</span>
  <span class="rem">// Создание окна</span>
  window=rdsFORMCreate(FALSE,-<span class="const">1</span>,-<span class="const">1</span>,
             <span class="str">"Ввод параметров"</span>);
  <span class="rem">// Добавление полей ввода</span>
  rdsFORMAddEdit(window,<span class="const">0</span>,<span class="const">1</span>,RDS_FORMCTRL_COMBOLIST,
      <span class="str">"Номер варианта:"</span>,<span class="const">200</span>);
  rdsSetObjectStr(window,<span class="const">1</span>,RDS_FORMVAL_LIST,
      <span class="str">"Первый вариант\nВторой вариант\nТретий вариант"</span>);
  rdsFORMAddEdit(window,<span class="const">0</span>,<span class="const">2</span>,RDS_FORMCTRL_EDIT,
      <span class="str">"Вещественный параметр:"</span>,<span class="const">80</span>);
  <span class="rem">// Занесение исходных значений в поля ввода</span>
  rdsSetObjectInt(window,<span class="const">1</span>,RDS_FORMVAL_VALUE,IOption);
  rdsSetObjectDouble(window,<span class="const">2</span>,RDS_FORMVAL_VALUE,DParam);
  <span class="rem">// Открытие окна</span>
  ok=rdsFORMShowModalEx(window,NULL);
  <span class="kw">if</span>(ok)
    { <span class="rem">// Нажата кнопка OK - запись параметров обратно в блок</span>
      IOption=rdsGetObjectInt(window,<span class="const">1</span>,RDS_FORMVAL_VALUE);
      DParam=rdsGetObjectDouble(window,<span class="const">2</span>,RDS_FORMVAL_VALUE);
    }
  <span class="rem">// Уничтожение окна</span>
  rdsDeleteObject(window);
  <span class="rem">// Возвращаемое значение</span>
  <span class="kw">return</span> ok?RDS_BFR_MODIFIED:RDS_BFR_DONE;
}
<span class="rem">//=========================================</span>

<span class="rem">// Нажатие кнопки мыши</span>
<span class="kw">void</span> TTestLData::MouseDown(<span class="kw">void</span>)
{
  rdsMessageBox(<span class="str">"Нажата кнопка мыши"</span>,NULL,
      MB_OK|MB_ICONINFORMATION);
}
<span class="rem">//=========================================</span></pre>

<p>В этой модели личная область данных оформлена в виде класса <span class="cpp">TTestLData</span>
с двумя полями: целым <span class="cpp">IOption</span> и вещественным
<span class="cpp">DParam</span>, которые задаются в окне настроек блока. Не будем подробно
останавливаться на структуре этой модели &ndash; подобные модели во множестве рассматриваются в
руководстве программиста.</p>

<p>Тексты интерфейса пользователя, которые необходимо перевести, находятся в функциях
<span class="cpp">TTestLData::Setup</span> и <span class="cpp">TTestLData::MouseDown</span>. В
функции <span class="cpp">TTestLData::Setup</span> открывается окно настроек блока, все
заголовки полей котрого (строки в двойных кавычках) необходимо перевести. В
<span class="cpp">TTestLData::MouseDown</span> при нажатии кнопки мыши выводится сообщение
пользователю, текст которого также необходимо перевести.</p>



<h3 id="light_p7_4_2">7.4.2. Создание файла описания интерфейса и файла перевода</h3>

<p>Создадим для этой модели
<a href="#light_p2">файл описания интерфейса пользователя</a> следующего вида:</p>

<pre class="cpp">[$Types]
Language=Caption,Text,Hint,Filter,Title,String,List

[$Params]
Caption=S,1
Text=S,2
Hint=S,3
Filter=S,4
Title=S,5
String=S,6
List=S,7

[TTestLData]
; Тестовый блок
Setup.Caption=Ввод параметров
IOption.Caption=Номер варианта:
IOption.List=0=Первый вариант\n1=Второй вариант\n2=Третий вариант
DParam.Caption=Вещественный параметр:
MouseDownMessage.Text=Нажата кнопка мыши</pre>

<p>Секции &laquo;$Types&raquo; и &laquo;$Params&raquo; этого файла скопированы из
&laquo;rds.dat&raquo;, поэтому в нем будут использоваться стандартные для файлов описания
интерфейса имена и идентификаторы параметров. В секции &laquo;TTestLData&raquo;
каждой из строк в кавычках, используемых в программе модели, соответствует какой-либо параметр
какого-либо объекта. Например, заголовок окна настроек присвоен параметру
&laquo;Caption&raquo; объекта &laquo;Setup&raquo;, сообщение пользователю о нажатии кнопки
мыши &ndash; параметру &laquo;Text&raquo; объекта &laquo;MouseDownMessage&raquo; и т.д.</p>

<p>Следует обратить внимание на содержимое выпадающего списка для параметра <span class="cpp">IOption</span>,
которое присвоено параметру &laquo;List&raquo; объекта &laquo;IOption&raquo;.
Оно отличается от строки в модели тем, что туда
<a href="#light_combolist">добавлены индексы для каждого варианта</a>, т.е.
&laquo;0=&hellip;&raquo;, &laquo;1=&hellip;&raquo; и т.д.</p>

<p>Поместим этот файл в папку &laquo;Description\Dll\&raquo; внутри папки установки RDS и
дадим ему имя &laquo;MyDll.dat&raquo;.</p>

<p>На данный момент в RDS добавлен английский язык интерфейса пользователя с именем &laquo;English&raquo;.
<a href="#light_p4_1">Экспортируем</a> файл описания
&laquo;Dll\MyDll.dat&raquo; в
<a href="#light_p4_2">INI-файл</a> для перевода, в результате чего получим файл со
следующим содержимым:</p>

<pre class="cpp">[$Descr]
Type=Language
Mod=English
Dat=Dll*MyDll.dat

[TTestLData]
DParam.Caption=Вещественный параметр:
IOption.Caption=Номер варианта:
IOption.List=0=Первый вариант\n1=Второй вариант\n2=Третий вариант
MouseDownMessage.Text=Нажата кнопка мыши
Setup.Caption=Ввод параметров</pre>

<p>Откроем его в любом текстовом редакторе и переведем на английский язык все значения
параметров в секции &laquo;TTestLData&raquo;:</p>

<pre class="cpp">[$Descr]
Type=Language
Mod=English
Dat=Dll*MyDll.dat

[TTestLData]
DParam.Caption=Real parameter:
IOption.Caption=Option:
IOption.List=0=First option\n1=Second option\n2=Third option
MouseDownMessage.Text=Mouse button pressed
Setup.Caption=Parameters</pre>

<p>Теперь <a href="#light_p4_4">импортируем</a> этот файл для описания
&laquo;Dll\MyDll.dat&raquo;. В папке
&laquo;Interface\Language\English\Dll\&raquo; появится двоичный файл
&laquo;MyDll.bin&raquo;, из которого можно загружать тексты окна настроек и сообщения
пользователю на английском языке. В общем виде путь к файлу перевода нашей модели для текущего языка
будет записываться как
&laquo;$CURLANG$\\Dll\\MyDll.bin&raquo;: если текущим языком будет английский, этот
путь будет указывать на только что импортированный нами файл.</p>



<h3 id="light_p7_4_3">7.4.3. Загрузка перевода сервисными функциями RDS</h3>

<p>Для того, чтобы добавить в модель блока функции загрузки перевода, достаточно изменить только
те части модели, в которых есть строки текста для интерфейса пользователя. В нашем случае это
<span class="cpp">TTestLData::Setup</span> и
<span class="cpp">TTestLData::MouseDown</span>. Перепишем их (изменения выделены
<span class="changes">цветом</span>):</p>


<pre class="cpp">  <span class="rem">// Функция настройки параметров</span>
  <span class="kw">int</span> TTestLData::Setup(<span class="kw">void</span>)
  { RDS_HOBJECT window; <span class="rem">// Идентификатор объекта-окна</span>
    BOOL ok;            <span class="rem">// Пользователь нажал "OK"</span>
    <span class="changes">RDS_HOBJECT lang;   <span class="rem">// Перевод интерфейса</span></span>

    <span class="changes"><span class="rem">// Загрузка группы "TTestLData" из языкового файла</span></span>
    <span class="changes">lang=<a href="#light_p7_2_4" class="hidden">rdsUIMODCreate</a>();</span>
    <span class="changes"><a href="#light_p7_2_5" class="hidden">rdsUIMODLoadGroup</a>(lang,<span class="str">"$CURLANG$\\Dll\\MyDll.bin"</span>,<span class="str">"TTestLData"</span>);</span>

    <span class="rem">// Создание окна</span>
    window=rdsFORMCreate(FALSE,-<span class="const">1</span>,-<span class="const">1</span>,
             <span class="changes"><a href="#light_p7_2_7" class="hidden">rdsUIMODGetParamString</a>(lang,<span class="str">"Setup"</span>,</span>
               <span class="changes">RDS_UIMOD_ANYPARAMID,</span>
               <span class="str">"Ввод параметров"</span><span class="changes">)</span>);
    <span class="rem">// Добавление полей ввода</span>
    rdsFORMAddEdit(window,<span class="const">0</span>,<span class="const">1</span>,RDS_FORMCTRL_COMBOLIST,
        <span class="changes"><a href="#light_p7_2_7" class="hidden">rdsUIMODGetParamString</a>(lang,<span class="str">"IOption"</span>,<span class="const">1</span>,</span><span class="str">"Номер варианта:"</span><span class="changes">)</span>,
        <span class="const">200</span>);
    rdsSetObjectStr(window,<span class="const">1</span>,RDS_FORMVAL_LIST,
        <span class="changes"><a href="#light_p7_2_8" class="hidden">rdsUIMODGetParamListString</a>(lang,<span class="str">"IOption"</span>,<span class="const">7</span>,</span>
          <span class="str">"Первый вариант\nВторой вариант\nТретий вариант"</span><span class="changes">)</span>);
    rdsFORMAddEdit(window,<span class="const">0</span>,<span class="const">2</span>,RDS_FORMCTRL_EDIT,
        <span class="changes"><a href="#light_p7_2_7" class="hidden">rdsUIMODGetParamString</a>(lang,<span class="str">"DParam"</span>,</span>
          <span class="changes">RDS_UIMOD_ANYPARAMID,</span><span class="str">"Вещественный параметр:"</span><span class="changes">)</span>,
        <span class="const">80</span>);
    <span class="rem">// Занесение исходных значений в поля ввода</span>
    rdsSetObjectInt(window,<span class="const">1</span>,RDS_FORMVAL_VALUE,IOption);
    rdsSetObjectDouble(window,<span class="const">2</span>,RDS_FORMVAL_VALUE,DParam);
    <span class="rem">// Открытие окна</span>
    ok=rdsFORMShowModalEx(window,NULL);
    <span class="kw">if</span>(ok)
      { <span class="rem">// Нажата кнопка OK - запись параметров обратно в блок</span>
        IOption=rdsGetObjectInt(window,<span class="const">1</span>,RDS_FORMVAL_VALUE);
        DParam=rdsGetObjectDouble(window,<span class="const">2</span>,RDS_FORMVAL_VALUE);
      }
    <span class="rem">// Уничтожение окна</span>
    rdsDeleteObject(window);
    <span class="changes"><span class="rem">// Уничтожение интерфейсного объекта</span></span>
    <span class="changes">rdsDeleteObject(lang);</span>
    <span class="rem">// Возвращаемое значение</span>
    <span class="kw">return</span> ok?RDS_BFR_MODIFIED:RDS_BFR_DONE;
  }
  <span class="rem">//=========================================</span>

  <span class="rem">// Реакция на мышь</span>
  <span class="kw">void</span> TTestLData::MouseDown(<span class="kw">void</span>)
  { <span class="changes">RDS_HOBJECT lang; <span class="rem">// Перевод интерфейса</span></span>

    <span class="changes"><span class="rem">// Загрузка одного объекта интерфейса</span></span>
    <span class="changes">lang=<a href="#light_p7_2_4" class="hidden">rdsUIMODCreate</a>();</span>
    <span class="changes"><a href="#light_p7_2_6" class="hidden">rdsUIMODLoadSingleObject</a>(lang,<span class="str">"$CURLANG$\\Dll\\MyDll.bin"</span>,</span>
      <span class="changes"><span class="str">"TTestLData"</span>,<span class="str">"MouseDownMessage"</span>);</span>

    rdsMessageBox(
      <span class="changes"><a href="#light_p7_2_7" class="hidden">rdsUIMODGetParamString</a>(lang,NULL,</span>
          <span class="changes">RDS_UIMOD_ANYPARAMID,</span><span class="str">"Нажата кнопка мыши"</span><span class="changes">)</span>,
      NULL,MB_OK|MB_ICONINFORMATION);

    <span class="changes"><span class="rem">// Уничтожение интерфейсного объекта</span></span>
    <span class="changes">rdsDeleteObject(lang);</span>
  }
  <span class="rem">//=========================================</span></pre>

<p>В функцию <span class="cpp">TTestLData::Setup</span> добавлен новый вспомогательный объект
<span class="cpp">lang</span>, который создается вызовом
<a href="#light_p7_2_4"><span class="cpp">rdsUIMODCreate</span></a>. Затем вызовом
<a href="#light_p7_2_5"><span class="cpp">rdsUIMODLoadGroup</span></a> в него
загружается группа объектов &laquo;TTestLData&raquo; из файла
&laquo;$CURLANG$\\Dll\\MyDll.bin&raquo;, т.е. из файла
&laquo;MyDll.bin&raquo; подпапки
&laquo;Dll&raquo; в папке текущего языка интерфейса пользователя. Если текущий язык
&ndash; английский, будут загружены данные из созданного нами файла &laquo;MyDll.bin&raquo;,
и все последующие вызовы будут возвращать тексты из этого файла. Если текущий язык &ndash; любой
другой, включая русский, соответствующий файл найден не будет, и данные не загрузятся. В результате
все последующие вызовы будут возвращать переданные в параметрах строки по умолчанию, т.е.
тексты на русском языке.</p>

<p>Далее везде в функциях, где раньше стояли строки в двойных кавычках, теперь вместо самих строк
записаны вызовы сервисных функций
<a href="#light_p7_2_7"><span class="cpp">rdsUIMODGetParamString</span></a> или
<a href="#light_p7_2_8"><span class="cpp">rdsUIMODGetParamListString</span></a>, в которые
прежние строки передаются как параметры по умолчанию. Для тех объектов, у которых в нашем
файле описания интерфейса есть только один параметр (&laquo;Setup&raquo; и
&laquo;DParam&raquo;) в качестве идентификатора параметра передается константа
<span class="cpp">RDS_UIMOD_ANYPARAMID</span>. У объекта
&laquo;IOption&raquo; два параметра: заголовок поля ввода
&laquo;Caption&raquo; с идентификатором 1 и содержимое списка
&laquo;List&raquo; с идентификатором 7. Из-за этого в вызовы функций получения текстов для
&laquo;IOption&raquo; передаются конкретные числа 1 и 7 &ndash; считывать
&laquo;первый попавшийся&raquo; параметр нельзя.</p>

<p>В самом конце функции <span class="cpp">TTestLData::Setup</span> созданный объект <span class="cpp">lang</span>
уничтожается вызовом <span class="cpp">rdsDeleteObject</span>. Уничтожать его раньше нельзя,
поскольку необходимые окну настройки тексты, загруженные из двоичного файла перевода, хранятся
в его внутренней памяти и будут уничтожены месте с ним.</p>

<p>В функции <span class="cpp">TTestLData::MouseDown</span> переведенный текст сообщения пользователю
точно таким же образом загружается из объекта &laquo;MouseDownMessage&raquo; той же секции
&laquo;TTestLData&raquo;.</p>

<p>Внесенных в модель изменений достаточно для того, чтобы при выборе пользователем русского
языка интерфейса RDS окно настройки блока и сообщение были на русском языке, при выборе английского
&ndash; на английском.</p>





<h3 id="light_p7_4_4">7.4.4. Загрузка перевода объектом вспомогательного класса</h3>

<p>Теперь изменим исходную модель так, чтобы переведенные тексты загружались при помощи объекта
<a href="#light_p7_3">класса <span class="cpp">TRdsHelperLanguage</span></a>. Для этого нужно
будет включить в текст модели файл заголовка &laquo;RdsClasses.hpp&raquo; и снова переписать функции
<span class="cpp">TTestLData::Setup</span> и
<span class="cpp">TTestLData::MouseDown</span>. Изменения выделены
<span class="changes">цветом</span>:</p>

<pre class="cpp">  <span class="changes"><span class="rem">// Включение описания вспомогательного класса</span></span>
  <span class="changes"><span class="preproc">#include &lt;RdsClasses.hpp&gt;</span></span>
  <span class="rem">// Функция настройки параметров</span>
  <span class="kw">int</span> TTestLData::Setup(<span class="kw">void</span>)
  { RDS_HOBJECT window; <span class="rem">// Идентификатор бъекта-окна</span>
    BOOL ok;            <span class="rem">// Пользователь нажал "OK"</span>
    <span class="changes"><span class="rem">// Объект перевода интерфейса</span></span>
    <span class="changes"><a href="#light_p7_3_1" class="hidden">TRdsHelperLanguage Lang(<span class="str">"$CURLANG$\\Dll\\MyDll.bin"</span>)</a>;</span>

    <span class="changes"><span class="rem">// Загрузка группы "TTestLData" из языкового файла</span></span>
    <span class="changes">Lang.<a href="#light_p7_3_6" class="hidden">LoadGroup</a>(<span class="str">"TTestLData"</span>);</span>

    <span class="rem">// Создание окна</span>
    window=rdsFORMCreate(FALSE,-<span class="const">1</span>,-<span class="const">1</span>,
               <span class="changes">Lang.<a href="#light_p7_3_9" class="hidden">GetString</a>(<span class="str">"Setup"</span>,</span>
                      <span class="changes">RDS_UIMOD_ANYPARAMID,</span>
                      <span class="str">"Ввод параметров"</span><span class="changes">)</span>);
    <span class="rem">// Добавление полей ввода</span>
    rdsFORMAddEdit(window,<span class="const">0</span>,<span class="const">1</span>,RDS_FORMCTRL_COMBOLIST,
        <span class="changes">Lang.<a href="#light_p7_3_9" class="hidden">GetString</a>(<span class="str">"IOption"</span>,<span class="const">1</span>,</span><span class="str">"Номер варианта:"</span><span class="changes">)</span>,
        <span class="const">200</span>);
    rdsSetObjectStr(window,<span class="const">1</span>,RDS_FORMVAL_LIST,
        <span class="changes">Lang.<a href="#light_p7_3_10" class="hidden">GetListString</a>(<span class="str">"IOption"</span>,<span class="const">7</span>,</span>
               <span class="str">"Первый вариант\nВторой вариант\nТретий вариант"</span><span class="changes">)</span>);
    rdsFORMAddEdit(window,<span class="const">0</span>,<span class="const">2</span>,RDS_FORMCTRL_EDIT,
        <span class="changes">Lang.<a href="#light_p7_3_9" class="hidden">GetString</a>(<span class="str">"DParam"</span>,RDS_UIMOD_ANYPARAMID,</span>
               <span class="str">"Вещественный параметр:"</span><span class="changes">)</span>,
        <span class="const">80</span>);
    <span class="rem">// Занесение исходных значений в поля ввода</span>
    rdsSetObjectInt(window,<span class="const">1</span>,RDS_FORMVAL_VALUE,IOption);
    rdsSetObjectDouble(window,<span class="const">2</span>,RDS_FORMVAL_VALUE,DParam);
    <span class="rem">// Открытие окна</span>
    ok=rdsFORMShowModalEx(window,NULL);
    <span class="kw">if</span>(ok)
      { <span class="rem">// Нажата кнопка OK - запись параметров обратно в блок</span>
        IOption=rdsGetObjectInt(window,<span class="const">1</span>,RDS_FORMVAL_VALUE);
        DParam=rdsGetObjectDouble(window,<span class="const">2</span>,RDS_FORMVAL_VALUE);
      }
    <span class="rem">// Уничтожение окна</span>
    rdsDeleteObject(window);
    <span class="rem">// Возвращаемое значение</span>
    <span class="kw">return</span> ok?RDS_BFR_MODIFIED:RDS_BFR_DONE;
  }
  <span class="rem">//=========================================</span>

  <span class="rem">// Реакция на мышь</span>
  <span class="kw">void</span> TTestLData::MouseDown(<span class="kw">void</span>)
  {
    <span class="changes"><a href="#light_p7_3_11" class="hidden">TRdsHelperLanguage::MessageBox</a>(</span>
      <span class="changes"><span class="str">"$CURLANG$\\Dll\\MyDll.bin"</span>,</span>
      <span class="str">"Нажата кнопка мыши"</span>,
      NULL,
      MB_OK|MB_ICONINFORMATION,
      <span class="changes"><span class="str">"MouseDownMessage"</span>,</span>
      <span class="changes"><span class="str">"TTestLData"</span></span>);
  }
  <span class="rem">//=========================================</span></pre>

<p>В начале функции <span class="cpp">TTestLData::Setup</span> создается объект
<span class="cpp">Lang</span> типа <span class="cpp">TRdsHelperLanguage</span>, причем в
его
<a href="#light_p7_3_1">конструкторе</a> сразу передан путь к двоичному файлу
описания интерфейса пользователя нашей модели для текущего языка
&laquo;$CURLANG$\\Dll\\MyDll.bin&raquo;. Как и в предыдущем примере, если текущий язык
&ndash; английский, дале в программе в <span class="cpp">Lang</span> будут загружены данные
из созданного нами файла &laquo;MyDll.bin&raquo;, и все последующие вызовы функций-членов
этого объекта будут возвращать тексты из этого файла. Если текущий язык
&ndash; любой другой, включая русский, соответствующий файл найден не будет, данные не загрузятся,
и все последующие вызовы будут возвращать переданные в параметрах строки по умолчанию, т.е.
тексты на русском языке.</p>

<p>Для загрузки в объект данных секции &laquo;TTestLData&raquo; используется функция объекта
<span class="cpp">Lang.<a href="#light_p7_3_6">LoadGroup</a></span>.</p>

<p>Далее везде вместо строк в кавычках подставлены вызовы функций-членов объекта
<span class="cpp">Lang.<a href="#light_p7_3_9">GetString</a></span> и
<span class="cpp">Lang.<a href="#light_p7_3_10">GetListString</a></span>,
в которые передаются имена объектов и идентификаторы их параметров для чтения, а также строки
по умолчанию, которые будут возвращаться при отсутствии данных текущего языка или если текущим выбран
язык по умолчанию. Для объектов, у которых только один параметр, вместо идентификатора
этого параметра передается константа <span class="cpp">RDS_UIMOD_ANYPARAMID</span>
(безразлично, данные какого параметра загружать &ndash; все равно он единственный).</p>

<p>В отличие от примера в п. <a href="#light_p7_4_3">7.4.3</a>, в конце функции
<span class="cpp">TTestLData::Setup</span> нет команды уничтожения объекта &ndash; он
уничтожится сам, когда выйдет из области видимости.</p>

<p>В функции <span class="cpp">TTestLData::MouseDown</span> вызов сервисной функции
<span class="cpp">rdsMessageBox</span> заменен на вызов статической функции вспомогательного класса
<span class="cpp">TRdsHelperLanguage</span>
<a href="#light_p7_3_11"><span class="cpp">TRdsHelperLanguage::MessageBox</span></a>,
которая использует собственный объект для загрузки данных. По этой причине описания дополнительного
объекта в функции <span class="cpp">TTestLData::MouseDown</span> нет,
<span class="cpp">TRdsHelperLanguage::MessageBox</span> делает все сама. В нее передается
путь к двоичному файлу перевода
&laquo;$CURLANG$\\Dll\\MyDll.bin&raquo;, имя объекта
&laquo;MouseDownMessage&raquo; и имя группы с этим объектом
&laquo;TTestLData&raquo;, а также флаги сообщения, заголовок его окна и текст сообщения для
языка по умолчанию, с которым вызывалась <span class="cpp">rdsMessageBox</span> в исходной
версии модели. Идентификатор параметра не передается: функция
<span class="cpp">TRdsHelperLanguage::MessageBox</span> требует, чтобы у указанного
в ее вызове объекта был единственный параметр. В нашем случае это выполняется.</p>

<p>Как и в предыдущем примере, внесенных в модель изменений достаточно для того, чтобы
при выборе пользователем русского языка интерфейса RDS окно настройки блока и сообщение были
на русском языке, при выборе английского &ndash; на английском.</p>

<hr />
</div>

<p class="bottom"><a href="index.html#light_uitranslate">Назад</a></p>

</body>
</html>
